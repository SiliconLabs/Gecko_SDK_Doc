<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>EFM32 Leopard Gecko Software Documentation: USB_HOST</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EFM32 Leopard Gecko Software Documentation
   &#160;<span id="projectnumber">efm32lg-doc-4.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="../../index.html"><span>Documentation&#160;Home</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__USB__HOST.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB_HOST<div class="ingroups"><a class="el" href="group__USB.html">USB</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>USB HOST protocol stack, see <a class="el" href="group__USB.html">USB host stack library</a> page for detailed documentation. </p><pre class="fragment"></pre><p>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB HOST device definition.  <a href="structUSBH__Device__TypeDef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB HOST endpoint status data.  <a href="structUSBH__Ep__TypeDef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Host stack initialization structure.  <a href="structUSBH__Init__TypeDef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga011ca5b4422ca0d7b2ac5baae77f6b99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga011ca5b4422ca0d7b2ac5baae77f6b99">USB_VBUSOVRCUR_POLARITY_HIGH</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga011ca5b4422ca0d7b2ac5baae77f6b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f204c3862e9c3d6dd469e98ea7c456"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gad5f204c3862e9c3d6dd469e98ea7c456">USB_VBUSOVRCUR_POLARITY_LOW</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gad5f204c3862e9c3d6dd469e98ea7c456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d1c6a944470a42cd40e4eac28a1402f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga4d1c6a944470a42cd40e4eac28a1402f">USB_VBUSOVRCUR_PORT_NONE</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:ga4d1c6a944470a42cd40e4eac28a1402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f0c44025ac0a0a70bdbd8ebebbd3f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gae4f0c44025ac0a0a70bdbd8ebebbd3f1">USBH_INIT_DEFAULT</a></td></tr>
<tr class="separator:gae4f0c44025ac0a0a70bdbd8ebebbd3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5ccbba1464980cf59277cd2a6765c14d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga5ccbba1464980cf59277cd2a6765c14d">USBH_Device_TypeDef</a></td></tr>
<tr class="memdesc:ga5ccbba1464980cf59277cd2a6765c14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB HOST device definition.  <a href="#ga5ccbba1464980cf59277cd2a6765c14d">More...</a><br /></td></tr>
<tr class="separator:ga5ccbba1464980cf59277cd2a6765c14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga34852d3ee651fb11751f21ccfc6bfcc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga34852d3ee651fb11751f21ccfc6bfcc2">USBH_EpState_TypeDef</a> { <br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2acd80bb986620028db2b94739d20e59f6">H_EP_IDLE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2abb313be634b2d1baf58b164ef7b96629">H_EP_SETUP</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2ad6473274a34916940013c44581528d92">H_EP_DATA_IN</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2aae603b4f9bb26371efdbbe4894308bf3">H_EP_DATA_OUT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2a8aae8401530f06ea9bf76fde11990333">H_EP_STATUS_IN</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2a1eb596383547a852e76f4c58c1b38bad">H_EP_STATUS_OUT</a> = 5
<br />
 }<tr class="separator:ga34852d3ee651fb11751f21ccfc6bfcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga06f1146ad72c09a1ed1d9a9c4b98edb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga06f1146ad72c09a1ed1d9a9c4b98edb2">USBH_AssignHostChannel</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, uint8_t hcnum)</td></tr>
<tr class="memdesc:ga06f1146ad72c09a1ed1d9a9c4b98edb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a host channel to a given endpoint.  <a href="#ga06f1146ad72c09a1ed1d9a9c4b98edb2">More...</a><br /></td></tr>
<tr class="separator:ga06f1146ad72c09a1ed1d9a9c4b98edb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b43c59fc9d3c91d0039f761ef4d6333"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga0b43c59fc9d3c91d0039f761ef4d6333">USBH_ControlMsg</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength, void *data, int timeout, <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a> callback)</td></tr>
<tr class="memdesc:ga0b43c59fc9d3c91d0039f761ef4d6333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a SETUP command to a device, non-blocking version.  <a href="#ga0b43c59fc9d3c91d0039f761ef4d6333">More...</a><br /></td></tr>
<tr class="separator:ga0b43c59fc9d3c91d0039f761ef4d6333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94fe14defe6b7e33472364c65f07f17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength, void *data, int timeout)</td></tr>
<tr class="memdesc:gad94fe14defe6b7e33472364c65f07f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a SETUP command to a device, blocking version.  <a href="#gad94fe14defe6b7e33472364c65f07f17">More...</a><br /></td></tr>
<tr class="separator:gad94fe14defe6b7e33472364c65f07f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf791f134a36bb5376abaf59c45b84e84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gaf791f134a36bb5376abaf59c45b84e84">USBH_DeviceConnected</a> (void)</td></tr>
<tr class="memdesc:gaf791f134a36bb5376abaf59c45b84e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a device is connected.  <a href="#gaf791f134a36bb5376abaf59c45b84e84">More...</a><br /></td></tr>
<tr class="separator:gaf791f134a36bb5376abaf59c45b84e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad09af4f14c4b205a9e159cb4c5fa7b8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gad09af4f14c4b205a9e159cb4c5fa7b8f">USBH_GetConfigurationDescriptorB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, void *buf, int len, uint8_t configIndex)</td></tr>
<tr class="memdesc:gad09af4f14c4b205a9e159cb4c5fa7b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a configuration descriptor from a device.  <a href="#gad09af4f14c4b205a9e159cb4c5fa7b8f">More...</a><br /></td></tr>
<tr class="separator:gad09af4f14c4b205a9e159cb4c5fa7b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2656404a391e6894b03dde7d42d11f4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga2656404a391e6894b03dde7d42d11f4f">USBH_GetDeviceDescriptorB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, void *buf, int len)</td></tr>
<tr class="memdesc:ga2656404a391e6894b03dde7d42d11f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a device descriptor from a device.  <a href="#ga2656404a391e6894b03dde7d42d11f4f">More...</a><br /></td></tr>
<tr class="separator:ga2656404a391e6894b03dde7d42d11f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad011363a4aa7f78c702a361bcebe67fb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gad011363a4aa7f78c702a361bcebe67fb">USBH_GetPortSpeed</a> (void)</td></tr>
<tr class="memdesc:gad011363a4aa7f78c702a361bcebe67fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bus speed of the device attached to the USB port.  <a href="#gad011363a4aa7f78c702a361bcebe67fb">More...</a><br /></td></tr>
<tr class="separator:gad011363a4aa7f78c702a361bcebe67fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e40f21d20e36116da7a45f4a8b7ee3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga4e40f21d20e36116da7a45f4a8b7ee3c">USBH_GetStringB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, uint8_t *buf, int bufLen, uint8_t stringIndex, uint16_t langID)</td></tr>
<tr class="memdesc:ga4e40f21d20e36116da7a45f4a8b7ee3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string descriptor from a device.  <a href="#ga4e40f21d20e36116da7a45f4a8b7ee3c">More...</a><br /></td></tr>
<tr class="separator:ga4e40f21d20e36116da7a45f4a8b7ee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb37814762148d4977bd0dbc1a9b46e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gaedb37814762148d4977bd0dbc1a9b46e">USBH_Init</a> (const <a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a> *p)</td></tr>
<tr class="memdesc:gaedb37814762148d4977bd0dbc1a9b46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize host protocol stack data structures.  <a href="#gaedb37814762148d4977bd0dbc1a9b46e">More...</a><br /></td></tr>
<tr class="separator:gaedb37814762148d4977bd0dbc1a9b46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50dc10ac598c6c8479319ff58c186266"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga50dc10ac598c6c8479319ff58c186266">USBH_InitDeviceData</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, const uint8_t *buf, <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, int numEp, uint8_t deviceSpeed)</td></tr>
<tr class="memdesc:ga50dc10ac598c6c8479319ff58c186266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate device and endpoint data structures with data retrieved during device enumeration.  <a href="#ga50dc10ac598c6c8479319ff58c186266">More...</a><br /></td></tr>
<tr class="separator:ga50dc10ac598c6c8479319ff58c186266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57479eb6271bc262a6652b50fd122ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gac57479eb6271bc262a6652b50fd122ce">USBH_PortReset</a> (void)</td></tr>
<tr class="memdesc:gac57479eb6271bc262a6652b50fd122ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive reset signalling on the USB port.  <a href="#gac57479eb6271bc262a6652b50fd122ce">More...</a><br /></td></tr>
<tr class="separator:gac57479eb6271bc262a6652b50fd122ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2cb3b486c0d628c23cce6a26984580b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gaa2cb3b486c0d628c23cce6a26984580b">USBH_PortResume</a> (void)</td></tr>
<tr class="memdesc:gaa2cb3b486c0d628c23cce6a26984580b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive resume signalling on the USB port.  <a href="#gaa2cb3b486c0d628c23cce6a26984580b">More...</a><br /></td></tr>
<tr class="separator:gaa2cb3b486c0d628c23cce6a26984580b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b518bcdfa5c19f42a362736767f273c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b518bcdfa5c19f42a362736767f273c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga3b518bcdfa5c19f42a362736767f273c">USBH_PortSuspend</a> (void)</td></tr>
<tr class="memdesc:ga3b518bcdfa5c19f42a362736767f273c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the USB port in suspend mode. <br /></td></tr>
<tr class="separator:ga3b518bcdfa5c19f42a362736767f273c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a5bb1a4f4cae3b9cc0556b98d3a4d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gab7a5bb1a4f4cae3b9cc0556b98d3a4d9">USBH_PrintConfigurationDescriptor</a> (const USB_ConfigurationDescriptor_TypeDef *config, int maxLen)</td></tr>
<tr class="memdesc:gab7a5bb1a4f4cae3b9cc0556b98d3a4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a configuration descriptor on the debug serial port.  <a href="#gab7a5bb1a4f4cae3b9cc0556b98d3a4d9">More...</a><br /></td></tr>
<tr class="separator:gab7a5bb1a4f4cae3b9cc0556b98d3a4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465475632c744fb3fae7a73e09606fb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga465475632c744fb3fae7a73e09606fb3">USBH_PrintDeviceDescriptor</a> (const USB_DeviceDescriptor_TypeDef *device)</td></tr>
<tr class="memdesc:ga465475632c744fb3fae7a73e09606fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a device descriptor on the debug serial port.  <a href="#ga465475632c744fb3fae7a73e09606fb3">More...</a><br /></td></tr>
<tr class="separator:ga465475632c744fb3fae7a73e09606fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe253e3e072d805774b8714aacf9182c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gabe253e3e072d805774b8714aacf9182c">USBH_PrintEndpointDescriptor</a> (const USB_EndpointDescriptor_TypeDef *endpoint)</td></tr>
<tr class="memdesc:gabe253e3e072d805774b8714aacf9182c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print an endpoint descriptor on the debug serial port.  <a href="#gabe253e3e072d805774b8714aacf9182c">More...</a><br /></td></tr>
<tr class="separator:gabe253e3e072d805774b8714aacf9182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a4aa696c25dfd0b99a2cda6e02d7a36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga7a4aa696c25dfd0b99a2cda6e02d7a36">USBH_PrintInterfaceDescriptor</a> (const USB_InterfaceDescriptor_TypeDef *interface)</td></tr>
<tr class="memdesc:ga7a4aa696c25dfd0b99a2cda6e02d7a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print an interface descriptor on the debug serial port.  <a href="#ga7a4aa696c25dfd0b99a2cda6e02d7a36">More...</a><br /></td></tr>
<tr class="separator:ga7a4aa696c25dfd0b99a2cda6e02d7a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60806aa452e18cee2002a2a5de015982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga60806aa452e18cee2002a2a5de015982">USBH_PrintString</a> (const char *pre, const USB_StringDescriptor_TypeDef *s, const char *post)</td></tr>
<tr class="memdesc:ga60806aa452e18cee2002a2a5de015982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a USB string descriptor on the debug serial port.  <a href="#ga60806aa452e18cee2002a2a5de015982">More...</a><br /></td></tr>
<tr class="separator:ga60806aa452e18cee2002a2a5de015982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ac91d938f8553e31913afdb8d8d80dc"><td class="memItemLeft" align="right" valign="top">USB_ConfigurationDescriptor_TypeDef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga2ac91d938f8553e31913afdb8d8d80dc">USBH_QGetConfigurationDescriptor</a> (const uint8_t *buf, int configIndex)</td></tr>
<tr class="memdesc:ga2ac91d938f8553e31913afdb8d8d80dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a configuration descriptor.  <a href="#ga2ac91d938f8553e31913afdb8d8d80dc">More...</a><br /></td></tr>
<tr class="separator:ga2ac91d938f8553e31913afdb8d8d80dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d6a8d78ebde4e394bb25aa62a871b30"><td class="memItemLeft" align="right" valign="top">USB_DeviceDescriptor_TypeDef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga4d6a8d78ebde4e394bb25aa62a871b30">USBH_QGetDeviceDescriptor</a> (const uint8_t *buf)</td></tr>
<tr class="memdesc:ga4d6a8d78ebde4e394bb25aa62a871b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the device descriptor.  <a href="#ga4d6a8d78ebde4e394bb25aa62a871b30">More...</a><br /></td></tr>
<tr class="separator:ga4d6a8d78ebde4e394bb25aa62a871b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e6eb1a2e9802af4ec16254e3d44783"><td class="memItemLeft" align="right" valign="top">USB_EndpointDescriptor_TypeDef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga10e6eb1a2e9802af4ec16254e3d44783">USBH_QGetEndpointDescriptor</a> (const uint8_t *buf, int configIndex, int interfaceIndex, int endpointIndex)</td></tr>
<tr class="memdesc:ga10e6eb1a2e9802af4ec16254e3d44783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to an endpoint descriptor.  <a href="#ga10e6eb1a2e9802af4ec16254e3d44783">More...</a><br /></td></tr>
<tr class="separator:ga10e6eb1a2e9802af4ec16254e3d44783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd04b4b1ea26459d6db42aa77b6d592d"><td class="memItemLeft" align="right" valign="top">USB_InterfaceDescriptor_TypeDef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gabd04b4b1ea26459d6db42aa77b6d592d">USBH_QGetInterfaceDescriptor</a> (const uint8_t *buf, int configIndex, int interfaceIndex)</td></tr>
<tr class="memdesc:gabd04b4b1ea26459d6db42aa77b6d592d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to an interface descriptor.  <a href="#gabd04b4b1ea26459d6db42aa77b6d592d">More...</a><br /></td></tr>
<tr class="separator:gabd04b4b1ea26459d6db42aa77b6d592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ef72709bb00accb740a0350f79fe35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB</a> (uint8_t *buf, size_t bufsize, uint8_t deviceSpeed)</td></tr>
<tr class="memdesc:gae9ef72709bb00accb740a0350f79fe35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will request both the device descriptor and the entire configuration descriptor from the device at USB address 0.  <a href="#gae9ef72709bb00accb740a0350f79fe35">More...</a><br /></td></tr>
<tr class="separator:gae9ef72709bb00accb740a0350f79fe35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3514adea6bc6da41b8a083153e3f9365"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga3514adea6bc6da41b8a083153e3f9365">USBH_Read</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, void *data, int byteCount, int timeout, <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a> callback)</td></tr>
<tr class="memdesc:ga3514adea6bc6da41b8a083153e3f9365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from device endpoint, non-blocking version.  <a href="#ga3514adea6bc6da41b8a083153e3f9365">More...</a><br /></td></tr>
<tr class="separator:ga3514adea6bc6da41b8a083153e3f9365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5829c1ebeed8cfd36317dd57c6584c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gab5829c1ebeed8cfd36317dd57c6584c9">USBH_ReadB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, void *data, int byteCount, int timeout)</td></tr>
<tr class="memdesc:gab5829c1ebeed8cfd36317dd57c6584c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from device endpoint, blocking version.  <a href="#gab5829c1ebeed8cfd36317dd57c6584c9">More...</a><br /></td></tr>
<tr class="separator:gab5829c1ebeed8cfd36317dd57c6584c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac93ecf15f240abf7093506c8e8ef9e61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gac93ecf15f240abf7093506c8e8ef9e61">USBH_SetAddressB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, uint8_t deviceAddress)</td></tr>
<tr class="memdesc:gac93ecf15f240abf7093506c8e8ef9e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a device an USB address.  <a href="#gac93ecf15f240abf7093506c8e8ef9e61">More...</a><br /></td></tr>
<tr class="separator:gac93ecf15f240abf7093506c8e8ef9e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f156ce4b8660203cf4957c019064d9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga0f156ce4b8660203cf4957c019064d9f">USBH_SetAltInterfaceB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, uint8_t interfaceIndex, uint8_t alternateSetting)</td></tr>
<tr class="memdesc:ga0f156ce4b8660203cf4957c019064d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a device interface within current device configuration.  <a href="#ga0f156ce4b8660203cf4957c019064d9f">More...</a><br /></td></tr>
<tr class="separator:ga0f156ce4b8660203cf4957c019064d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6938e5856e9d28116922070621be36a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga6938e5856e9d28116922070621be36a5">USBH_SetConfigurationB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, uint8_t configValue)</td></tr>
<tr class="memdesc:ga6938e5856e9d28116922070621be36a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a device configuration.  <a href="#ga6938e5856e9d28116922070621be36a5">More...</a><br /></td></tr>
<tr class="separator:ga6938e5856e9d28116922070621be36a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547d9df531d791c90fd6f44d28e7089a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga547d9df531d791c90fd6f44d28e7089a">USBH_StallEpB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep)</td></tr>
<tr class="memdesc:ga547d9df531d791c90fd6f44d28e7089a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an endpoint in the stalled (halted) state.  <a href="#ga547d9df531d791c90fd6f44d28e7089a">More...</a><br /></td></tr>
<tr class="separator:ga547d9df531d791c90fd6f44d28e7089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154c6b268f2d39d4e1577f917e0da239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga154c6b268f2d39d4e1577f917e0da239">USBH_Stop</a> (void)</td></tr>
<tr class="memdesc:ga154c6b268f2d39d4e1577f917e0da239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop USB host operation.  <a href="#ga154c6b268f2d39d4e1577f917e0da239">More...</a><br /></td></tr>
<tr class="separator:ga154c6b268f2d39d4e1577f917e0da239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8fcc4a69080f3d1005d1bc21d44218"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gabf8fcc4a69080f3d1005d1bc21d44218">USBH_UnStallEpB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep)</td></tr>
<tr class="memdesc:gabf8fcc4a69080f3d1005d1bc21d44218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset stall state on a stalled (halted) endpoint.  <a href="#gabf8fcc4a69080f3d1005d1bc21d44218">More...</a><br /></td></tr>
<tr class="separator:gabf8fcc4a69080f3d1005d1bc21d44218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f99f2ed786c98d00935fc2fd140aaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB</a> (uint8_t *buf, int timeoutInSeconds)</td></tr>
<tr class="memdesc:ga62f99f2ed786c98d00935fc2fd140aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for device connection.  <a href="#ga62f99f2ed786c98d00935fc2fd140aaf">More...</a><br /></td></tr>
<tr class="separator:ga62f99f2ed786c98d00935fc2fd140aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c9fcc6a9f2db01206c010330b6e41f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga0c9fcc6a9f2db01206c010330b6e41f6">USBH_Write</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, void *data, int byteCount, int timeout, <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a> callback)</td></tr>
<tr class="memdesc:ga0c9fcc6a9f2db01206c010330b6e41f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to device endpoint, non-blocking version.  <a href="#ga0c9fcc6a9f2db01206c010330b6e41f6">More...</a><br /></td></tr>
<tr class="separator:ga0c9fcc6a9f2db01206c010330b6e41f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c7b3b7944f7f1b8e4327dd66fa7ff8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga27c7b3b7944f7f1b8e4327dd66fa7ff8">USBH_WriteB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, void *data, int byteCount, int timeout)</td></tr>
<tr class="memdesc:ga27c7b3b7944f7f1b8e4327dd66fa7ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to device endpoint, blocking version.  <a href="#ga27c7b3b7944f7f1b8e4327dd66fa7ff8">More...</a><br /></td></tr>
<tr class="separator:ga27c7b3b7944f7f1b8e4327dd66fa7ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga011ca5b4422ca0d7b2ac5baae77f6b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_VBUSOVRCUR_POLARITY_HIGH&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overcurrent flag pin polarity is high. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00840">840</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad5f204c3862e9c3d6dd469e98ea7c456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_VBUSOVRCUR_POLARITY_LOW&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overcurrent flag pin polarity is low. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00839">839</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d1c6a944470a42cd40e4eac28a1402f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_VBUSOVRCUR_PORT_NONE&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No overcurrent flag functionality. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00838">838</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae4f0c44025ac0a0a70bdbd8ebebbd3f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_INIT_DEFAULT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                            \</div>
<div class="line">  MAX_HOST_FIFO_SIZE_INWORDS * 2,<span class="comment">/* 1024 bytes Rx FIFO size.             */</span>  \</div>
<div class="line">  MAX_HOST_FIFO_SIZE_INWORDS,    <span class="comment">/* 512 bytes non-periodic Tx FIFO size. */</span>  \</div>
<div class="line">  MAX_HOST_FIFO_SIZE_INWORDS,    <span class="comment">/* 512 bytes periodic Tx FIFO size.     */</span>  \</div>
<div class="line">  0                              <span class="comment">/* Reserved.                            */</span>  \</div>
<div class="line">}</div>
</div><!-- fragment --><p>Default <a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a> values, provides reasonable Tx/Rx FIFO partitioning. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00914">914</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5ccbba1464980cf59277cd2a6765c14d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a>  <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USB HOST device definition. </p>
<p>A host application should not manipulate the contents of this struct. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga34852d3ee651fb11751f21ccfc6bfcc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__USB__HOST.html#ga34852d3ee651fb11751f21ccfc6bfcc2">USBH_EpState_TypeDef</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB HOST endpoint status enumerator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2acd80bb986620028db2b94739d20e59f6"></a>H_EP_IDLE&#160;</td><td class="fielddoc">
<p>The endpoint is idle. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2abb313be634b2d1baf58b164ef7b96629"></a>H_EP_SETUP&#160;</td><td class="fielddoc">
<p>The endpoint is in SETUP stage. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2ad6473274a34916940013c44581528d92"></a>H_EP_DATA_IN&#160;</td><td class="fielddoc">
<p>The endpoint is in DATA IN stage. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2aae603b4f9bb26371efdbbe4894308bf3"></a>H_EP_DATA_OUT&#160;</td><td class="fielddoc">
<p>The endpoint is in DATA OUT stage. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2a8aae8401530f06ea9bf76fde11990333"></a>H_EP_STATUS_IN&#160;</td><td class="fielddoc">
<p>The endpoint is in STATUS IN stage. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2a1eb596383547a852e76f4c58c1b38bad"></a>H_EP_STATUS_OUT&#160;</td><td class="fielddoc">
<p>The endpoint is in STATUS OUT stage. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00843">843</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga06f1146ad72c09a1ed1d9a9c4b98edb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_AssignHostChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hcnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign a host channel to a given endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hcnum</td><td>Host channel number (0..).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code.</dd></dl>
<p>After assigning a host channel to an endpoint, all subsequent transfers to the endpoint will use the given host channel. Several endpoints can be assigned to the same host channel, but keep in mind that concurrent transfers can only be performed on endpoints assigned to different host channels. <br />
 The default endpoint (EP0) is assigned to host channels 0 and 1 by the host stack. </p>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00160">160</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Ep__TypeDef.html#a498ef5c49df06f7516060abba364ce37">USBH_Ep_TypeDef::addr</a>, <a class="el" href="group__USB__COMMON.html#ga37edda82028e35831f6b321d57eb6c6c">CONFIG_DESC_BM_TRANSFERTYPE</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a86a128ca7350399f382b97cdf139f7e5">USBH_Ep_TypeDef::epDesc</a>, <a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2acd80bb986620028db2b94739d20e59f6">H_EP_IDLE</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#abbc89752b155f35463b68aeb16b50ac7">USBH_Ep_TypeDef::hcIn</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a4ca23c7736c6ded42faca4886ca610e5">USBH_Ep_TypeDef::hcOut</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#aca0fb63debe406a69b27832d8ede497e">USBH_Ep_TypeDef::in</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ac2279b4158fac0939e5eed3a37c2e39f">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a372dcdc1c18e02de60ff95581984b5fe">USBH_Ep_TypeDef::state</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#aaec68ed616a7586b97748117fc428ce2">USBH_Ep_TypeDef::type</a>, <a class="el" href="group__USB__COMMON.html#gaacee2775597edddc9d4ba5dee2024395">USB_SETUP_DIR_MASK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, and <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b43c59fc9d3c91d0039f761ef4d6333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_ControlMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bmRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a SETUP command to a device, non-blocking version. </p>
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is non-blocking and returns immediately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bmRequestType</td><td>SETUP command request type. A suitable combination of values <a class="el" href="group__USB__COMMON.html#ga204e51e67cf7671617112b94ecfe3a46">USB_SETUP_DIR_D2H</a>, <a class="el" href="group__USB__COMMON.html#ga88f4223ae1ca659baa20ddfdb3dcc217">USB_SETUP_DIR_H2D</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#ga8067a7210027455955067dc98e111494">USB_SETUP_TYPE_CLASS_MASK</a>, <a class="el" href="group__USB__COMMON.html#ga7e1d5f94bc4780ea74aea4efa5cbd804">USB_SETUP_TYPE_VENDOR_MASK</a>, <a class="el" href="group__USB__COMMON.html#gad48131dc5ca47b4b2def65e7bbc8442f">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="group__USB__COMMON.html#ga59754621c21db801e11513ba06a3a02e">USB_SETUP_RECIPIENT_INTERFACE</a>, <a class="el" href="group__USB__COMMON.html#gac6ef27ac78140749f3607246f21c1471">USB_SETUP_RECIPIENT_ENDPOINT</a> or <a class="el" href="group__USB__COMMON.html#gaa1a71b2e05ba5682c956d8dfdf01d40b">USB_SETUP_RECIPIENT_OTHER</a>.<br />
 Refer to the USB specification for details.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bRequest</td><td>A specific SETUP command request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wValue</td><td>Word sized field that varies according to request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wIndex</td><td>Word sized field that varies according to request. Typically used to pass an index or offset.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wLength</td><td>Number of bytes to transfer if there is a data stage.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to be called on transfer completion. Supply NULL if no callback is needed. See <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00246">246</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Ep__TypeDef.html#a0fd9a2e769340251d88643f2392ee362">USBH_Ep_TypeDef::buf</a>, <a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2acd80bb986620028db2b94739d20e59f6">H_EP_IDLE</a>, <a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2abb313be634b2d1baf58b164ef7b96629">H_EP_SETUP</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#abbc89752b155f35463b68aeb16b50ac7">USBH_Ep_TypeDef::hcIn</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a4ca23c7736c6ded42faca4886ca610e5">USBH_Ep_TypeDef::hcOut</a>, <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#aac5ef5a7c53b65b89d794328328548a2">USBH_Ep_TypeDef::setup</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a81c2801c6161cb2bb08b9714509b1e37">USBH_Ep_TypeDef::setupErrCnt</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a372dcdc1c18e02de60ff95581984b5fe">USBH_Ep_TypeDef::state</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#afc297ff52c3bd575b40e26b843364564">USBH_Ep_TypeDef::timeout</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1afa326e98a111316089803b32218fa176">USB_STATUS_EP_BUSY</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1aab9974d621b469d47637c07d1ee0c29f">USB_STATUS_HC_BUSY</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, <a class="el" href="group__USB__HOST.html#gaf791f134a36bb5376abaf59c45b84e84">USBH_DeviceConnected()</a>, <a class="el" href="group__USB__COMMON.html#gac2a406f16d989b04c4fc5b37d5c10b45">USBTIMER_Start()</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ad69013d2335283397b539f0d59c0f7ef">USBH_Ep_TypeDef::xferCompleteCb</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a12e951b4d75eab6e4b68de674110efff">USBH_Ep_TypeDef::xferCompleted</a>, and <a class="el" href="structUSBH__Ep__TypeDef.html#a771ee9abfb47d3eeba3806197b2855e2">USBH_Ep_TypeDef::xferred</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="gad94fe14defe6b7e33472364c65f07f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_ControlMsgB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bmRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a SETUP command to a device, blocking version. </p>
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bmRequestType</td><td>SETUP command request type. A suitable combination of values <a class="el" href="group__USB__COMMON.html#ga204e51e67cf7671617112b94ecfe3a46">USB_SETUP_DIR_D2H</a>, <a class="el" href="group__USB__COMMON.html#ga88f4223ae1ca659baa20ddfdb3dcc217">USB_SETUP_DIR_H2D</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#ga8067a7210027455955067dc98e111494">USB_SETUP_TYPE_CLASS_MASK</a>, <a class="el" href="group__USB__COMMON.html#ga7e1d5f94bc4780ea74aea4efa5cbd804">USB_SETUP_TYPE_VENDOR_MASK</a>, <a class="el" href="group__USB__COMMON.html#gad48131dc5ca47b4b2def65e7bbc8442f">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="group__USB__COMMON.html#ga59754621c21db801e11513ba06a3a02e">USB_SETUP_RECIPIENT_INTERFACE</a>, <a class="el" href="group__USB__COMMON.html#gac6ef27ac78140749f3607246f21c1471">USB_SETUP_RECIPIENT_ENDPOINT</a> or <a class="el" href="group__USB__COMMON.html#gaa1a71b2e05ba5682c956d8dfdf01d40b">USB_SETUP_RECIPIENT_OTHER</a>.<br />
 Refer to the USB specification for details.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bRequest</td><td>A specific SETUP command request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wValue</td><td>Word sized field that varies according to request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wIndex</td><td>Word sized field that varies according to request. Typically used to pass an index or offset.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wLength</td><td>Number of bytes to transfer if there is a data stage.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00367">367</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, <a class="el" href="group__USB__HOST.html#ga0b43c59fc9d3c91d0039f761ef4d6333">USBH_ControlMsg()</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a12e951b4d75eab6e4b68de674110efff">USBH_Ep_TypeDef::xferCompleted</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a771ee9abfb47d3eeba3806197b2855e2">USBH_Ep_TypeDef::xferred</a>, and <a class="el" href="structUSBH__Ep__TypeDef.html#a2e94cea0590006aeb094e9646d23831a">USBH_Ep_TypeDef::xferStatus</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#gad09af4f14c4b205a9e159cb4c5fa7b8f">USBH_GetConfigurationDescriptorB()</a>, <a class="el" href="group__USB__HOST.html#ga2656404a391e6894b03dde7d42d11f4f">USBH_GetDeviceDescriptorB()</a>, <a class="el" href="group__USB__HOST.html#ga4e40f21d20e36116da7a45f4a8b7ee3c">USBH_GetStringB()</a>, <a class="el" href="group__USB__HOST.html#gac93ecf15f240abf7093506c8e8ef9e61">USBH_SetAddressB()</a>, <a class="el" href="group__USB__HOST.html#ga0f156ce4b8660203cf4957c019064d9f">USBH_SetAltInterfaceB()</a>, <a class="el" href="group__USB__HOST.html#ga6938e5856e9d28116922070621be36a5">USBH_SetConfigurationB()</a>, <a class="el" href="group__USB__HOST.html#ga547d9df531d791c90fd6f44d28e7089a">USBH_StallEpB()</a>, and <a class="el" href="group__USB__HOST.html#gabf8fcc4a69080f3d1005d1bc21d44218">USBH_UnStallEpB()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf791f134a36bb5376abaf59c45b84e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USBH_DeviceConnected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a device is connected. </p>
<dl class="section return"><dt>Returns</dt><dd>True if device connected, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00612">612</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#ga0b43c59fc9d3c91d0039f761ef4d6333">USBH_ControlMsg()</a>, <a class="el" href="group__USB__HOST.html#ga3514adea6bc6da41b8a083153e3f9365">USBH_Read()</a>, <a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB()</a>, and <a class="el" href="group__USB__HOST.html#ga0c9fcc6a9f2db01206c010330b6e41f6">USBH_Write()</a>.</p>

</div>
</div>
<a class="anchor" id="gad09af4f14c4b205a9e159cb4c5fa7b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_GetConfigurationDescriptorB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>configIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a configuration descriptor from a device. </p>
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to request, must not exceed transfer data buffer size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configIndex</td><td>Configuration index, a zero based number indicating which configuration to request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00647">647</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="group__USB__COMMON.html#ga115a1d866ed9498300d59c90549ead0d">GET_DESCRIPTOR</a>, <a class="el" href="group__USB__COMMON.html#ga255b06a613102c4438f98da8cf374b77">USB_CONFIG_DESCRIPTOR</a>, <a class="el" href="group__USB__COMMON.html#ga204e51e67cf7671617112b94ecfe3a46">USB_SETUP_DIR_D2H</a>, <a class="el" href="group__USB__COMMON.html#gad48131dc5ca47b4b2def65e7bbc8442f">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, and <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2656404a391e6894b03dde7d42d11f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_GetDeviceDescriptorB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a device descriptor from a device. </p>
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to request, must not exceed transfer data buffer size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00704">704</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="group__USB__COMMON.html#ga115a1d866ed9498300d59c90549ead0d">GET_DESCRIPTOR</a>, <a class="el" href="group__USB__COMMON.html#gae6d736353df6b564adfc8034b4cd888b">USB_DEVICE_DESCRIPTOR</a>, <a class="el" href="group__USB__COMMON.html#ga204e51e67cf7671617112b94ecfe3a46">USB_SETUP_DIR_D2H</a>, <a class="el" href="group__USB__COMMON.html#gad48131dc5ca47b4b2def65e7bbc8442f">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, and <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>, and <a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB()</a>.</p>

</div>
</div>
<a class="anchor" id="gad011363a4aa7f78c702a361bcebe67fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBH_GetPortSpeed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bus speed of the device attached to the USB port. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gac483b34de71117d1db0dc1d9c1f896d9">PORT_FULL_SPEED</a> or <a class="el" href="group__USB__COMMON.html#gab35af8fb505263e1e594d07f9e5c8253">PORT_LOW_SPEED</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00741">741</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>Referenced by <a class="el" href="group__Msd.html#gaeb31e6900faf7971679af16d079f6c14">MSDH_Init()</a>, and <a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e40f21d20e36116da7a45f4a8b7ee3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_GetStringB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stringIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>langID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a string descriptor from a device. </p>
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed. <br />
 The maximum permitted USB string lenght is 255 bytes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufLen</td><td>Transfer data buffer size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringIndex</td><td>String index, a zero based number indicating which string to request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">langID</td><td>String language ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00779">779</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="group__USB__COMMON.html#ga115a1d866ed9498300d59c90549ead0d">GET_DESCRIPTOR</a>, <a class="el" href="group__COMMON.html#ga9569b0ba06efef226b0a82109eef3ec3">SL_MIN</a>, <a class="el" href="group__USB__COMMON.html#ga204e51e67cf7671617112b94ecfe3a46">USB_SETUP_DIR_D2H</a>, <a class="el" href="group__USB__COMMON.html#gad48131dc5ca47b4b2def65e7bbc8442f">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#ga64ab6de48cce87b6b0318f47b0d81ded">USB_STRING_DESCRIPTOR</a>, and <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="gaedb37814762148d4977bd0dbc1a9b46e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize host protocol stack data structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to initialization structure. See <a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Host stack internal data structures are initialized, no actions will be performed on the USB port. Use this function once before starting USB host operation. USB operation is initated with <a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00837">837</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__EFM32LG995F256__Peripheral__Declaration.html#ga0ed1d26edfd19bbb92da3601b9804750">CMU</a>, <a class="el" href="group__CMU.html#gae11949f9c2e4033ad63dac48c9a739d3">CMU_ClockSelectSet()</a>, <a class="el" href="group__EFM32LG__CMU__BitFields.html#gaf5cf64cddc6e02152d49d46d1e8612eb">CMU_CMD_USBCCLKSEL_HFCLKNODIV</a>, <a class="el" href="group__EFM32LG__CMU__BitFields.html#ga4734bcc381ac0f16635454dd90452b7a">CMU_HFCORECLKEN0_USB</a>, <a class="el" href="group__EFM32LG__CMU__BitFields.html#ga1ac2c5862e307be1b5612253be11d8f0">CMU_HFCORECLKEN0_USBC</a>, <a class="el" href="group__CMU.html#gga519ea66a1a21e07f2d1cccc9aa55799eaf26ebbfb801b7dbd9ee98bc3e49327f0">cmuClock_HF</a>, <a class="el" href="group__CMU.html#ggaeaf3a27499d7441981159c5973546751a699ff3f53a103968e54f6e429f0f03e1">cmuSelect_HFXO</a>, <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="structUSBH__Init__TypeDef.html#aca7555b01d0e35256d228cedd295a312">USBH_Init_TypeDef::nptxFifoSize</a>, <a class="el" href="structUSBH__Init__TypeDef.html#a4f06d71480097b85d53af70245c33ea1">USBH_Init_TypeDef::ptxFifoSize</a>, <a class="el" href="structUSBH__Init__TypeDef.html#afb23a2753f21e530ed6f5ccf1316a5b2">USBH_Init_TypeDef::rxFifoSize</a>, <a class="el" href="group__EFM32LG995F256.html#gga666eb0caeb12ec0e281415592ae89083a5078f46ddc47f29eae4aa40bd57d1692">USB_IRQn</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, and <a class="el" href="group__USB__COMMON.html#ga21c87b800d87fd731173dd4f48f23c28">USBTIMER_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga50dc10ac598c6c8479319ff58c186266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_InitDeviceData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>deviceSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate device and endpoint data structures with data retrieved during device enumeration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to an array of <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> endpoint data structures.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numEp</td><td>Number of elements in endpoint array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceSpeed</td><td><a class="el" href="group__USB__COMMON.html#gac483b34de71117d1db0dc1d9c1f896d9">PORT_FULL_SPEED</a> or <a class="el" href="group__USB__COMMON.html#gab35af8fb505263e1e594d07f9e5c8253">PORT_LOW_SPEED</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function prior to moving a device out of default state. The application itself must allocate device and endpoint structures. Data from a prior call to <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a> must be passed in input parameter <em>buf</em>. The device speed can be determined with <a class="el" href="group__USB__HOST.html#gad011363a4aa7f78c702a361bcebe67fb">USBH_GetPortSpeed()</a> for devices directly attached to the USB port. Devices attached via a hub must retrieve this information by querying the hub. </p>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00905">905</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Device__TypeDef.html#a345d58d313ea676ffea5c7b47e7f8b79">USBH_Device_TypeDef::addr</a>, <a class="el" href="structUSBH__Device__TypeDef.html#abec0a197ceb8df8dc928153f837a4c7c">USBH_Device_TypeDef::confDesc</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a07597207c1bc0d5a2795944c687ca812">USBH_Device_TypeDef::devDesc</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a6faabbcd85b74888a66033798b643455">USBH_Device_TypeDef::ep</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a86a128ca7350399f382b97cdf139f7e5">USBH_Ep_TypeDef::epDesc</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#abbc89752b155f35463b68aeb16b50ac7">USBH_Ep_TypeDef::hcIn</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a4ca23c7736c6ded42faca4886ca610e5">USBH_Ep_TypeDef::hcOut</a>, <a class="el" href="structUSBH__Device__TypeDef.html#acdc5a66f2a8f48b0326e28cdb75ae798">USBH_Device_TypeDef::itfDesc</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a7a085fe94f3ccae689ff8e1f080bc371">USBH_Device_TypeDef::numEp</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ac2279b4158fac0939e5eed3a37c2e39f">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ae718c515646ac6c9b9b23b0e53f03ea8">USBH_Ep_TypeDef::parentDevice</a>, <a class="el" href="structUSBH__Device__TypeDef.html#ad0332a51a25b48aca2b750de8c474230">USBH_Device_TypeDef::speed</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a8b219c0a9405e783a1eb1f4285849dd4">USBH_Ep_TypeDef::toggle</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#aaec68ed616a7586b97748117fc428ce2">USBH_Ep_TypeDef::type</a>, <a class="el" href="group__USB__COMMON.html#ga30b596aed3f4d37df7df3a3ffb883c65">USB_CONFIG_DESCSIZE</a>, <a class="el" href="group__USB__COMMON.html#ga77cdcc6eb8ead17efdcef129070e5bf3">USB_DEVICE_DESCSIZE</a>, <a class="el" href="group__USB__COMMON.html#ga3de2785fdddd667dfab0a6cb25863486">USB_ENDPOINT_DESCSIZE</a>, <a class="el" href="group__USB__COMMON.html#ga95b74d966c16ae5fec01e0d6cd26fdac">USB_EPTYPE_CTRL</a>, <a class="el" href="group__USB__COMMON.html#gabaed245137ca1bc8be3c22de50845fe6">USB_INTERFACE_DESCSIZE</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, <a class="el" href="group__USB__HOST.html#ga10e6eb1a2e9802af4ec16254e3d44783">USBH_QGetEndpointDescriptor()</a>, and <a class="el" href="group__USB__HOST.html#gabd04b4b1ea26459d6db42aa77b6d592d">USBH_QGetInterfaceDescriptor()</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>, and <a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB()</a>.</p>

</div>
</div>
<a class="anchor" id="gac57479eb6271bc262a6652b50fd122ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PortReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drive reset signalling on the USB port. </p>
<dl class="section note"><dt>Note</dt><dd>This function is primarily meant for debugging a device. When returning the device will appear to be disconnected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00982">982</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, and <a class="el" href="group__USB__COMMON.html#gabb1c11cad365c7c3b99a3e7826035951">USBTIMER_DelayMs()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa2cb3b486c0d628c23cce6a26984580b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PortResume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drive resume signalling on the USB port. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01012">1012</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, and <a class="el" href="group__USB__COMMON.html#gabb1c11cad365c7c3b99a3e7826035951">USBTIMER_DelayMs()</a>.</p>

</div>
</div>
<a class="anchor" id="gab7a5bb1a4f4cae3b9cc0556b98d3a4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PrintConfigurationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const USB_ConfigurationDescriptor_TypeDef *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print a configuration descriptor on the debug serial port. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled when #define USB_USE_PRINTF and #define USER_PUTCHAR macros are properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to a USB_ConfigurationDescriptor_TypeDef data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxLen</td><td>The size of the data buffer passed as input parameter <em>config</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01085">1085</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__COMMON.html#ga9569b0ba06efef226b0a82109eef3ec3">SL_MIN</a>, <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb">USB_PRINTF()</a>, <a class="el" href="group__USB__COMMON.html#gac49ccf1d69a08567d1a5911b0312e735">USB_PUTCHAR()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, and <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="ga465475632c744fb3fae7a73e09606fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PrintDeviceDescriptor </td>
          <td>(</td>
          <td class="paramtype">const USB_DeviceDescriptor_TypeDef *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print a device descriptor on the debug serial port. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled when #define USB_USE_PRINTF and #define USER_PUTCHAR macros are properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a USB_DeviceDescriptor_TypeDef data structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01142">1142</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb">USB_PRINTF()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, and <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="gabe253e3e072d805774b8714aacf9182c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PrintEndpointDescriptor </td>
          <td>(</td>
          <td class="paramtype">const USB_EndpointDescriptor_TypeDef *&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print an endpoint descriptor on the debug serial port. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled when #define USB_USE_PRINTF and #define USER_PUTCHAR macros are properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Pointer to a USB_EndpointDescriptor_TypeDef data structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01184">1184</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb">USB_PRINTF()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, and <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a4aa696c25dfd0b99a2cda6e02d7a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PrintInterfaceDescriptor </td>
          <td>(</td>
          <td class="paramtype">const USB_InterfaceDescriptor_TypeDef *&#160;</td>
          <td class="paramname"><em>interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty print an interface descriptor on the debug serial port. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled when #define USB_USE_PRINTF and #define USER_PUTCHAR macros are properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interface</td><td>Pointer to a USB_InterfaceDescriptor_TypeDef data structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01219">1219</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb">USB_PRINTF()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, and <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="ga60806aa452e18cee2002a2a5de015982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBH_PrintString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const USB_StringDescriptor_TypeDef *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>post</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a USB string descriptor on the debug serial port. </p>
<dl class="section note"><dt>Note</dt><dd>This function is enabled when the #define USER_PUTCHAR macro is properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pre</td><td>Optional text string to prepend to the string descriptor. Pass NULL if not needed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Pointer to a USB_StringDescriptor_TypeDef data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">post</td><td>Optional text string to append to the string descriptor. Pass NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01268">1268</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__USB__COMMON.html#gac49ccf1d69a08567d1a5911b0312e735">USB_PUTCHAR()</a>, and <a class="el" href="group__USB__COMMON.html#ga7276e056a2f6aeb99240f72529f41f8f">USB_PUTS()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ac91d938f8553e31913afdb8d8d80dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USB_ConfigurationDescriptor_TypeDef* USBH_QGetConfigurationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>configIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to a configuration descriptor. </p>
<dl class="section note"><dt>Note</dt><dd>This function search through <em>buf</em> looking for a given configuration descriptor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configIndex</td><td>Configuration index, a zero based number indicating which configuration descriptor to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to USB_ConfigurationDescriptor_TypeDef. NULL if no descriptor found. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01331">1331</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__COMMON.html#ga9569b0ba06efef226b0a82109eef3ec3">SL_MIN</a>, <a class="el" href="group__USB__COMMON.html#ga255b06a613102c4438f98da8cf374b77">USB_CONFIG_DESCRIPTOR</a>, <a class="el" href="group__USB__COMMON.html#ga30b596aed3f4d37df7df3a3ffb883c65">USB_CONFIG_DESCSIZE</a>, and <a class="el" href="group__USB__HOST.html#ga4d6a8d78ebde4e394bb25aa62a871b30">USBH_QGetDeviceDescriptor()</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#gabd04b4b1ea26459d6db42aa77b6d592d">USBH_QGetInterfaceDescriptor()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d6a8d78ebde4e394bb25aa62a871b30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USB_DeviceDescriptor_TypeDef* USBH_QGetDeviceDescriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the device descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to USB_DeviceDescriptor_TypeDef. NULL if no descriptor found. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01387">1387</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__USB__COMMON.html#gae6d736353df6b564adfc8034b4cd888b">USB_DEVICE_DESCRIPTOR</a>, and <a class="el" href="group__USB__COMMON.html#ga77cdcc6eb8ead17efdcef129070e5bf3">USB_DEVICE_DESCSIZE</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#ga2ac91d938f8553e31913afdb8d8d80dc">USBH_QGetConfigurationDescriptor()</a>.</p>

</div>
</div>
<a class="anchor" id="ga10e6eb1a2e9802af4ec16254e3d44783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USB_EndpointDescriptor_TypeDef* USBH_QGetEndpointDescriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>configIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endpointIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to an endpoint descriptor. </p>
<dl class="section note"><dt>Note</dt><dd>This function search through <em>buf</em> looking for a given endpoint descriptor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configIndex</td><td>Configuration index, a zero based number indicating in which configuration descriptor to look for the interface containing the endpoint descriptor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaceIndex</td><td>Interface index, a zero based number indicating the interface descriptor to look for the correct endpoint descriptor in.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endpointIndex</td><td>Endpoint index, a zero based number indicating which endpoint descriptor to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to USB_EndpointDescriptor_TypeDef. NULL if no descriptor found. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01434">1434</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__USB__COMMON.html#ga01c697098d067b7a297bdaf2e3e2a8a5">USB_ENDPOINT_DESCRIPTOR</a>, <a class="el" href="group__USB__COMMON.html#ga3de2785fdddd667dfab0a6cb25863486">USB_ENDPOINT_DESCSIZE</a>, <a class="el" href="group__USB__COMMON.html#gabaed245137ca1bc8be3c22de50845fe6">USB_INTERFACE_DESCSIZE</a>, and <a class="el" href="group__USB__HOST.html#gabd04b4b1ea26459d6db42aa77b6d592d">USBH_QGetInterfaceDescriptor()</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#ga50dc10ac598c6c8479319ff58c186266">USBH_InitDeviceData()</a>.</p>

</div>
</div>
<a class="anchor" id="gabd04b4b1ea26459d6db42aa77b6d592d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USB_InterfaceDescriptor_TypeDef* USBH_QGetInterfaceDescriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>configIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to an interface descriptor. </p>
<dl class="section note"><dt>Note</dt><dd>This function search through <em>buf</em> looking for a given interface descriptor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configIndex</td><td>Configuration index, a zero based number indicating in which configuration descriptor to look for the interface descriptor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaceIndex</td><td>Interface index, a zero based number indicating which interface descriptor to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to USB_InterfaceDescriptor_TypeDef. NULL if no descriptor found. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01506">1506</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__USB__COMMON.html#ga30b596aed3f4d37df7df3a3ffb883c65">USB_CONFIG_DESCSIZE</a>, <a class="el" href="group__USB__COMMON.html#ga09a5036ed62dcda9011836684ecbc83e">USB_INTERFACE_DESCRIPTOR</a>, <a class="el" href="group__USB__COMMON.html#gabaed245137ca1bc8be3c22de50845fe6">USB_INTERFACE_DESCSIZE</a>, and <a class="el" href="group__USB__HOST.html#ga2ac91d938f8553e31913afdb8d8d80dc">USBH_QGetConfigurationDescriptor()</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#ga50dc10ac598c6c8479319ff58c186266">USBH_InitDeviceData()</a>, and <a class="el" href="group__USB__HOST.html#ga10e6eb1a2e9802af4ec16254e3d44783">USBH_QGetEndpointDescriptor()</a>.</p>

</div>
</div>
<a class="anchor" id="gae9ef72709bb00accb740a0350f79fe35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_QueryDeviceB </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>deviceSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will request both the device descriptor and the entire configuration descriptor from the device at USB address 0. </p>
<dl class="section note"><dt>Note</dt><dd>This function is normally used to retrieve the data needed by <a class="el" href="group__USB__HOST.html#ga50dc10ac598c6c8479319ff58c186266">USBH_InitDeviceData()</a>. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer with sufficent space for the descriptors. The data buffer size must be sizeof( <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> ) + the anticipated maximum size of the entire configuration descriptor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>The size of the data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceSpeed</td><td><a class="el" href="group__USB__COMMON.html#gac483b34de71117d1db0dc1d9c1f896d9">PORT_FULL_SPEED</a> or <a class="el" href="group__USB__COMMON.html#gab35af8fb505263e1e594d07f9e5c8253">PORT_LOW_SPEED</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The device speed can be determined with <a class="el" href="group__USB__HOST.html#gad011363a4aa7f78c702a361bcebe67fb">USBH_GetPortSpeed()</a> for devices directly attached to the USB port. Devices attached via a hub must retrieve this information by querying the hub. </p>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01582">1582</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Device__TypeDef.html#abec0a197ceb8df8dc928153f837a4c7c">USBH_Device_TypeDef::confDesc</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a07597207c1bc0d5a2795944c687ca812">USBH_Device_TypeDef::devDesc</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a6faabbcd85b74888a66033798b643455">USBH_Device_TypeDef::ep</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ac2279b4158fac0939e5eed3a37c2e39f">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="group__COMMON.html#ga9569b0ba06efef226b0a82109eef3ec3">SL_MIN</a>, <a class="el" href="structUSBH__Device__TypeDef.html#ad0332a51a25b48aca2b750de8c474230">USBH_Device_TypeDef::speed</a>, <a class="el" href="group__USB__COMMON.html#ga30b596aed3f4d37df7df3a3ffb883c65">USB_CONFIG_DESCSIZE</a>, <a class="el" href="group__USB__COMMON.html#ga77cdcc6eb8ead17efdcef129070e5bf3">USB_DEVICE_DESCSIZE</a>, <a class="el" href="group__USB__COMMON.html#gabaed245137ca1bc8be3c22de50845fe6">USB_INTERFACE_DESCSIZE</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a551e7a6fbdf7e891b8232818179fa229">USB_STATUS_REQ_ERR</a>, <a class="el" href="group__USB__HOST.html#gad09af4f14c4b205a9e159cb4c5fa7b8f">USBH_GetConfigurationDescriptorB()</a>, <a class="el" href="group__USB__HOST.html#ga2656404a391e6894b03dde7d42d11f4f">USBH_GetDeviceDescriptorB()</a>, and <a class="el" href="group__USB__HOST.html#ga50dc10ac598c6c8479319ff58c186266">USBH_InitDeviceData()</a>.</p>

<p>Referenced by <a class="el" href="group__Msd.html#gaeb31e6900faf7971679af16d079f6c14">MSDH_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3514adea6bc6da41b8a083153e3f9365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from device endpoint, non-blocking version. </p>
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is non-blocking and returns immediately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteCount</td><td>Number of bytes to transfer (zero is a valid value).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to be called on transfer completion. Supply NULL if no callback is needed. See <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01672">1672</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Ep__TypeDef.html#a0fd9a2e769340251d88643f2392ee362">USBH_Ep_TypeDef::buf</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a86a128ca7350399f382b97cdf139f7e5">USBH_Ep_TypeDef::epDesc</a>, <a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2ad6473274a34916940013c44581528d92">H_EP_DATA_IN</a>, <a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2acd80bb986620028db2b94739d20e59f6">H_EP_IDLE</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#abbc89752b155f35463b68aeb16b50ac7">USBH_Ep_TypeDef::hcIn</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#aca0fb63debe406a69b27832d8ede497e">USBH_Ep_TypeDef::in</a>, <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ac2279b4158fac0939e5eed3a37c2e39f">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ad1d3154129fda09c6057495e1afa2cc7">USBH_Ep_TypeDef::remaining</a>, <a class="el" href="group__COMMON.html#ga9569b0ba06efef226b0a82109eef3ec3">SL_MIN</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a372dcdc1c18e02de60ff95581984b5fe">USBH_Ep_TypeDef::state</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#afc297ff52c3bd575b40e26b843364564">USBH_Ep_TypeDef::timeout</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#aaec68ed616a7586b97748117fc428ce2">USBH_Ep_TypeDef::type</a>, <a class="el" href="group__USB__COMMON.html#ga5afdd9301e4641dbd23dc1d994958f86">USB_EPTYPE_INTR</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1afa326e98a111316089803b32218fa176">USB_STATUS_EP_BUSY</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1aab9974d621b469d47637c07d1ee0c29f">USB_STATUS_HC_BUSY</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, <a class="el" href="group__USB__HOST.html#gaf791f134a36bb5376abaf59c45b84e84">USBH_DeviceConnected()</a>, <a class="el" href="group__USB__COMMON.html#gac2a406f16d989b04c4fc5b37d5c10b45">USBTIMER_Start()</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ad69013d2335283397b539f0d59c0f7ef">USBH_Ep_TypeDef::xferCompleteCb</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a12e951b4d75eab6e4b68de674110efff">USBH_Ep_TypeDef::xferCompleted</a>, and <a class="el" href="structUSBH__Ep__TypeDef.html#a771ee9abfb47d3eeba3806197b2855e2">USBH_Ep_TypeDef::xferred</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#gab5829c1ebeed8cfd36317dd57c6584c9">USBH_ReadB()</a>.</p>

</div>
</div>
<a class="anchor" id="gab5829c1ebeed8cfd36317dd57c6584c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_ReadB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from device endpoint, blocking version. </p>
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteCount</td><td>Number of bytes to transfer (zero is a valid value).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01794">1794</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, <a class="el" href="group__USB__HOST.html#ga3514adea6bc6da41b8a083153e3f9365">USBH_Read()</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a12e951b4d75eab6e4b68de674110efff">USBH_Ep_TypeDef::xferCompleted</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a771ee9abfb47d3eeba3806197b2855e2">USBH_Ep_TypeDef::xferred</a>, and <a class="el" href="structUSBH__Ep__TypeDef.html#a2e94cea0590006aeb094e9646d23831a">USBH_Ep_TypeDef::xferStatus</a>.</p>

<p>Referenced by <a class="el" href="group__Msd.html#ga924b6ac8bbbb582c299825f371813067">MSDBOT_Xfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gac93ecf15f240abf7093506c8e8ef9e61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_SetAddressB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>deviceAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give a device an USB address. </p>
<dl class="section note"><dt>Note</dt><dd>The device must currently have address 0. This command will move the device to the addressed state. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceAddress</td><td>The new device address. Provide a value between 0 and 127.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01841">1841</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Device__TypeDef.html#a345d58d313ea676ffea5c7b47e7f8b79">USBH_Device_TypeDef::addr</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="group__USB__COMMON.html#gad3c9f5426c07d7d4da8cf1752a111576">SET_ADDRESS</a>, <a class="el" href="group__USB__COMMON.html#ga0e5e61a43fa8c7d415d59f319ef4e941">USB_MAX_DEVICE_ADDRESS</a>, <a class="el" href="group__USB__COMMON.html#ga88f4223ae1ca659baa20ddfdb3dcc217">USB_SETUP_DIR_H2D</a>, <a class="el" href="group__USB__COMMON.html#gad48131dc5ca47b4b2def65e7bbc8442f">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, and <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f156ce4b8660203cf4957c019064d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_SetAltInterfaceB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>interfaceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>alternateSetting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate a device interface within current device configuration. </p>
<dl class="section note"><dt>Note</dt><dd><br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaceIndex</td><td>The interface index. A zero based value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternateSetting</td><td>The alternate interface setting value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01897">1897</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Device__TypeDef.html#a6faabbcd85b74888a66033798b643455">USBH_Device_TypeDef::ep</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a7a085fe94f3ccae689ff8e1f080bc371">USBH_Device_TypeDef::numEp</a>, <a class="el" href="group__USB__COMMON.html#ga90c9c23759bdbb3ba106f88cb5ffc261">SET_INTERFACE</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a8b219c0a9405e783a1eb1f4285849dd4">USBH_Ep_TypeDef::toggle</a>, <a class="el" href="group__USB__COMMON.html#ga88f4223ae1ca659baa20ddfdb3dcc217">USB_SETUP_DIR_H2D</a>, <a class="el" href="group__USB__COMMON.html#ga59754621c21db801e11513ba06a3a02e">USB_SETUP_RECIPIENT_INTERFACE</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, and <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6938e5856e9d28116922070621be36a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_SetConfigurationB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>configValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate a device configuration. </p>
<dl class="section note"><dt>Note</dt><dd>This command will move the device to the configured state. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configValue</td><td>The configuration value. The value can be retrieved from device-&gt;confDesc.bConfigurationValue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01956">1956</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Device__TypeDef.html#a6faabbcd85b74888a66033798b643455">USBH_Device_TypeDef::ep</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a7a085fe94f3ccae689ff8e1f080bc371">USBH_Device_TypeDef::numEp</a>, <a class="el" href="group__USB__COMMON.html#ga5cdfe3de183eb4e190b2ccaa299045bf">SET_CONFIGURATION</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a8b219c0a9405e783a1eb1f4285849dd4">USBH_Ep_TypeDef::toggle</a>, <a class="el" href="group__USB__COMMON.html#ga88f4223ae1ca659baa20ddfdb3dcc217">USB_SETUP_DIR_H2D</a>, <a class="el" href="group__USB__COMMON.html#gad48131dc5ca47b4b2def65e7bbc8442f">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, and <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga547d9df531d791c90fd6f44d28e7089a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_StallEpB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an endpoint in the stalled (halted) state. </p>
<dl class="section note"><dt>Note</dt><dd>This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02009">2009</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Ep__TypeDef.html#a498ef5c49df06f7516060abba364ce37">USBH_Ep_TypeDef::addr</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ae718c515646ac6c9b9b23b0e53f03ea8">USBH_Ep_TypeDef::parentDevice</a>, <a class="el" href="group__USB__COMMON.html#gaf8b97e67097fbf7d56c3dcac52fe679e">SET_FEATURE</a>, <a class="el" href="group__USB__COMMON.html#ga0a75e9871273bf2c40d1d9aa1641c8ce">USB_FEATURE_ENDPOINT_HALT</a>, <a class="el" href="group__USB__COMMON.html#ga88f4223ae1ca659baa20ddfdb3dcc217">USB_SETUP_DIR_H2D</a>, <a class="el" href="group__USB__COMMON.html#gac6ef27ac78140749f3607246f21c1471">USB_SETUP_RECIPIENT_ENDPOINT</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, and <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga154c6b268f2d39d4e1577f917e0da239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBH_Stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop USB host operation. </p>
<p>USB host operation is terminated and VBUS on the port is turned off. </p>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02036">2036</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__EFM32LG995F256__Peripheral__Declaration.html#ga0ed1d26edfd19bbb92da3601b9804750">CMU</a>, <a class="el" href="group__EFM32LG__CMU__BitFields.html#ga4734bcc381ac0f16635454dd90452b7a">CMU_HFCORECLKEN0_USB</a>, <a class="el" href="group__EFM32LG__CMU__BitFields.html#ga1ac2c5862e307be1b5612253be11d8f0">CMU_HFCORECLKEN0_USBC</a>, <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, and <a class="el" href="group__USB__COMMON.html#gab73c922427cf0d509788a8063451703f">USBTIMER_Stop()</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB()</a>.</p>

</div>
</div>
<a class="anchor" id="gabf8fcc4a69080f3d1005d1bc21d44218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_UnStallEpB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset stall state on a stalled (halted) endpoint. </p>
<dl class="section note"><dt>Note</dt><dd>This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02068">2068</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Ep__TypeDef.html#a498ef5c49df06f7516060abba364ce37">USBH_Ep_TypeDef::addr</a>, <a class="el" href="group__USB__COMMON.html#ga1908d37748e7d545ee5f190715624150">CLEAR_FEATURE</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a6babfb30fb631b15a7177342a1912b38">USBH_Device_TypeDef::ep0</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ae718c515646ac6c9b9b23b0e53f03ea8">USBH_Ep_TypeDef::parentDevice</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a8b219c0a9405e783a1eb1f4285849dd4">USBH_Ep_TypeDef::toggle</a>, <a class="el" href="group__USB__COMMON.html#ga0a75e9871273bf2c40d1d9aa1641c8ce">USB_FEATURE_ENDPOINT_HALT</a>, <a class="el" href="group__USB__COMMON.html#ga88f4223ae1ca659baa20ddfdb3dcc217">USB_SETUP_DIR_H2D</a>, <a class="el" href="group__USB__COMMON.html#gac6ef27ac78140749f3607246f21c1471">USB_SETUP_RECIPIENT_ENDPOINT</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, and <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a>.</p>

<p>Referenced by <a class="el" href="group__Msd.html#ga924b6ac8bbbb582c299825f371813067">MSDBOT_Xfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga62f99f2ed786c98d00935fc2fd140aaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_WaitForDeviceConnectionB </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutInSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for device connection. </p>
<p>This function will wait for device connection and try to read the 8 first bytes of the device descriptor. <br />
 First the USB peripheral is initializet (reset) and VBUS is turned on. When a device is connected, an USB reset will be signalled on the USB port, and then a USB GetDescriptor command is performed. <br />
 This procedure is repeated until success or timeout. On each iteration the duration of USB reset signalling is varied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer with sufficent space for retrieving the first 8 bytes of a device descriptor. The data buffer size must be sizeof( <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> ) + 8.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutInSeconds</td><td>Timeout in seconds. A value of 0 means infinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a69c65b08dff316759c941351aa70a905">USB_STATUS_TIMEOUT</a> on timeout, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1aa9c73dd98ee624ee7d4b8f7c2ec7206b">USB_STATUS_DEVICE_MALFUNCTION</a> if a device was attached but USB communications could not be succesfully established with the device, or <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1aa84fb30ea08f226b475c1bb137483023">USB_STATUS_PORT_OVERCURRENT</a> if a VBUS overcurrent condition exist. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02146">2146</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__EFM32LG995F256__Peripheral__Declaration.html#ga0ed1d26edfd19bbb92da3601b9804750">CMU</a>, <a class="el" href="group__EFM32LG__CMU__BitFields.html#ga4734bcc381ac0f16635454dd90452b7a">CMU_HFCORECLKEN0_USB</a>, <a class="el" href="group__EFM32LG__CMU__BitFields.html#ga1ac2c5862e307be1b5612253be11d8f0">CMU_HFCORECLKEN0_USBC</a>, <a class="el" href="structUSBH__Device__TypeDef.html#a07597207c1bc0d5a2795944c687ca812">USBH_Device_TypeDef::devDesc</a>, <a class="el" href="group__GPIO.html#gac1050d30b940c30899c63aa060fa4dba">GPIO_PinInGet()</a>, <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1aa9c73dd98ee624ee7d4b8f7c2ec7206b">USB_STATUS_DEVICE_MALFUNCTION</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1aa84fb30ea08f226b475c1bb137483023">USB_STATUS_PORT_OVERCURRENT</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a69c65b08dff316759c941351aa70a905">USB_STATUS_TIMEOUT</a>, <a class="el" href="group__USB__HOST.html#gaf791f134a36bb5376abaf59c45b84e84">USBH_DeviceConnected()</a>, <a class="el" href="group__USB__HOST.html#ga2656404a391e6894b03dde7d42d11f4f">USBH_GetDeviceDescriptorB()</a>, <a class="el" href="group__USB__HOST.html#gad011363a4aa7f78c702a361bcebe67fb">USBH_GetPortSpeed()</a>, <a class="el" href="group__USB__HOST.html#ga50dc10ac598c6c8479319ff58c186266">USBH_InitDeviceData()</a>, <a class="el" href="group__USB__HOST.html#ga154c6b268f2d39d4e1577f917e0da239">USBH_Stop()</a>, <a class="el" href="group__USB__COMMON.html#gabb1c11cad365c7c3b99a3e7826035951">USBTIMER_DelayMs()</a>, and <a class="el" href="group__USB__COMMON.html#gab73c922427cf0d509788a8063451703f">USBTIMER_Stop()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c9fcc6a9f2db01206c010330b6e41f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to device endpoint, non-blocking version. </p>
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. <br />
 This function is non-blocking and returns immediately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteCount</td><td>Number of bytes to transfer (zero is a valid value).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to be called on transfer completion. Supply NULL if no callback is needed. See <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02297">2297</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="structUSBH__Ep__TypeDef.html#a0fd9a2e769340251d88643f2392ee362">USBH_Ep_TypeDef::buf</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a86a128ca7350399f382b97cdf139f7e5">USBH_Ep_TypeDef::epDesc</a>, <a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2aae603b4f9bb26371efdbbe4894308bf3">H_EP_DATA_OUT</a>, <a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2acd80bb986620028db2b94739d20e59f6">H_EP_IDLE</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a4ca23c7736c6ded42faca4886ca610e5">USBH_Ep_TypeDef::hcOut</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#aca0fb63debe406a69b27832d8ede497e">USBH_Ep_TypeDef::in</a>, <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ac2279b4158fac0939e5eed3a37c2e39f">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ad1d3154129fda09c6057495e1afa2cc7">USBH_Ep_TypeDef::remaining</a>, <a class="el" href="group__COMMON.html#ga9569b0ba06efef226b0a82109eef3ec3">SL_MIN</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a372dcdc1c18e02de60ff95581984b5fe">USBH_Ep_TypeDef::state</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#afc297ff52c3bd575b40e26b843364564">USBH_Ep_TypeDef::timeout</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#aaec68ed616a7586b97748117fc428ce2">USBH_Ep_TypeDef::type</a>, <a class="el" href="group__USB__COMMON.html#ga5afdd9301e4641dbd23dc1d994958f86">USB_EPTYPE_INTR</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1afa326e98a111316089803b32218fa176">USB_STATUS_EP_BUSY</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1aab9974d621b469d47637c07d1ee0c29f">USB_STATUS_HC_BUSY</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, <a class="el" href="group__USB__HOST.html#gaf791f134a36bb5376abaf59c45b84e84">USBH_DeviceConnected()</a>, <a class="el" href="group__USB__COMMON.html#gac2a406f16d989b04c4fc5b37d5c10b45">USBTIMER_Start()</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#ad69013d2335283397b539f0d59c0f7ef">USBH_Ep_TypeDef::xferCompleteCb</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a12e951b4d75eab6e4b68de674110efff">USBH_Ep_TypeDef::xferCompleted</a>, and <a class="el" href="structUSBH__Ep__TypeDef.html#a771ee9abfb47d3eeba3806197b2855e2">USBH_Ep_TypeDef::xferred</a>.</p>

<p>Referenced by <a class="el" href="group__USB__HOST.html#ga27c7b3b7944f7f1b8e4327dd66fa7ff8">USBH_WriteB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga27c7b3b7944f7f1b8e4327dd66fa7ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_WriteB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to device endpoint, blocking version. </p>
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. <br />
 This function is blocking and will not return before the transfer has completed, timed out or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteCount</td><td>Number of bytes to transfer (zero is a valid value).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02417">2417</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="group__INT.html#gaa46adfbe58501552a0614c3f7adda6a5">INT_Disable()</a>, <a class="el" href="group__INT.html#gafba0338f70b8fab23d8b5c00ec15df56">INT_Enable()</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a1792144148bac0a51ebc387e74e85257">USB_STATUS_ILLEGAL</a>, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a>, <a class="el" href="group__USB__HOST.html#ga0c9fcc6a9f2db01206c010330b6e41f6">USBH_Write()</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a12e951b4d75eab6e4b68de674110efff">USBH_Ep_TypeDef::xferCompleted</a>, <a class="el" href="structUSBH__Ep__TypeDef.html#a771ee9abfb47d3eeba3806197b2855e2">USBH_Ep_TypeDef::xferred</a>, and <a class="el" href="structUSBH__Ep__TypeDef.html#a2e94cea0590006aeb094e9646d23831a">USBH_Ep_TypeDef::xferStatus</a>.</p>

<p>Referenced by <a class="el" href="group__Msd.html#ga924b6ac8bbbb582c299825f371813067">MSDBOT_Xfer()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 10 2016 14:30:02 for EFM32 Leopard Gecko Software Documentation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
