<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>EFM32 Leopard Gecko Software Documentation: USB_HOST</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EFM32 Leopard Gecko Software Documentation
   &#160;<span id="projectnumber">efm32lg-doc-4.2.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="../../index.html"><span>Documentation&#160;Home</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__USB__HOST.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB_HOST<div class="ingroups"><a class="el" href="group__USB.html">USB</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>USB HOST protocol stack, see <a class="el" href="group__USB.html">USB host stack library</a> page for detailed documentation. </p><pre class="fragment"></pre><p>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB HOST endpoint status data.  <a href="structUSBH__Ep__TypeDef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB HOST device definition.  <a href="structUSBH__Device__TypeDef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB Host stack initialization structure.  <a href="structUSBH__Init__TypeDef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga4d1c6a944470a42cd40e4eac28a1402f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga4d1c6a944470a42cd40e4eac28a1402f">USB_VBUSOVRCUR_PORT_NONE</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:ga4d1c6a944470a42cd40e4eac28a1402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5f204c3862e9c3d6dd469e98ea7c456"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gad5f204c3862e9c3d6dd469e98ea7c456">USB_VBUSOVRCUR_POLARITY_LOW</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gad5f204c3862e9c3d6dd469e98ea7c456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga011ca5b4422ca0d7b2ac5baae77f6b99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga011ca5b4422ca0d7b2ac5baae77f6b99">USB_VBUSOVRCUR_POLARITY_HIGH</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ga011ca5b4422ca0d7b2ac5baae77f6b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f0c44025ac0a0a70bdbd8ebebbd3f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gae4f0c44025ac0a0a70bdbd8ebebbd3f1">USBH_INIT_DEFAULT</a></td></tr>
<tr class="separator:gae4f0c44025ac0a0a70bdbd8ebebbd3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5ccbba1464980cf59277cd2a6765c14d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga5ccbba1464980cf59277cd2a6765c14d">USBH_Device_TypeDef</a></td></tr>
<tr class="memdesc:ga5ccbba1464980cf59277cd2a6765c14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB HOST device definition.  <a href="#ga5ccbba1464980cf59277cd2a6765c14d">More...</a><br /></td></tr>
<tr class="separator:ga5ccbba1464980cf59277cd2a6765c14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga34852d3ee651fb11751f21ccfc6bfcc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga34852d3ee651fb11751f21ccfc6bfcc2">USBH_EpState_TypeDef</a> { <br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2acd80bb986620028db2b94739d20e59f6">H_EP_IDLE</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2abb313be634b2d1baf58b164ef7b96629">H_EP_SETUP</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2ad6473274a34916940013c44581528d92">H_EP_DATA_IN</a> = 2, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2aae603b4f9bb26371efdbbe4894308bf3">H_EP_DATA_OUT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2a8aae8401530f06ea9bf76fde11990333">H_EP_STATUS_IN</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__USB__HOST.html#gga34852d3ee651fb11751f21ccfc6bfcc2a1eb596383547a852e76f4c58c1b38bad">H_EP_STATUS_OUT</a> = 5
<br />
 }<tr class="separator:ga34852d3ee651fb11751f21ccfc6bfcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga06f1146ad72c09a1ed1d9a9c4b98edb2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga06f1146ad72c09a1ed1d9a9c4b98edb2">USBH_AssignHostChannel</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, uint8_t hcnum)</td></tr>
<tr class="memdesc:ga06f1146ad72c09a1ed1d9a9c4b98edb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a host channel to a given endpoint.  <a href="#ga06f1146ad72c09a1ed1d9a9c4b98edb2">More...</a><br /></td></tr>
<tr class="separator:ga06f1146ad72c09a1ed1d9a9c4b98edb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b43c59fc9d3c91d0039f761ef4d6333"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga0b43c59fc9d3c91d0039f761ef4d6333">USBH_ControlMsg</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength, void *data, int timeout, <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a> callback)</td></tr>
<tr class="memdesc:ga0b43c59fc9d3c91d0039f761ef4d6333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a SETUP command to a device, non-blocking version.  <a href="#ga0b43c59fc9d3c91d0039f761ef4d6333">More...</a><br /></td></tr>
<tr class="separator:ga0b43c59fc9d3c91d0039f761ef4d6333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad94fe14defe6b7e33472364c65f07f17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength, void *data, int timeout)</td></tr>
<tr class="memdesc:gad94fe14defe6b7e33472364c65f07f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a SETUP command to a device, blocking version.  <a href="#gad94fe14defe6b7e33472364c65f07f17">More...</a><br /></td></tr>
<tr class="separator:gad94fe14defe6b7e33472364c65f07f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf791f134a36bb5376abaf59c45b84e84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gaf791f134a36bb5376abaf59c45b84e84">USBH_DeviceConnected</a> (void)</td></tr>
<tr class="memdesc:gaf791f134a36bb5376abaf59c45b84e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a device is connected.  <a href="#gaf791f134a36bb5376abaf59c45b84e84">More...</a><br /></td></tr>
<tr class="separator:gaf791f134a36bb5376abaf59c45b84e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad09af4f14c4b205a9e159cb4c5fa7b8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gad09af4f14c4b205a9e159cb4c5fa7b8f">USBH_GetConfigurationDescriptorB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, void *buf, int len, uint8_t configIndex)</td></tr>
<tr class="memdesc:gad09af4f14c4b205a9e159cb4c5fa7b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a configuration descriptor from a device.  <a href="#gad09af4f14c4b205a9e159cb4c5fa7b8f">More...</a><br /></td></tr>
<tr class="separator:gad09af4f14c4b205a9e159cb4c5fa7b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2656404a391e6894b03dde7d42d11f4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga2656404a391e6894b03dde7d42d11f4f">USBH_GetDeviceDescriptorB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, void *buf, int len)</td></tr>
<tr class="memdesc:ga2656404a391e6894b03dde7d42d11f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a device descriptor from a device.  <a href="#ga2656404a391e6894b03dde7d42d11f4f">More...</a><br /></td></tr>
<tr class="separator:ga2656404a391e6894b03dde7d42d11f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad011363a4aa7f78c702a361bcebe67fb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gad011363a4aa7f78c702a361bcebe67fb">USBH_GetPortSpeed</a> (void)</td></tr>
<tr class="memdesc:gad011363a4aa7f78c702a361bcebe67fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bus speed of the device attached to the USB port.  <a href="#gad011363a4aa7f78c702a361bcebe67fb">More...</a><br /></td></tr>
<tr class="separator:gad011363a4aa7f78c702a361bcebe67fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e40f21d20e36116da7a45f4a8b7ee3c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga4e40f21d20e36116da7a45f4a8b7ee3c">USBH_GetStringB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, uint8_t *buf, int bufLen, uint8_t stringIndex, uint16_t langID)</td></tr>
<tr class="memdesc:ga4e40f21d20e36116da7a45f4a8b7ee3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string descriptor from a device.  <a href="#ga4e40f21d20e36116da7a45f4a8b7ee3c">More...</a><br /></td></tr>
<tr class="separator:ga4e40f21d20e36116da7a45f4a8b7ee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb37814762148d4977bd0dbc1a9b46e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gaedb37814762148d4977bd0dbc1a9b46e">USBH_Init</a> (const <a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a> *p)</td></tr>
<tr class="memdesc:gaedb37814762148d4977bd0dbc1a9b46e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize host protocol stack data structures.  <a href="#gaedb37814762148d4977bd0dbc1a9b46e">More...</a><br /></td></tr>
<tr class="separator:gaedb37814762148d4977bd0dbc1a9b46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50dc10ac598c6c8479319ff58c186266"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga50dc10ac598c6c8479319ff58c186266">USBH_InitDeviceData</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, const uint8_t *buf, <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, int numEp, uint8_t deviceSpeed)</td></tr>
<tr class="memdesc:ga50dc10ac598c6c8479319ff58c186266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate device and endpoint data structures with data retrieved during device enumeration.  <a href="#ga50dc10ac598c6c8479319ff58c186266">More...</a><br /></td></tr>
<tr class="separator:ga50dc10ac598c6c8479319ff58c186266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac57479eb6271bc262a6652b50fd122ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gac57479eb6271bc262a6652b50fd122ce">USBH_PortReset</a> (void)</td></tr>
<tr class="memdesc:gac57479eb6271bc262a6652b50fd122ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive reset signalling on the USB port.  <a href="#gac57479eb6271bc262a6652b50fd122ce">More...</a><br /></td></tr>
<tr class="separator:gac57479eb6271bc262a6652b50fd122ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2cb3b486c0d628c23cce6a26984580b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gaa2cb3b486c0d628c23cce6a26984580b">USBH_PortResume</a> (void)</td></tr>
<tr class="memdesc:gaa2cb3b486c0d628c23cce6a26984580b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive resume signalling on the USB port.  <a href="#gaa2cb3b486c0d628c23cce6a26984580b">More...</a><br /></td></tr>
<tr class="separator:gaa2cb3b486c0d628c23cce6a26984580b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b518bcdfa5c19f42a362736767f273c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b518bcdfa5c19f42a362736767f273c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga3b518bcdfa5c19f42a362736767f273c">USBH_PortSuspend</a> (void)</td></tr>
<tr class="memdesc:ga3b518bcdfa5c19f42a362736767f273c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the USB port in suspend mode. <br /></td></tr>
<tr class="separator:ga3b518bcdfa5c19f42a362736767f273c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60806aa452e18cee2002a2a5de015982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga60806aa452e18cee2002a2a5de015982">USBH_PrintString</a> (const char *pre, const <a class="el" href="structUSB__StringDescriptor__TypeDef.html">USB_StringDescriptor_TypeDef</a> *s, const char *post)</td></tr>
<tr class="memdesc:ga60806aa452e18cee2002a2a5de015982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a USB string descriptor on the debug serial port.  <a href="#ga60806aa452e18cee2002a2a5de015982">More...</a><br /></td></tr>
<tr class="separator:ga60806aa452e18cee2002a2a5de015982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a5bb1a4f4cae3b9cc0556b98d3a4d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gab7a5bb1a4f4cae3b9cc0556b98d3a4d9">USBH_PrintConfigurationDescriptor</a> (const <a class="el" href="structUSB__ConfigurationDescriptor__TypeDef.html">USB_ConfigurationDescriptor_TypeDef</a> *config, int maxLen)</td></tr>
<tr class="memdesc:gab7a5bb1a4f4cae3b9cc0556b98d3a4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a configuration descriptor on the debug serial port.  <a href="#gab7a5bb1a4f4cae3b9cc0556b98d3a4d9">More...</a><br /></td></tr>
<tr class="separator:gab7a5bb1a4f4cae3b9cc0556b98d3a4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465475632c744fb3fae7a73e09606fb3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga465475632c744fb3fae7a73e09606fb3">USBH_PrintDeviceDescriptor</a> (const <a class="el" href="structUSB__DeviceDescriptor__TypeDef.html">USB_DeviceDescriptor_TypeDef</a> *device)</td></tr>
<tr class="memdesc:ga465475632c744fb3fae7a73e09606fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print a device descriptor on the debug serial port.  <a href="#ga465475632c744fb3fae7a73e09606fb3">More...</a><br /></td></tr>
<tr class="separator:ga465475632c744fb3fae7a73e09606fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe253e3e072d805774b8714aacf9182c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gabe253e3e072d805774b8714aacf9182c">USBH_PrintEndpointDescriptor</a> (const <a class="el" href="structUSB__EndpointDescriptor__TypeDef.html">USB_EndpointDescriptor_TypeDef</a> *endpoint)</td></tr>
<tr class="memdesc:gabe253e3e072d805774b8714aacf9182c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print an endpoint descriptor on the debug serial port.  <a href="#gabe253e3e072d805774b8714aacf9182c">More...</a><br /></td></tr>
<tr class="separator:gabe253e3e072d805774b8714aacf9182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a4aa696c25dfd0b99a2cda6e02d7a36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga7a4aa696c25dfd0b99a2cda6e02d7a36">USBH_PrintInterfaceDescriptor</a> (const <a class="el" href="structUSB__InterfaceDescriptor__TypeDef.html">USB_InterfaceDescriptor_TypeDef</a> *interface)</td></tr>
<tr class="memdesc:ga7a4aa696c25dfd0b99a2cda6e02d7a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty print an interface descriptor on the debug serial port.  <a href="#ga7a4aa696c25dfd0b99a2cda6e02d7a36">More...</a><br /></td></tr>
<tr class="separator:ga7a4aa696c25dfd0b99a2cda6e02d7a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ef72709bb00accb740a0350f79fe35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB</a> (uint8_t *buf, size_t bufsize, uint8_t deviceSpeed)</td></tr>
<tr class="memdesc:gae9ef72709bb00accb740a0350f79fe35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will request both the device descriptor and the entire configuration descriptor from the device at USB address 0.  <a href="#gae9ef72709bb00accb740a0350f79fe35">More...</a><br /></td></tr>
<tr class="separator:gae9ef72709bb00accb740a0350f79fe35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ac91d938f8553e31913afdb8d8d80dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUSB__ConfigurationDescriptor__TypeDef.html">USB_ConfigurationDescriptor_TypeDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga2ac91d938f8553e31913afdb8d8d80dc">USBH_QGetConfigurationDescriptor</a> (const uint8_t *buf, int configIndex)</td></tr>
<tr class="memdesc:ga2ac91d938f8553e31913afdb8d8d80dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to a configuration descriptor.  <a href="#ga2ac91d938f8553e31913afdb8d8d80dc">More...</a><br /></td></tr>
<tr class="separator:ga2ac91d938f8553e31913afdb8d8d80dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d6a8d78ebde4e394bb25aa62a871b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUSB__DeviceDescriptor__TypeDef.html">USB_DeviceDescriptor_TypeDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga4d6a8d78ebde4e394bb25aa62a871b30">USBH_QGetDeviceDescriptor</a> (const uint8_t *buf)</td></tr>
<tr class="memdesc:ga4d6a8d78ebde4e394bb25aa62a871b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the device descriptor.  <a href="#ga4d6a8d78ebde4e394bb25aa62a871b30">More...</a><br /></td></tr>
<tr class="separator:ga4d6a8d78ebde4e394bb25aa62a871b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e6eb1a2e9802af4ec16254e3d44783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUSB__EndpointDescriptor__TypeDef.html">USB_EndpointDescriptor_TypeDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga10e6eb1a2e9802af4ec16254e3d44783">USBH_QGetEndpointDescriptor</a> (const uint8_t *buf, int configIndex, int interfaceIndex, int endpointIndex)</td></tr>
<tr class="memdesc:ga10e6eb1a2e9802af4ec16254e3d44783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to an endpoint descriptor.  <a href="#ga10e6eb1a2e9802af4ec16254e3d44783">More...</a><br /></td></tr>
<tr class="separator:ga10e6eb1a2e9802af4ec16254e3d44783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd04b4b1ea26459d6db42aa77b6d592d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUSB__InterfaceDescriptor__TypeDef.html">USB_InterfaceDescriptor_TypeDef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gabd04b4b1ea26459d6db42aa77b6d592d">USBH_QGetInterfaceDescriptor</a> (const uint8_t *buf, int configIndex, int interfaceIndex)</td></tr>
<tr class="memdesc:gabd04b4b1ea26459d6db42aa77b6d592d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to an interface descriptor.  <a href="#gabd04b4b1ea26459d6db42aa77b6d592d">More...</a><br /></td></tr>
<tr class="separator:gabd04b4b1ea26459d6db42aa77b6d592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3514adea6bc6da41b8a083153e3f9365"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga3514adea6bc6da41b8a083153e3f9365">USBH_Read</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, void *data, int byteCount, int timeout, <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a> callback)</td></tr>
<tr class="memdesc:ga3514adea6bc6da41b8a083153e3f9365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from device endpoint, non-blocking version.  <a href="#ga3514adea6bc6da41b8a083153e3f9365">More...</a><br /></td></tr>
<tr class="separator:ga3514adea6bc6da41b8a083153e3f9365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5829c1ebeed8cfd36317dd57c6584c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gab5829c1ebeed8cfd36317dd57c6584c9">USBH_ReadB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, void *data, int byteCount, int timeout)</td></tr>
<tr class="memdesc:gab5829c1ebeed8cfd36317dd57c6584c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from device endpoint, blocking version.  <a href="#gab5829c1ebeed8cfd36317dd57c6584c9">More...</a><br /></td></tr>
<tr class="separator:gab5829c1ebeed8cfd36317dd57c6584c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac93ecf15f240abf7093506c8e8ef9e61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gac93ecf15f240abf7093506c8e8ef9e61">USBH_SetAddressB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, uint8_t deviceAddress)</td></tr>
<tr class="memdesc:gac93ecf15f240abf7093506c8e8ef9e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a device an USB address.  <a href="#gac93ecf15f240abf7093506c8e8ef9e61">More...</a><br /></td></tr>
<tr class="separator:gac93ecf15f240abf7093506c8e8ef9e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f156ce4b8660203cf4957c019064d9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga0f156ce4b8660203cf4957c019064d9f">USBH_SetAltInterfaceB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, uint8_t interfaceIndex, uint8_t alternateSetting)</td></tr>
<tr class="memdesc:ga0f156ce4b8660203cf4957c019064d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a device interface within current device configuration.  <a href="#ga0f156ce4b8660203cf4957c019064d9f">More...</a><br /></td></tr>
<tr class="separator:ga0f156ce4b8660203cf4957c019064d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6938e5856e9d28116922070621be36a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga6938e5856e9d28116922070621be36a5">USBH_SetConfigurationB</a> (<a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *device, uint8_t configValue)</td></tr>
<tr class="memdesc:ga6938e5856e9d28116922070621be36a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate a device configuration.  <a href="#ga6938e5856e9d28116922070621be36a5">More...</a><br /></td></tr>
<tr class="separator:ga6938e5856e9d28116922070621be36a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga547d9df531d791c90fd6f44d28e7089a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga547d9df531d791c90fd6f44d28e7089a">USBH_StallEpB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep)</td></tr>
<tr class="memdesc:ga547d9df531d791c90fd6f44d28e7089a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an endpoint in the stalled (halted) state.  <a href="#ga547d9df531d791c90fd6f44d28e7089a">More...</a><br /></td></tr>
<tr class="separator:ga547d9df531d791c90fd6f44d28e7089a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154c6b268f2d39d4e1577f917e0da239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga154c6b268f2d39d4e1577f917e0da239">USBH_Stop</a> (void)</td></tr>
<tr class="memdesc:ga154c6b268f2d39d4e1577f917e0da239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop USB host operation.  <a href="#ga154c6b268f2d39d4e1577f917e0da239">More...</a><br /></td></tr>
<tr class="separator:ga154c6b268f2d39d4e1577f917e0da239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf8fcc4a69080f3d1005d1bc21d44218"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#gabf8fcc4a69080f3d1005d1bc21d44218">USBH_UnStallEpB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep)</td></tr>
<tr class="memdesc:gabf8fcc4a69080f3d1005d1bc21d44218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset stall state on a stalled (halted) endpoint.  <a href="#gabf8fcc4a69080f3d1005d1bc21d44218">More...</a><br /></td></tr>
<tr class="separator:gabf8fcc4a69080f3d1005d1bc21d44218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62f99f2ed786c98d00935fc2fd140aaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB</a> (uint8_t *buf, int timeoutInSeconds)</td></tr>
<tr class="memdesc:ga62f99f2ed786c98d00935fc2fd140aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for device connection.  <a href="#ga62f99f2ed786c98d00935fc2fd140aaf">More...</a><br /></td></tr>
<tr class="separator:ga62f99f2ed786c98d00935fc2fd140aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c9fcc6a9f2db01206c010330b6e41f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga0c9fcc6a9f2db01206c010330b6e41f6">USBH_Write</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, void *data, int byteCount, int timeout, <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a> callback)</td></tr>
<tr class="memdesc:ga0c9fcc6a9f2db01206c010330b6e41f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to device endpoint, non-blocking version.  <a href="#ga0c9fcc6a9f2db01206c010330b6e41f6">More...</a><br /></td></tr>
<tr class="separator:ga0c9fcc6a9f2db01206c010330b6e41f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c7b3b7944f7f1b8e4327dd66fa7ff8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html#ga27c7b3b7944f7f1b8e4327dd66fa7ff8">USBH_WriteB</a> (<a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *ep, void *data, int byteCount, int timeout)</td></tr>
<tr class="memdesc:ga27c7b3b7944f7f1b8e4327dd66fa7ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to device endpoint, blocking version.  <a href="#ga27c7b3b7944f7f1b8e4327dd66fa7ff8">More...</a><br /></td></tr>
<tr class="separator:ga27c7b3b7944f7f1b8e4327dd66fa7ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga4d1c6a944470a42cd40e4eac28a1402f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_VBUSOVRCUR_PORT_NONE&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No overcurrent flag functionality. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00843">843</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad5f204c3862e9c3d6dd469e98ea7c456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_VBUSOVRCUR_POLARITY_LOW&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overcurrent flag pin polarity is low. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00844">844</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga011ca5b4422ca0d7b2ac5baae77f6b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_VBUSOVRCUR_POLARITY_HIGH&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overcurrent flag pin polarity is high. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00845">845</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae4f0c44025ac0a0a70bdbd8ebebbd3f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBH_INIT_DEFAULT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                            \</div>
<div class="line">  MAX_HOST_FIFO_SIZE_INWORDS * 2,<span class="comment">/* 1024 bytes Rx FIFO size.             */</span>  \</div>
<div class="line">  MAX_HOST_FIFO_SIZE_INWORDS,    <span class="comment">/* 512 bytes non-periodic Tx FIFO size. */</span>  \</div>
<div class="line">  MAX_HOST_FIFO_SIZE_INWORDS,    <span class="comment">/* 512 bytes periodic Tx FIFO size.     */</span>  \</div>
<div class="line">  0                              <span class="comment">/* Reserved.                            */</span>  \</div>
<div class="line">}</div>
</div><!-- fragment --><p>Default <a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a> values, provides reasonable Tx/Rx FIFO partitioning. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00919">919</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5ccbba1464980cf59277cd2a6765c14d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a>  <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A host application should not manipulate the contents of this struct. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga34852d3ee651fb11751f21ccfc6bfcc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__USB__HOST.html#ga34852d3ee651fb11751f21ccfc6bfcc2">USBH_EpState_TypeDef</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB HOST endpoint status enumerator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2acd80bb986620028db2b94739d20e59f6"></a>H_EP_IDLE&#160;</td><td class="fielddoc">
<p>The endpoint is idle. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2abb313be634b2d1baf58b164ef7b96629"></a>H_EP_SETUP&#160;</td><td class="fielddoc">
<p>The endpoint is in SETUP stage. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2ad6473274a34916940013c44581528d92"></a>H_EP_DATA_IN&#160;</td><td class="fielddoc">
<p>The endpoint is in DATA IN stage. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2aae603b4f9bb26371efdbbe4894308bf3"></a>H_EP_DATA_OUT&#160;</td><td class="fielddoc">
<p>The endpoint is in DATA OUT stage. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2a8aae8401530f06ea9bf76fde11990333"></a>H_EP_STATUS_IN&#160;</td><td class="fielddoc">
<p>The endpoint is in STATUS IN stage. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga34852d3ee651fb11751f21ccfc6bfcc2a1eb596383547a852e76f4c58c1b38bad"></a>H_EP_STATUS_OUT&#160;</td><td class="fielddoc">
<p>The endpoint is in STATUS OUT stage. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00848">848</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga06f1146ad72c09a1ed1d9a9c4b98edb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_AssignHostChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hcnum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hcnum</td><td>Host channel number (0..).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code.</dd></dl>
<p>After assigning a host channel to an endpoint, all subsequent transfers to the endpoint will use the given host channel. Several endpoints can be assigned to the same host channel, but keep in mind that concurrent transfers can only be performed on endpoints assigned to different host channels. <br />
 The default endpoint (EP0) is assigned to host channels 0 and 1 by the host stack. </p>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00160">160</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00875">USBH_Ep_TypeDef::addr</a>, <a class="el" href="em__usb_8h_source.html#l00502">USB_EndpointDescriptor_TypeDef::bEndpointAddress</a>, <a class="el" href="em__usb_8h_source.html#l00503">USB_EndpointDescriptor_TypeDef::bmAttributes</a>, <a class="el" href="em__usb_8h_source.html#l00186">CONFIG_DESC_BM_TRANSFERTYPE</a>, <a class="el" href="em__usb_8h_source.html#l00866">USBH_Ep_TypeDef::epDesc</a>, <a class="el" href="em__usb_8h_source.html#l00850">H_EP_IDLE</a>, <a class="el" href="em__usb_8h_source.html#l00871">USBH_Ep_TypeDef::hcIn</a>, <a class="el" href="em__usb_8h_source.html#l00870">USBH_Ep_TypeDef::hcOut</a>, <a class="el" href="em__usb_8h_source.html#l00872">USBH_Ep_TypeDef::in</a>, <a class="el" href="em__usb_8h_source.html#l00869">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="em__usb_8h_source.html#l00874">USBH_Ep_TypeDef::state</a>, <a class="el" href="em__usb_8h_source.html#l00868">USBH_Ep_TypeDef::type</a>, <a class="el" href="em__usb_8h_source.html#l00060">USB_SETUP_DIR_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usb_8h_source.html#l00504">USB_EndpointDescriptor_TypeDef::wMaxPacketSize</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b43c59fc9d3c91d0039f761ef4d6333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_ControlMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bmRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is non-blocking and returns immediately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bmRequestType</td><td>SETUP command request type. A suitable combination of values <a class="el" href="group__USB__COMMON.html#ga204e51e67cf7671617112b94ecfe3a46">USB_SETUP_DIR_D2H</a>, <a class="el" href="group__USB__COMMON.html#ga88f4223ae1ca659baa20ddfdb3dcc217">USB_SETUP_DIR_H2D</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#ga8067a7210027455955067dc98e111494">USB_SETUP_TYPE_CLASS_MASK</a>, <a class="el" href="group__USB__COMMON.html#ga7e1d5f94bc4780ea74aea4efa5cbd804">USB_SETUP_TYPE_VENDOR_MASK</a>, <a class="el" href="group__USB__COMMON.html#gad48131dc5ca47b4b2def65e7bbc8442f">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="group__USB__COMMON.html#ga59754621c21db801e11513ba06a3a02e">USB_SETUP_RECIPIENT_INTERFACE</a>, <a class="el" href="group__USB__COMMON.html#gac6ef27ac78140749f3607246f21c1471">USB_SETUP_RECIPIENT_ENDPOINT</a> or <a class="el" href="group__USB__COMMON.html#gaa1a71b2e05ba5682c956d8dfdf01d40b">USB_SETUP_RECIPIENT_OTHER</a>.<br />
 Refer to the USB specification for details.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bRequest</td><td>A specific SETUP command request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wValue</td><td>Word sized field that varies according to request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wIndex</td><td>Word sized field that varies according to request. Typically used to pass an index or offset.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wLength</td><td>Number of bytes to transfer if there is a data stage.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to be called on transfer completion. Supply NULL if no callback is needed. See <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00246">246</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00389">USB_Setup_TypeDef::bmRequestType</a>, <a class="el" href="em__usb_8h_source.html#l00391">USB_Setup_TypeDef::bRequest</a>, <a class="el" href="em__usb_8h_source.html#l00876">USBH_Ep_TypeDef::buf</a>, <a class="el" href="em__usb_8h_source.html#l00850">H_EP_IDLE</a>, <a class="el" href="em__usb_8h_source.html#l00851">H_EP_SETUP</a>, <a class="el" href="em__usb_8h_source.html#l00871">USBH_Ep_TypeDef::hcIn</a>, <a class="el" href="em__usb_8h_source.html#l00870">USBH_Ep_TypeDef::hcOut</a>, <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00864">USBH_Ep_TypeDef::setup</a>, <a class="el" href="em__usb_8h_source.html#l00865">USBH_Ep_TypeDef::setupErrCnt</a>, <a class="el" href="em__usb_8h_source.html#l00874">USBH_Ep_TypeDef::state</a>, <a class="el" href="em__usb_8h_source.html#l00882">USBH_Ep_TypeDef::timeout</a>, <a class="el" href="em__usb_8h_source.html#l00321">USB_STATUS_EP_BUSY</a>, <a class="el" href="em__usb_8h_source.html#l00333">USB_STATUS_HC_BUSY</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usbh_8c_source.html#l00612">USBH_DeviceConnected()</a>, <a class="el" href="em__usbtimer_8c_source.html#l00234">USBTIMER_Start()</a>, <a class="el" href="em__usb_8h_source.html#l00393">USB_Setup_TypeDef::wIndex</a>, <a class="el" href="em__usb_8h_source.html#l00394">USB_Setup_TypeDef::wLength</a>, <a class="el" href="em__usb_8h_source.html#l00392">USB_Setup_TypeDef::wValue</a>, <a class="el" href="em__usb_8h_source.html#l00879">USBH_Ep_TypeDef::xferCompleteCb</a>, <a class="el" href="em__usb_8h_source.html#l00877">USBH_Ep_TypeDef::xferCompleted</a>, and <a class="el" href="em__usb_8h_source.html#l00880">USBH_Ep_TypeDef::xferred</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l00367">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="gad94fe14defe6b7e33472364c65f07f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_ControlMsgB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bmRequestType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bmRequestType</td><td>SETUP command request type. A suitable combination of values <a class="el" href="group__USB__COMMON.html#ga204e51e67cf7671617112b94ecfe3a46">USB_SETUP_DIR_D2H</a>, <a class="el" href="group__USB__COMMON.html#ga88f4223ae1ca659baa20ddfdb3dcc217">USB_SETUP_DIR_H2D</a>, <a class="el" href="group__USB__COMMON.html#ga10487f57d22e32059947a62ba2fc5228">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="group__USB__COMMON.html#ga8067a7210027455955067dc98e111494">USB_SETUP_TYPE_CLASS_MASK</a>, <a class="el" href="group__USB__COMMON.html#ga7e1d5f94bc4780ea74aea4efa5cbd804">USB_SETUP_TYPE_VENDOR_MASK</a>, <a class="el" href="group__USB__COMMON.html#gad48131dc5ca47b4b2def65e7bbc8442f">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="group__USB__COMMON.html#ga59754621c21db801e11513ba06a3a02e">USB_SETUP_RECIPIENT_INTERFACE</a>, <a class="el" href="group__USB__COMMON.html#gac6ef27ac78140749f3607246f21c1471">USB_SETUP_RECIPIENT_ENDPOINT</a> or <a class="el" href="group__USB__COMMON.html#gaa1a71b2e05ba5682c956d8dfdf01d40b">USB_SETUP_RECIPIENT_OTHER</a>.<br />
 Refer to the USB specification for details.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bRequest</td><td>A specific SETUP command request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wValue</td><td>Word sized field that varies according to request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wIndex</td><td>Word sized field that varies according to request. Typically used to pass an index or offset.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wLength</td><td>Number of bytes to transfer if there is a data stage.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00367">367</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usbh_8c_source.html#l00246">USBH_ControlMsg()</a>, <a class="el" href="em__usb_8h_source.html#l00877">USBH_Ep_TypeDef::xferCompleted</a>, <a class="el" href="em__usb_8h_source.html#l00880">USBH_Ep_TypeDef::xferred</a>, and <a class="el" href="em__usb_8h_source.html#l00878">USBH_Ep_TypeDef::xferStatus</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l00647">USBH_GetConfigurationDescriptorB()</a>, <a class="el" href="em__usbh_8c_source.html#l00704">USBH_GetDeviceDescriptorB()</a>, <a class="el" href="em__usbh_8c_source.html#l00779">USBH_GetStringB()</a>, <a class="el" href="em__usbh_8c_source.html#l01841">USBH_SetAddressB()</a>, <a class="el" href="em__usbh_8c_source.html#l01897">USBH_SetAltInterfaceB()</a>, <a class="el" href="em__usbh_8c_source.html#l01956">USBH_SetConfigurationB()</a>, <a class="el" href="em__usbh_8c_source.html#l02009">USBH_StallEpB()</a>, and <a class="el" href="em__usbh_8c_source.html#l02068">USBH_UnStallEpB()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf791f134a36bb5376abaf59c45b84e84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USBH_DeviceConnected </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if device connected, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00612">612</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l00246">USBH_ControlMsg()</a>, <a class="el" href="em__usbh_8c_source.html#l01672">USBH_Read()</a>, <a class="el" href="em__usbh_8c_source.html#l02146">USBH_WaitForDeviceConnectionB()</a>, and <a class="el" href="em__usbh_8c_source.html#l02297">USBH_Write()</a>.</p>

</div>
</div>
<a class="anchor" id="gad09af4f14c4b205a9e159cb4c5fa7b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_GetConfigurationDescriptorB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>configIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to request, must not exceed transfer data buffer size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configIndex</td><td>Configuration index, a zero based number indicating which configuration to request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00647">647</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00083">GET_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00117">USB_CONFIG_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00061">USB_SETUP_DIR_D2H</a>, <a class="el" href="em__usb_8h_source.html#l00073">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="em__usb_8h_source.html#l00068">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, and <a class="el" href="em__usbh_8c_source.html#l00367">USBH_ControlMsgB()</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l01582">USBH_QueryDeviceB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2656404a391e6894b03dde7d42d11f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_GetDeviceDescriptorB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes to request, must not exceed transfer data buffer size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00704">704</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00083">GET_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00116">USB_DEVICE_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00061">USB_SETUP_DIR_D2H</a>, <a class="el" href="em__usb_8h_source.html#l00073">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="em__usb_8h_source.html#l00068">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, and <a class="el" href="em__usbh_8c_source.html#l00367">USBH_ControlMsgB()</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l01582">USBH_QueryDeviceB()</a>, and <a class="el" href="em__usbh_8c_source.html#l02146">USBH_WaitForDeviceConnectionB()</a>.</p>

</div>
</div>
<a class="anchor" id="gad011363a4aa7f78c702a361bcebe67fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t USBH_GetPortSpeed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gac483b34de71117d1db0dc1d9c1f896d9">PORT_FULL_SPEED</a> or <a class="el" href="group__USB__COMMON.html#gab35af8fb505263e1e594d07f9e5c8253">PORT_LOW_SPEED</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00741">741</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>Referenced by <a class="el" href="msdh_8c_source.html#l00059">MSDH_Init()</a>, and <a class="el" href="em__usbh_8c_source.html#l02146">USBH_WaitForDeviceConnectionB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e40f21d20e36116da7a45f4a8b7ee3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_GetStringB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stringIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>langID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed. <br />
 The maximum permitted USB string lenght is 255 bytes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufLen</td><td>Transfer data buffer size.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringIndex</td><td>String index, a zero based number indicating which string to request.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">langID</td><td>String language ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00779">779</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__common_8h_source.html#l00079">EFM32_MIN</a>, <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00083">GET_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00514">USB_StringDescriptor_TypeDef::len</a>, <a class="el" href="em__usb_8h_source.html#l00516">USB_StringDescriptor_TypeDef::name</a>, <a class="el" href="em__usb_8h_source.html#l00061">USB_SETUP_DIR_D2H</a>, <a class="el" href="em__usb_8h_source.html#l00073">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="em__usb_8h_source.html#l00068">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00118">USB_STRING_DESCRIPTOR</a>, and <a class="el" href="em__usbh_8c_source.html#l00367">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="gaedb37814762148d4977bd0dbc1a9b46e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Pointer to initialization structure. See <a class="el" href="structUSBH__Init__TypeDef.html">USBH_Init_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Host stack internal data structures are initialized, no actions will be performed on the USB port. Use this function once before starting USB host operation. USB operation is initated with <a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00837">837</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="efm32lg995f256_8h_source.html#l00384">CMU</a>, <a class="el" href="em__cmu_8c_source.html#l02406">CMU_ClockSelectSet()</a>, <a class="el" href="efm32lg__cmu_8h_source.html#l00492">CMU_CMD_USBCCLKSEL_HFCLKNODIV</a>, <a class="el" href="efm32lg__cmu_8h_source.html#l00830">CMU_HFCORECLKEN0_USB</a>, <a class="el" href="efm32lg__cmu_8h_source.html#l00825">CMU_HFCORECLKEN0_USBC</a>, <a class="el" href="em__cmu_8h_source.html#l00265">cmuClock_HF</a>, <a class="el" href="em__cmu_8h_source.html#l00956">cmuSelect_HFXO</a>, <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00908">USBH_Init_TypeDef::nptxFifoSize</a>, <a class="el" href="em__usb_8h_source.html#l00909">USBH_Init_TypeDef::ptxFifoSize</a>, <a class="el" href="em__usb_8h_source.html#l00907">USBH_Init_TypeDef::rxFifoSize</a>, <a class="el" href="efm32lg995f256_8h_source.html#l00072">USB_IRQn</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usbtimer_8c_source.html#l00190">USBTIMER_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga50dc10ac598c6c8479319ff58c186266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_InitDeviceData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>deviceSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to an array of <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> endpoint data structures.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numEp</td><td>Number of elements in endpoint array.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceSpeed</td><td><a class="el" href="group__USB__COMMON.html#gac483b34de71117d1db0dc1d9c1f896d9">PORT_FULL_SPEED</a> or <a class="el" href="group__USB__COMMON.html#gab35af8fb505263e1e594d07f9e5c8253">PORT_LOW_SPEED</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>Use this function prior to moving a device out of default state. The application itself must allocate device and endpoint structures. Data from a prior call to <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a> must be passed in input parameter <em>buf</em>. The device speed can be determined with <a class="el" href="group__USB__HOST.html#gad011363a4aa7f78c702a361bcebe67fb">USBH_GetPortSpeed()</a> for devices directly attached to the USB port. Devices attached via a hub must retrieve this information by querying the hub. </p>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00905">905</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00897">USBH_Device_TypeDef::addr</a>, <a class="el" href="em__usb_8h_source.html#l00892">USBH_Device_TypeDef::confDesc</a>, <a class="el" href="em__usb_8h_source.html#l00891">USBH_Device_TypeDef::devDesc</a>, <a class="el" href="em__usb_8h_source.html#l00895">USBH_Device_TypeDef::ep</a>, <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00866">USBH_Ep_TypeDef::epDesc</a>, <a class="el" href="em__usb_8h_source.html#l00871">USBH_Ep_TypeDef::hcIn</a>, <a class="el" href="em__usb_8h_source.html#l00870">USBH_Ep_TypeDef::hcOut</a>, <a class="el" href="em__usb_8h_source.html#l00893">USBH_Device_TypeDef::itfDesc</a>, <a class="el" href="em__usb_8h_source.html#l00896">USBH_Device_TypeDef::numEp</a>, <a class="el" href="em__usb_8h_source.html#l00869">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="em__usb_8h_source.html#l00867">USBH_Ep_TypeDef::parentDevice</a>, <a class="el" href="em__usb_8h_source.html#l00898">USBH_Device_TypeDef::speed</a>, <a class="el" href="em__usb_8h_source.html#l00873">USBH_Ep_TypeDef::toggle</a>, <a class="el" href="em__usb_8h_source.html#l00868">USBH_Ep_TypeDef::type</a>, <a class="el" href="em__usb_8h_source.html#l00145">USB_CONFIG_DESCSIZE</a>, <a class="el" href="em__usb_8h_source.html#l00144">USB_DEVICE_DESCSIZE</a>, <a class="el" href="em__usb_8h_source.html#l00147">USB_ENDPOINT_DESCSIZE</a>, <a class="el" href="em__usb_8h_source.html#l00169">USB_EPTYPE_CTRL</a>, <a class="el" href="em__usb_8h_source.html#l00146">USB_INTERFACE_DESCSIZE</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usbh_8c_source.html#l01434">USBH_QGetEndpointDescriptor()</a>, and <a class="el" href="em__usbh_8c_source.html#l01506">USBH_QGetInterfaceDescriptor()</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l01582">USBH_QueryDeviceB()</a>, and <a class="el" href="em__usbh_8c_source.html#l02146">USBH_WaitForDeviceConnectionB()</a>.</p>

</div>
</div>
<a class="anchor" id="gac57479eb6271bc262a6652b50fd122ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PortReset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is primarily meant for debugging a device. When returning the device will appear to be disconnected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l00982">982</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usbtimer_8c_source.html#l00135">USBTIMER_DelayMs()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa2cb3b486c0d628c23cce6a26984580b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PortResume </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01012">1012</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usbtimer_8c_source.html#l00135">USBTIMER_DelayMs()</a>.</p>

</div>
</div>
<a class="anchor" id="ga60806aa452e18cee2002a2a5de015982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBH_PrintString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structUSB__StringDescriptor__TypeDef.html">USB_StringDescriptor_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>post</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is enabled when the #define USER_PUTCHAR macro is properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pre</td><td>Optional text string to prepend to the string descriptor. Pass NULL if not needed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Pointer to a <a class="el" href="structUSB__StringDescriptor__TypeDef.html">USB_StringDescriptor_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">post</td><td>Optional text string to append to the string descriptor. Pass NULL if not needed. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01268">1268</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00516">USB_StringDescriptor_TypeDef::name</a>, <a class="el" href="group__USB__COMMON.html#gac49ccf1d69a08567d1a5911b0312e735">USB_PUTCHAR()</a>, and <a class="el" href="group__USB__COMMON.html#ga7276e056a2f6aeb99240f72529f41f8f">USB_PUTS()</a>.</p>

</div>
</div>
<a class="anchor" id="gab7a5bb1a4f4cae3b9cc0556b98d3a4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PrintConfigurationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUSB__ConfigurationDescriptor__TypeDef.html">USB_ConfigurationDescriptor_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is enabled when #define USB_USE_PRINTF and #define USER_PUTCHAR macros are properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to a <a class="el" href="structUSB__ConfigurationDescriptor__TypeDef.html">USB_ConfigurationDescriptor_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxLen</td><td>The size of the data buffer passed as input parameter <em>config</em>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01085">1085</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00439">USB_ConfigurationDescriptor_TypeDef::bConfigurationValue</a>, <a class="el" href="em__usb_8h_source.html#l00431">USB_ConfigurationDescriptor_TypeDef::bDescriptorType</a>, <a class="el" href="em__usb_8h_source.html#l00430">USB_ConfigurationDescriptor_TypeDef::bLength</a>, <a class="el" href="em__usb_8h_source.html#l00444">USB_ConfigurationDescriptor_TypeDef::bmAttributes</a>, <a class="el" href="em__usb_8h_source.html#l00449">USB_ConfigurationDescriptor_TypeDef::bMaxPower</a>, <a class="el" href="em__usb_8h_source.html#l00437">USB_ConfigurationDescriptor_TypeDef::bNumInterfaces</a>, <a class="el" href="em__common_8h_source.html#l00079">EFM32_MIN</a>, <a class="el" href="em__usb_8h_source.html#l00442">USB_ConfigurationDescriptor_TypeDef::iConfiguration</a>, <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb">USB_PRINTF()</a>, <a class="el" href="group__USB__COMMON.html#gac49ccf1d69a08567d1a5911b0312e735">USB_PUTCHAR()</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usb_8h_source.html#l00432">USB_ConfigurationDescriptor_TypeDef::wTotalLength</a>.</p>

</div>
</div>
<a class="anchor" id="ga465475632c744fb3fae7a73e09606fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PrintDeviceDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUSB__DeviceDescriptor__TypeDef.html">USB_DeviceDescriptor_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is enabled when #define USB_USE_PRINTF and #define USER_PUTCHAR macros are properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSB__DeviceDescriptor__TypeDef.html">USB_DeviceDescriptor_TypeDef</a> data structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01142">1142</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00416">USB_DeviceDescriptor_TypeDef::bcdDevice</a>, <a class="el" href="em__usb_8h_source.html#l00408">USB_DeviceDescriptor_TypeDef::bcdUSB</a>, <a class="el" href="em__usb_8h_source.html#l00407">USB_DeviceDescriptor_TypeDef::bDescriptorType</a>, <a class="el" href="em__usb_8h_source.html#l00410">USB_DeviceDescriptor_TypeDef::bDeviceClass</a>, <a class="el" href="em__usb_8h_source.html#l00412">USB_DeviceDescriptor_TypeDef::bDeviceProtocol</a>, <a class="el" href="em__usb_8h_source.html#l00411">USB_DeviceDescriptor_TypeDef::bDeviceSubClass</a>, <a class="el" href="em__usb_8h_source.html#l00406">USB_DeviceDescriptor_TypeDef::bLength</a>, <a class="el" href="em__usb_8h_source.html#l00413">USB_DeviceDescriptor_TypeDef::bMaxPacketSize0</a>, <a class="el" href="em__usb_8h_source.html#l00421">USB_DeviceDescriptor_TypeDef::bNumConfigurations</a>, <a class="el" href="em__usb_8h_source.html#l00415">USB_DeviceDescriptor_TypeDef::idProduct</a>, <a class="el" href="em__usb_8h_source.html#l00414">USB_DeviceDescriptor_TypeDef::idVendor</a>, <a class="el" href="em__usb_8h_source.html#l00417">USB_DeviceDescriptor_TypeDef::iManufacturer</a>, <a class="el" href="em__usb_8h_source.html#l00418">USB_DeviceDescriptor_TypeDef::iProduct</a>, <a class="el" href="em__usb_8h_source.html#l00419">USB_DeviceDescriptor_TypeDef::iSerialNumber</a>, <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb">USB_PRINTF()</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, and <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="gabe253e3e072d805774b8714aacf9182c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PrintEndpointDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUSB__EndpointDescriptor__TypeDef.html">USB_EndpointDescriptor_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is enabled when #define USB_USE_PRINTF and #define USER_PUTCHAR macros are properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>Pointer to a <a class="el" href="structUSB__EndpointDescriptor__TypeDef.html">USB_EndpointDescriptor_TypeDef</a> data structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01184">1184</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00501">USB_EndpointDescriptor_TypeDef::bDescriptorType</a>, <a class="el" href="em__usb_8h_source.html#l00502">USB_EndpointDescriptor_TypeDef::bEndpointAddress</a>, <a class="el" href="em__usb_8h_source.html#l00505">USB_EndpointDescriptor_TypeDef::bInterval</a>, <a class="el" href="em__usb_8h_source.html#l00500">USB_EndpointDescriptor_TypeDef::bLength</a>, <a class="el" href="em__usb_8h_source.html#l00503">USB_EndpointDescriptor_TypeDef::bmAttributes</a>, <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb">USB_PRINTF()</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usb_8h_source.html#l00504">USB_EndpointDescriptor_TypeDef::wMaxPacketSize</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a4aa696c25dfd0b99a2cda6e02d7a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_PrintInterfaceDescriptor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUSB__InterfaceDescriptor__TypeDef.html">USB_InterfaceDescriptor_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is enabled when #define USB_USE_PRINTF and #define USER_PUTCHAR macros are properly defined when configuring the protocol stack in "usbconfig.h". The function is primarily meant for debugging purposes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">interface</td><td>Pointer to a <a class="el" href="structUSB__InterfaceDescriptor__TypeDef.html">USB_InterfaceDescriptor_TypeDef</a> data structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01219">1219</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00464">USB_InterfaceDescriptor_TypeDef::bAlternateSetting</a>, <a class="el" href="em__usb_8h_source.html#l00460">USB_InterfaceDescriptor_TypeDef::bDescriptorType</a>, <a class="el" href="em__usb_8h_source.html#l00469">USB_InterfaceDescriptor_TypeDef::bInterfaceClass</a>, <a class="el" href="em__usb_8h_source.html#l00461">USB_InterfaceDescriptor_TypeDef::bInterfaceNumber</a>, <a class="el" href="em__usb_8h_source.html#l00480">USB_InterfaceDescriptor_TypeDef::bInterfaceProtocol</a>, <a class="el" href="em__usb_8h_source.html#l00474">USB_InterfaceDescriptor_TypeDef::bInterfaceSubClass</a>, <a class="el" href="em__usb_8h_source.html#l00459">USB_InterfaceDescriptor_TypeDef::bLength</a>, <a class="el" href="em__usb_8h_source.html#l00466">USB_InterfaceDescriptor_TypeDef::bNumEndpoints</a>, <a class="el" href="em__usb_8h_source.html#l00490">USB_InterfaceDescriptor_TypeDef::iInterface</a>, <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb">USB_PRINTF()</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, and <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="gae9ef72709bb00accb740a0350f79fe35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_QueryDeviceB </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>deviceSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is normally used to retrieve the data needed by <a class="el" href="group__USB__HOST.html#ga50dc10ac598c6c8479319ff58c186266">USBH_InitDeviceData()</a>. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer with sufficent space for the descriptors. The data buffer size must be sizeof( <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> ) + the anticipated maximum size of the entire configuration descriptor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufsize</td><td>The size of the data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceSpeed</td><td><a class="el" href="group__USB__COMMON.html#gac483b34de71117d1db0dc1d9c1f896d9">PORT_FULL_SPEED</a> or <a class="el" href="group__USB__COMMON.html#gab35af8fb505263e1e594d07f9e5c8253">PORT_LOW_SPEED</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The device speed can be determined with <a class="el" href="group__USB__HOST.html#gad011363a4aa7f78c702a361bcebe67fb">USBH_GetPortSpeed()</a> for devices directly attached to the USB port. Devices attached via a hub must retrieve this information by querying the hub. </p>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01582">1582</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00413">USB_DeviceDescriptor_TypeDef::bMaxPacketSize0</a>, <a class="el" href="em__usb_8h_source.html#l00892">USBH_Device_TypeDef::confDesc</a>, <a class="el" href="em__usb_8h_source.html#l00891">USBH_Device_TypeDef::devDesc</a>, <a class="el" href="em__common_8h_source.html#l00079">EFM32_MIN</a>, <a class="el" href="em__usb_8h_source.html#l00895">USBH_Device_TypeDef::ep</a>, <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00869">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="em__usb_8h_source.html#l00898">USBH_Device_TypeDef::speed</a>, <a class="el" href="em__usb_8h_source.html#l00145">USB_CONFIG_DESCSIZE</a>, <a class="el" href="em__usb_8h_source.html#l00144">USB_DEVICE_DESCSIZE</a>, <a class="el" href="em__usb_8h_source.html#l00146">USB_INTERFACE_DESCSIZE</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usb_8h_source.html#l00320">USB_STATUS_REQ_ERR</a>, <a class="el" href="em__usbh_8c_source.html#l00647">USBH_GetConfigurationDescriptorB()</a>, <a class="el" href="em__usbh_8c_source.html#l00704">USBH_GetDeviceDescriptorB()</a>, <a class="el" href="em__usbh_8c_source.html#l00905">USBH_InitDeviceData()</a>, and <a class="el" href="em__usb_8h_source.html#l00432">USB_ConfigurationDescriptor_TypeDef::wTotalLength</a>.</p>

<p>Referenced by <a class="el" href="msdh_8c_source.html#l00059">MSDH_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ac91d938f8553e31913afdb8d8d80dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUSB__ConfigurationDescriptor__TypeDef.html">USB_ConfigurationDescriptor_TypeDef</a>* USBH_QGetConfigurationDescriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>configIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function search through <em>buf</em> looking for a given configuration descriptor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configIndex</td><td>Configuration index, a zero based number indicating which configuration descriptor to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to <a class="el" href="structUSB__ConfigurationDescriptor__TypeDef.html">USB_ConfigurationDescriptor_TypeDef</a>. NULL if no descriptor found. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01331">1331</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__common_8h_source.html#l00079">EFM32_MIN</a>, <a class="el" href="em__usb_8h_source.html#l00117">USB_CONFIG_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00145">USB_CONFIG_DESCSIZE</a>, and <a class="el" href="em__usbh_8c_source.html#l01387">USBH_QGetDeviceDescriptor()</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l01506">USBH_QGetInterfaceDescriptor()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d6a8d78ebde4e394bb25aa62a871b30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUSB__DeviceDescriptor__TypeDef.html">USB_DeviceDescriptor_TypeDef</a>* USBH_QGetDeviceDescriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to <a class="el" href="structUSB__DeviceDescriptor__TypeDef.html">USB_DeviceDescriptor_TypeDef</a>. NULL if no descriptor found. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01387">1387</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00407">USB_DeviceDescriptor_TypeDef::bDescriptorType</a>, <a class="el" href="em__usb_8h_source.html#l00406">USB_DeviceDescriptor_TypeDef::bLength</a>, <a class="el" href="em__usb_8h_source.html#l00116">USB_DEVICE_DESCRIPTOR</a>, and <a class="el" href="em__usb_8h_source.html#l00144">USB_DEVICE_DESCSIZE</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l01331">USBH_QGetConfigurationDescriptor()</a>.</p>

</div>
</div>
<a class="anchor" id="ga10e6eb1a2e9802af4ec16254e3d44783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUSB__EndpointDescriptor__TypeDef.html">USB_EndpointDescriptor_TypeDef</a>* USBH_QGetEndpointDescriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>configIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>endpointIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function search through <em>buf</em> looking for a given endpoint descriptor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configIndex</td><td>Configuration index, a zero based number indicating in which configuration descriptor to look for the interface containing the endpoint descriptor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaceIndex</td><td>Interface index, a zero based number indicating the interface descriptor to look for the correct endpoint descriptor in.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endpointIndex</td><td>Endpoint index, a zero based number indicating which endpoint descriptor to look for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to <a class="el" href="structUSB__EndpointDescriptor__TypeDef.html">USB_EndpointDescriptor_TypeDef</a>. NULL if no descriptor found. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01434">1434</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00121">USB_ENDPOINT_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00147">USB_ENDPOINT_DESCSIZE</a>, <a class="el" href="em__usb_8h_source.html#l00146">USB_INTERFACE_DESCSIZE</a>, and <a class="el" href="em__usbh_8c_source.html#l01506">USBH_QGetInterfaceDescriptor()</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l00905">USBH_InitDeviceData()</a>.</p>

</div>
</div>
<a class="anchor" id="gabd04b4b1ea26459d6db42aa77b6d592d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUSB__InterfaceDescriptor__TypeDef.html">USB_InterfaceDescriptor_TypeDef</a>* USBH_QGetInterfaceDescriptor </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>configIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interfaceIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function search through <em>buf</em> looking for a given interface descriptor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer containing enumeration data retrieved with <a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a>.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configIndex</td><td>Configuration index, a zero based number indicating in which configuration descriptor to look for the interface descriptor.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaceIndex</td><td>Interface index, a zero based number indicating which interface descriptor to find.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to <a class="el" href="structUSB__InterfaceDescriptor__TypeDef.html">USB_InterfaceDescriptor_TypeDef</a>. NULL if no descriptor found. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01506">1506</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00145">USB_CONFIG_DESCSIZE</a>, <a class="el" href="em__usb_8h_source.html#l00120">USB_INTERFACE_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00146">USB_INTERFACE_DESCSIZE</a>, and <a class="el" href="em__usbh_8c_source.html#l01331">USBH_QGetConfigurationDescriptor()</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l00905">USBH_InitDeviceData()</a>, and <a class="el" href="em__usbh_8c_source.html#l01434">USBH_QGetEndpointDescriptor()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3514adea6bc6da41b8a083153e3f9365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is non-blocking and returns immediately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteCount</td><td>Number of bytes to transfer (zero is a valid value).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to be called on transfer completion. Supply NULL if no callback is needed. See <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01672">1672</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00505">USB_EndpointDescriptor_TypeDef::bInterval</a>, <a class="el" href="em__usb_8h_source.html#l00876">USBH_Ep_TypeDef::buf</a>, <a class="el" href="em__common_8h_source.html#l00079">EFM32_MIN</a>, <a class="el" href="em__usb_8h_source.html#l00866">USBH_Ep_TypeDef::epDesc</a>, <a class="el" href="em__usb_8h_source.html#l00852">H_EP_DATA_IN</a>, <a class="el" href="em__usb_8h_source.html#l00850">H_EP_IDLE</a>, <a class="el" href="em__usb_8h_source.html#l00871">USBH_Ep_TypeDef::hcIn</a>, <a class="el" href="em__usb_8h_source.html#l00872">USBH_Ep_TypeDef::in</a>, <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00869">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="em__usb_8h_source.html#l00881">USBH_Ep_TypeDef::remaining</a>, <a class="el" href="em__usb_8h_source.html#l00874">USBH_Ep_TypeDef::state</a>, <a class="el" href="em__usb_8h_source.html#l00882">USBH_Ep_TypeDef::timeout</a>, <a class="el" href="em__usb_8h_source.html#l00868">USBH_Ep_TypeDef::type</a>, <a class="el" href="em__usb_8h_source.html#l00172">USB_EPTYPE_INTR</a>, <a class="el" href="em__usb_8h_source.html#l00321">USB_STATUS_EP_BUSY</a>, <a class="el" href="em__usb_8h_source.html#l00333">USB_STATUS_HC_BUSY</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usbh_8c_source.html#l00612">USBH_DeviceConnected()</a>, <a class="el" href="em__usbtimer_8c_source.html#l00234">USBTIMER_Start()</a>, <a class="el" href="em__usb_8h_source.html#l00879">USBH_Ep_TypeDef::xferCompleteCb</a>, <a class="el" href="em__usb_8h_source.html#l00877">USBH_Ep_TypeDef::xferCompleted</a>, and <a class="el" href="em__usb_8h_source.html#l00880">USBH_Ep_TypeDef::xferred</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l01794">USBH_ReadB()</a>.</p>

</div>
</div>
<a class="anchor" id="gab5829c1ebeed8cfd36317dd57c6584c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_ReadB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size. <br />
 This function is blocking and will not return before the transfer has completed, timed out or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteCount</td><td>Number of bytes to transfer (zero is a valid value).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01794">1794</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usbh_8c_source.html#l01672">USBH_Read()</a>, <a class="el" href="em__usb_8h_source.html#l00877">USBH_Ep_TypeDef::xferCompleted</a>, <a class="el" href="em__usb_8h_source.html#l00880">USBH_Ep_TypeDef::xferred</a>, and <a class="el" href="em__usb_8h_source.html#l00878">USBH_Ep_TypeDef::xferStatus</a>.</p>

<p>Referenced by <a class="el" href="msdbot_8c_source.html#l00098">MSDBOT_Xfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gac93ecf15f240abf7093506c8e8ef9e61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_SetAddressB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>deviceAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The device must currently have address 0. This command will move the device to the addressed state. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceAddress</td><td>The new device address. Provide a value between 0 and 127.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01841">1841</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00897">USBH_Device_TypeDef::addr</a>, <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00082">SET_ADDRESS</a>, <a class="el" href="em__usb_8h_source.html#l00181">USB_MAX_DEVICE_ADDRESS</a>, <a class="el" href="em__usb_8h_source.html#l00062">USB_SETUP_DIR_H2D</a>, <a class="el" href="em__usb_8h_source.html#l00073">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="em__usb_8h_source.html#l00068">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usbh_8c_source.html#l00367">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0f156ce4b8660203cf4957c019064d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_SetAltInterfaceB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>interfaceIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>alternateSetting</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd><br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interfaceIndex</td><td>The interface index. A zero based value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternateSetting</td><td>The alternate interface setting value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01897">1897</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00895">USBH_Device_TypeDef::ep</a>, <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00896">USBH_Device_TypeDef::numEp</a>, <a class="el" href="em__usb_8h_source.html#l00088">SET_INTERFACE</a>, <a class="el" href="em__usb_8h_source.html#l00873">USBH_Ep_TypeDef::toggle</a>, <a class="el" href="em__usb_8h_source.html#l00062">USB_SETUP_DIR_H2D</a>, <a class="el" href="em__usb_8h_source.html#l00074">USB_SETUP_RECIPIENT_INTERFACE</a>, <a class="el" href="em__usb_8h_source.html#l00068">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usbh_8c_source.html#l00367">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6938e5856e9d28116922070621be36a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_SetConfigurationB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>configValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This command will move the device to the configured state. <br />
 This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>Pointer to a <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">configValue</td><td>The configuration value. The value can be retrieved from device-&gt;confDesc.bConfigurationValue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l01956">1956</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00895">USBH_Device_TypeDef::ep</a>, <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00896">USBH_Device_TypeDef::numEp</a>, <a class="el" href="em__usb_8h_source.html#l00086">SET_CONFIGURATION</a>, <a class="el" href="em__usb_8h_source.html#l00873">USBH_Ep_TypeDef::toggle</a>, <a class="el" href="em__usb_8h_source.html#l00062">USB_SETUP_DIR_H2D</a>, <a class="el" href="em__usb_8h_source.html#l00073">USB_SETUP_RECIPIENT_DEVICE</a>, <a class="el" href="em__usb_8h_source.html#l00068">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usbh_8c_source.html#l00367">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga547d9df531d791c90fd6f44d28e7089a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_StallEpB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02009">2009</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00875">USBH_Ep_TypeDef::addr</a>, <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00867">USBH_Ep_TypeDef::parentDevice</a>, <a class="el" href="em__usb_8h_source.html#l00081">SET_FEATURE</a>, <a class="el" href="em__usb_8h_source.html#l00191">USB_FEATURE_ENDPOINT_HALT</a>, <a class="el" href="em__usb_8h_source.html#l00062">USB_SETUP_DIR_H2D</a>, <a class="el" href="em__usb_8h_source.html#l00075">USB_SETUP_RECIPIENT_ENDPOINT</a>, <a class="el" href="em__usb_8h_source.html#l00068">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, and <a class="el" href="em__usbh_8c_source.html#l00367">USBH_ControlMsgB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga154c6b268f2d39d4e1577f917e0da239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBH_Stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USB host operation is terminated and VBUS on the port is turned off. </p>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02036">2036</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="efm32lg995f256_8h_source.html#l00384">CMU</a>, <a class="el" href="efm32lg__cmu_8h_source.html#l00830">CMU_HFCORECLKEN0_USB</a>, <a class="el" href="efm32lg__cmu_8h_source.html#l00825">CMU_HFCORECLKEN0_USBC</a>, <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, and <a class="el" href="em__usbtimer_8c_source.html#l00302">USBTIMER_Stop()</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l02146">USBH_WaitForDeviceConnectionB()</a>.</p>

</div>
</div>
<a class="anchor" id="gabf8fcc4a69080f3d1005d1bc21d44218"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_UnStallEpB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function is blocking and will not return before the transfer has completed, timed out (1 second) or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02068">2068</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00875">USBH_Ep_TypeDef::addr</a>, <a class="el" href="em__usb_8h_source.html#l00080">CLEAR_FEATURE</a>, <a class="el" href="em__usb_8h_source.html#l00894">USBH_Device_TypeDef::ep0</a>, <a class="el" href="em__usb_8h_source.html#l00867">USBH_Ep_TypeDef::parentDevice</a>, <a class="el" href="em__usb_8h_source.html#l00873">USBH_Ep_TypeDef::toggle</a>, <a class="el" href="em__usb_8h_source.html#l00191">USB_FEATURE_ENDPOINT_HALT</a>, <a class="el" href="em__usb_8h_source.html#l00062">USB_SETUP_DIR_H2D</a>, <a class="el" href="em__usb_8h_source.html#l00075">USB_SETUP_RECIPIENT_ENDPOINT</a>, <a class="el" href="em__usb_8h_source.html#l00068">USB_SETUP_TYPE_STANDARD_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, and <a class="el" href="em__usbh_8c_source.html#l00367">USBH_ControlMsgB()</a>.</p>

<p>Referenced by <a class="el" href="msdbot_8c_source.html#l00098">MSDBOT_Xfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga62f99f2ed786c98d00935fc2fd140aaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_WaitForDeviceConnectionB </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeoutInSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will wait for device connection and try to read the 8 first bytes of the device descriptor. <br />
 First the USB peripheral is initializet (reset) and VBUS is turned on. When a device is connected, an USB reset will be signalled on the USB port, and then a USB GetDescriptor command is performed. <br />
 This procedure is repeated until success or timeout. On each iteration the duration of USB reset signalling is varied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A data buffer with sufficent space for retrieving the first 8 bytes of a device descriptor. The data buffer size must be sizeof( <a class="el" href="structUSBH__Device__TypeDef.html">USBH_Device_TypeDef</a> ) + 8.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutInSeconds</td><td>Timeout in seconds. A value of 0 means infinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a69c65b08dff316759c941351aa70a905">USB_STATUS_TIMEOUT</a> on timeout, <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1aa9c73dd98ee624ee7d4b8f7c2ec7206b">USB_STATUS_DEVICE_MALFUNCTION</a> if a device was attached but USB communications could not be succesfully established with the device, or <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1aa84fb30ea08f226b475c1bb137483023">USB_STATUS_PORT_OVERCURRENT</a> if a VBUS overcurrent condition exist. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02146">2146</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="efm32lg995f256_8h_source.html#l00384">CMU</a>, <a class="el" href="efm32lg__cmu_8h_source.html#l00830">CMU_HFCORECLKEN0_USB</a>, <a class="el" href="efm32lg__cmu_8h_source.html#l00825">CMU_HFCORECLKEN0_USBC</a>, <a class="el" href="em__usb_8h_source.html#l00891">USBH_Device_TypeDef::devDesc</a>, <a class="el" href="em__gpio_8h_source.html#l00675">GPIO_PinInGet()</a>, <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00334">USB_STATUS_DEVICE_MALFUNCTION</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usb_8h_source.html#l00335">USB_STATUS_PORT_OVERCURRENT</a>, <a class="el" href="em__usb_8h_source.html#l00331">USB_STATUS_TIMEOUT</a>, <a class="el" href="em__usbh_8c_source.html#l00612">USBH_DeviceConnected()</a>, <a class="el" href="em__usbh_8c_source.html#l00704">USBH_GetDeviceDescriptorB()</a>, <a class="el" href="em__usbh_8c_source.html#l00741">USBH_GetPortSpeed()</a>, <a class="el" href="em__usbh_8c_source.html#l00905">USBH_InitDeviceData()</a>, <a class="el" href="em__usbh_8c_source.html#l02036">USBH_Stop()</a>, <a class="el" href="em__usbtimer_8c_source.html#l00135">USBTIMER_DelayMs()</a>, and <a class="el" href="em__usbtimer_8c_source.html#l00302">USBTIMER_Stop()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c9fcc6a9f2db01206c010330b6e41f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. <br />
 This function is non-blocking and returns immediately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteCount</td><td>Number of bytes to transfer (zero is a valid value).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Function to be called on transfer completion. Supply NULL if no callback is needed. See <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977">USB_XferCompleteCb_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02297">2297</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00505">USB_EndpointDescriptor_TypeDef::bInterval</a>, <a class="el" href="em__usb_8h_source.html#l00876">USBH_Ep_TypeDef::buf</a>, <a class="el" href="em__common_8h_source.html#l00079">EFM32_MIN</a>, <a class="el" href="em__usb_8h_source.html#l00866">USBH_Ep_TypeDef::epDesc</a>, <a class="el" href="em__usb_8h_source.html#l00853">H_EP_DATA_OUT</a>, <a class="el" href="em__usb_8h_source.html#l00850">H_EP_IDLE</a>, <a class="el" href="em__usb_8h_source.html#l00870">USBH_Ep_TypeDef::hcOut</a>, <a class="el" href="em__usb_8h_source.html#l00872">USBH_Ep_TypeDef::in</a>, <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00869">USBH_Ep_TypeDef::packetSize</a>, <a class="el" href="em__usb_8h_source.html#l00881">USBH_Ep_TypeDef::remaining</a>, <a class="el" href="em__usb_8h_source.html#l00874">USBH_Ep_TypeDef::state</a>, <a class="el" href="em__usb_8h_source.html#l00882">USBH_Ep_TypeDef::timeout</a>, <a class="el" href="em__usb_8h_source.html#l00868">USBH_Ep_TypeDef::type</a>, <a class="el" href="em__usb_8h_source.html#l00172">USB_EPTYPE_INTR</a>, <a class="el" href="em__usb_8h_source.html#l00321">USB_STATUS_EP_BUSY</a>, <a class="el" href="em__usb_8h_source.html#l00333">USB_STATUS_HC_BUSY</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usbh_8c_source.html#l00612">USBH_DeviceConnected()</a>, <a class="el" href="em__usbtimer_8c_source.html#l00234">USBTIMER_Start()</a>, <a class="el" href="em__usb_8h_source.html#l00879">USBH_Ep_TypeDef::xferCompleteCb</a>, <a class="el" href="em__usb_8h_source.html#l00877">USBH_Ep_TypeDef::xferCompleted</a>, and <a class="el" href="em__usb_8h_source.html#l00880">USBH_Ep_TypeDef::xferred</a>.</p>

<p>Referenced by <a class="el" href="em__usbh_8c_source.html#l02417">USBH_WriteB()</a>.</p>

</div>
</div>
<a class="anchor" id="ga27c7b3b7944f7f1b8e4327dd66fa7ff8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBH_WriteB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. <br />
 This function is blocking and will not return before the transfer has completed, timed out or failed.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Pointer to a <a class="el" href="structUSBH__Ep__TypeDef.html">USBH_Ep_TypeDef</a> data structure.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byteCount</td><td>Number of bytes to transfer (zero is a valid value).</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Transfer timeout in milliseconds. The transfer will be terminated if not completed within <em>timeout</em> milliseconds. A value of 0 means infinite.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive (or zero) value indicates number of bytes transferred. <br />
 A negative value indicates a transfer error code enumerated in <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbh_8c_source.html#l02417">2417</a> of file <a class="el" href="em__usbh_8c_source.html">em_usbh.c</a>.</p>

<p>References <a class="el" href="em__int_8h_source.html#l00071">INT_Disable()</a>, <a class="el" href="em__int_8h_source.html#l00094">INT_Enable()</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usbh_8c_source.html#l02297">USBH_Write()</a>, <a class="el" href="em__usb_8h_source.html#l00877">USBH_Ep_TypeDef::xferCompleted</a>, <a class="el" href="em__usb_8h_source.html#l00880">USBH_Ep_TypeDef::xferred</a>, and <a class="el" href="em__usb_8h_source.html#l00878">USBH_Ep_TypeDef::xferStatus</a>.</p>

<p>Referenced by <a class="el" href="msdbot_8c_source.html#l00098">MSDBOT_Xfer()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Dec 8 2015 15:37:37 for EFM32 Leopard Gecko Software Documentation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
