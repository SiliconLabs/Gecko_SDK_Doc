<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Board Support Package: common/drivers/msdd.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_c5ab7d5005c5f96afef39cd6ff9e2484.html">common</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_640347b79a58de25a4e6f9b018e8e1be.html">drivers</a>
  </div>
</div>
<div class="contents">
<h1>msdd.c</h1><a href="msdd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**************************************************************************/</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;em_usb.h&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;em_cmu.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;em_gpio.h&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;<a class="code" href="msdbot_8h.html" title="Definitions for the Bulk Only Transport protocol of USB Mass Storage devices.">msdbot.h</a>&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;<a class="code" href="msdscsi_8h.html" title="SCSI interface for Mass Storage Devices (MSD).">msdscsi.h</a>&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;<a class="code" href="msdd_8h.html" title="Mass Storage class Device (MSD) driver.">msdd.h</a>&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;msddmedia.h&quot;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="comment">/**************************************************************************/</span>
<a name="l00058"></a>00058 <span class="comment">/*** Typedef&#39;s and defines. ***/</span>
<a name="l00059"></a>00059 <span class="preprocessor">#define MSD_DIR_DATA_OUT    0</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#define MSD_DIR_DATA_IN     1</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define MSD_MAX_BURST       32768U          </span><span class="comment">/* 32 * 1024 */</span>
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 <span class="comment">/**************************************************************************/</span>
<a name="l00066"></a>00066 <span class="keyword">typedef</span> <span class="keyword">enum</span>
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068   MSDD_IDLE                 = 0,
<a name="l00069"></a>00069   MSDD_WAITFOR_CBW          = 1,
<a name="l00070"></a>00070   MSDD_WAITFOR_RECOVERY     = 2,
<a name="l00071"></a>00071   MSDD_SEND_CSW             = 3,
<a name="l00072"></a>00072   MSDD_WAIT_FOR_INUNSTALLED = 4,
<a name="l00073"></a>00073   MSDD_STALL_IN             = 5,
<a name="l00074"></a>00074   MSDD_ACCESS_INDIRECT      = 6,
<a name="l00075"></a>00075   MSDD_WRITE_INDIRECT       = 7,
<a name="l00076"></a>00076   MSDD_DO_CMD_TASK          = 8,
<a name="l00077"></a>00077 } msdState_TypeDef;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">/*** Function prototypes. ***/</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="keyword">static</span> <span class="keywordtype">int</span>            CbwCallback(USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining);
<a name="l00082"></a>00082 __STATIC_INLINE <span class="keywordtype">bool</span>  CswMeaningful(<span class="keywordtype">void</span>);
<a name="l00083"></a>00083 __STATIC_INLINE <span class="keywordtype">bool</span>  CswValid(<span class="keywordtype">void</span>);
<a name="l00084"></a>00084 __STATIC_INLINE <span class="keywordtype">void</span>  EnableNextCbw(<span class="keywordtype">void</span>);
<a name="l00085"></a>00085 <span class="keyword">static</span> <span class="keywordtype">void</span>           ProcessScsiCdb(<span class="keywordtype">void</span>);
<a name="l00086"></a>00086 __STATIC_INLINE <span class="keywordtype">void</span>  SendCsw(<span class="keywordtype">void</span>);
<a name="l00087"></a>00087 <span class="keyword">static</span> <span class="keywordtype">void</span>           UsbXferBotData(uint8_t *data, uint32_t len, USB_XferCompleteCb_TypeDef cb);
<a name="l00088"></a>00088 <span class="keyword">static</span> <span class="keywordtype">void</span>           XferBotData(uint32_t length);
<a name="l00089"></a>00089 <span class="keyword">static</span> <span class="keywordtype">int</span>            XferBotDataCallback(USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining);
<a name="l00090"></a>00090 <span class="keyword">static</span> <span class="keywordtype">int</span>            XferBotDataIndirectCallback(USB_Status_TypeDef status, uint32_t xferred, uint32_t remaining);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="comment">/*** Variables ***/</span>
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="comment">/* Storage for one CBW */</span>
<a name="l00095"></a>00095 STATIC_UBUF(cbw, USB_FS_BULK_EP_MAXSIZE);
<a name="l00096"></a>00096 <span class="keyword">static</span> <a class="code" href="structMSDBOT__CBW__TypeDef.html" title="Bulk Only Transport (BOT) Command Block Wrapper (CBW) typedef.">MSDBOT_CBW_TypeDef</a> *pCbw = (<a class="code" href="structMSDBOT__CBW__TypeDef.html" title="Bulk Only Transport (BOT) Command Block Wrapper (CBW) typedef.">MSDBOT_CBW_TypeDef</a>*) &amp;cbw;
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 EFM32_ALIGN(4)
<a name="l00099"></a>00099 <span class="comment">/* Storage for one CSW */</span>
<a name="l00100"></a>00100 static <a class="code" href="structMSDBOT__CSW__TypeDef.html" title="Bulk Only Transport (BOT) Command Status Wrapper (CSW) typedef.">MSDBOT_CSW_TypeDef</a> csw __attribute__ ((aligned(4)));
<a name="l00101"></a>00101 static <a class="code" href="structMSDBOT__CSW__TypeDef.html" title="Bulk Only Transport (BOT) Command Status Wrapper (CSW) typedef.">MSDBOT_CSW_TypeDef</a> *pCsw = &amp;csw;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 STATIC_UBUF(mediaBuffer, <a class="code" href="group__Msd.html#gae1bda16775ab83b9f08d2196aef40898" title="Intermediate media storage buffer size.">MEDIA_BUFSIZ</a>);  <span class="comment">/* Intermediate media storage buffer */</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 static <a class="code" href="structMSDD__CmdStatus__TypeDef.html" title="Status info for one BOT CBW -&amp;gt; Data I/O -&amp;gt; CSW cycle.">MSDD_CmdStatus_TypeDef</a> CmdStatus;
<a name="l00106"></a>00106 static <a class="code" href="structMSDD__CmdStatus__TypeDef.html" title="Status info for one BOT CBW -&amp;gt; Data I/O -&amp;gt; CSW cycle.">MSDD_CmdStatus_TypeDef</a> *pCmdStatus = &amp;CmdStatus;
<a name="l00107"></a>00107 static msdState_TypeDef       savedState; <span class="comment">/* MSD state machine state. */</span>
<a name="l00108"></a>00108 static <span class="keywordtype">int</span> ledPort;
<a name="l00109"></a>00109 static <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ledPin;
<a name="l00110"></a>00110 static <span class="keywordtype">bool</span> turResponse = true;         <span class="comment">// Response on TEST UNIT READY command.</span>
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">/**************************************************************************/</span>
<a name="l00115"></a>00115 EFM32_ALIGN(4)
<a name="l00116"></a>00116 static const <a class="code" href="structMSDSCSI__InquiryData__TypeDef.html" title="SCSI Inquiry response data typedef.">MSDSCSI_InquiryData_TypeDef</a> InquiryData __attribute__ ((aligned(4))) =
<a name="l00117"></a>00117 {
<a name="l00118"></a>00118   { .PeripheralDeviceType = 0, .PeripheralQualifier = 0 }, <span class="comment">/* Block device  */</span>
<a name="l00119"></a>00119   { .Reserved1            = 0, .Removable           = 1 },
<a name="l00120"></a>00120 
<a name="l00121"></a>00121   .Version = 5,                                       <span class="comment">/* T10 SPC-3 compliant */</span>
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   { .ResponseDataFormat = 2,                          <span class="comment">/* T10 SPC-3 compliant reponse data */</span>
<a name="l00124"></a>00124     .HiSup = 0, .NormACA = 0, .Obsolete1 = 0 },
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   .AdditionalLength = 31,
<a name="l00127"></a>00127 
<a name="l00128"></a>00128   { .Protect = 0, .Reserved2 = 0, .ThirdPartyCode = 0,
<a name="l00129"></a>00129     .Tpgs    = 0, .Acc       = 0, .Sccs           = 0 },
<a name="l00130"></a>00130 
<a name="l00131"></a>00131   { .Addr16 = 0, .Obsolete2 = 0, .MChngr = 0, .MultiP = 0,
<a name="l00132"></a>00132     .Vs1    = 0, .EncServ   = 0, .BQue   = 0 },
<a name="l00133"></a>00133 
<a name="l00134"></a>00134   { .Vs2  = 0, .CmdQue = 0, .Obsolete3 = 0, .Linked = 0,
<a name="l00135"></a>00135     .Sync = 0, .Wbus16 = 0, .Obsolete4 = 0 },
<a name="l00136"></a>00136 
<a name="l00137"></a>00137   .T10VendorId          = { <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39; &#39;</span> },
<a name="l00138"></a>00138   .ProductId            = { <span class="charliteral">&#39;E&#39;</span>, <span class="charliteral">&#39;F&#39;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="charliteral">&#39;3&#39;</span>, <span class="charliteral">&#39;2&#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39;M&#39;</span>, <span class="charliteral">&#39;S&#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39; &#39;</span>, <span class="charliteral">&#39;D&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, <span class="charliteral">&#39;v&#39;</span>, <span class="charliteral">&#39;i&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;e&#39;</span> },
<a name="l00139"></a>00139   .ProductRevisionLevel ={ <span class="charliteral">&#39;1&#39;</span>, <span class="charliteral">&#39;.&#39;</span>, <span class="charliteral">&#39;0&#39;</span>, <span class="charliteral">&#39;0&#39;</span> }
<a name="l00140"></a>00140 };
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="comment">/**************************************************************************/</span>
<a name="l00147"></a>00147 EFM32_ALIGN(4)
<a name="l00148"></a>00148 static const <a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a> NoSenseData __attribute__ ((aligned(4))) =
<a name="l00149"></a>00149 {
<a name="l00150"></a>00150   { .ResponseCode = 0x70, .Valid = 0 },
<a name="l00151"></a>00151   .Obsolete = 0,
<a name="l00152"></a>00152   { .SenseKey = 0, .Reserved =0, .Ili = 0, .Eom = 0, .FileMark = 0 },
<a name="l00153"></a>00153   .Information      = 0,
<a name="l00154"></a>00154   .AdditionalLength = 10,
<a name="l00155"></a>00155   .CmdSpecificInfo  = 0,
<a name="l00156"></a>00156   .Asc              = 0,
<a name="l00157"></a>00157   .Ascq             = 0,
<a name="l00158"></a>00158   .Fruc             = 0,
<a name="l00159"></a>00159   { .SenseKeySpecific1 = 0, .Sksv = 0 },
<a name="l00160"></a>00160   .SenseKeySpecific2 = 0,
<a name="l00161"></a>00161   .SenseKeySpecific3 = 0
<a name="l00162"></a>00162 };
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 <span class="comment">/**************************************************************************/</span>
<a name="l00170"></a>00170 EFM32_ALIGN(4)
<a name="l00171"></a>00171 static const <a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a> IllegalSenseData __attribute__ ((aligned(4))) =
<a name="l00172"></a>00172 {
<a name="l00173"></a>00173   { .ResponseCode = 0x70, .Valid = 0 },
<a name="l00174"></a>00174   .Obsolete = 0,
<a name="l00175"></a>00175   { .SenseKey = 5,                          <span class="comment">/* SensKey = 5 =&gt; ILLEGAL REQUEST */</span>
<a name="l00176"></a>00176     .Reserved = 0, .Ili = 0, .Eom = 0, .FileMark = 0 },
<a name="l00177"></a>00177   .Information      = 0,
<a name="l00178"></a>00178   .AdditionalLength = 10,
<a name="l00179"></a>00179   .CmdSpecificInfo  = 0,
<a name="l00180"></a>00180   .Asc              = 0x24,    <span class="comment">/* Asc/Ascq = 0x24/0x00 =&gt; INVALID FIELD IN CDB*/</span>
<a name="l00181"></a>00181   .Ascq             = 0,
<a name="l00182"></a>00182   .Fruc             = 0,
<a name="l00183"></a>00183   { .SenseKeySpecific1 = 0, .Sksv  = 0 },
<a name="l00184"></a>00184   .SenseKeySpecific2 = 0,
<a name="l00185"></a>00185   .SenseKeySpecific3 = 0
<a name="l00186"></a>00186 };
<a name="l00187"></a>00187 
<a name="l00188"></a>00188 <span class="keyword">static</span> <span class="keyword">volatile</span> msdState_TypeDef        msdState;     
<a name="l00189"></a>00189 <span class="keyword">static</span> <a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a> *pSenseData;  
<a name="l00193"></a>00193 <span class="comment">/**************************************************************************/</span>
<a name="l00203"></a><a class="code" href="group__Msd.html#ga6bab19f6afa0c63c3c735c9bea3b8242">00203</a> <span class="keywordtype">void</span> <a class="code" href="group__Msd.html#ga6bab19f6afa0c63c3c735c9bea3b8242" title="Initialize MSD device.">MSDD_Init</a>(<span class="keywordtype">int</span> activityLedPort, uint32_t activityLedPin)
<a name="l00204"></a>00204 {
<a name="l00205"></a>00205   <span class="keywordflow">if</span> ( ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__Read10__TypeDef.html" title="SCSI Read 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Read10_TypeDef</a>)           != <a class="code" href="group__Msd.html#gaeeee5bff632d8292bdf27234a2db1610" title="SCSI Read (10) CBD length.">SCSI_READ10_LEN</a>           ) ||
<a name="l00206"></a>00206        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__Write10__TypeDef.html" title="SCSI Write 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Write10_TypeDef</a>)          != <a class="code" href="group__Msd.html#ga412dd9e12c21fbd38201d7b8fb4ac25f" title="SCSI Write (10) CDB length.">SCSI_WRITE10_LEN</a>          ) ||
<a name="l00207"></a>00207        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__Verify10__TypeDef.html" title="SCSI Verify 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Verify10_TypeDef</a>)         != <a class="code" href="group__Msd.html#ga334a21e13b25d306613eb4b2b2f46360" title="SCSI Verify (10) CDB length.">SCSI_VERIFY10_LEN</a>         ) ||
<a name="l00208"></a>00208        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html" title="SCSI Request Sense Command Descriptor Block (CDB) typedef.">MSDSCSI_RequestSense_TypeDef</a>)     != <a class="code" href="group__Msd.html#gaabd4aaed3342eaa039c186b217f54340" title="SCSI Request Sense CDB length.">SCSI_REQUESTSENSE_LEN</a>     ) ||
<a name="l00209"></a>00209        ( <span class="keyword">sizeof</span>(InquiryData)                      != <a class="code" href="group__Msd.html#ga59d92155a959caa17dee09196cf59e7c" title="SCSI Inquiry response data length.">SCSI_INQUIRYDATA_LEN</a>      ) ||
<a name="l00210"></a>00210        ( <span class="keyword">sizeof</span>(NoSenseData)                      != <a class="code" href="group__Msd.html#ga5981ba77043dd5be09ef0c563d5acac1" title="SCSI Request Sense response data length.">SCSI_REQUESTSENSEDATA_LEN</a> ) ||
<a name="l00211"></a>00211        ( <span class="keyword">sizeof</span>(IllegalSenseData)                 != <a class="code" href="group__Msd.html#ga5981ba77043dd5be09ef0c563d5acac1" title="SCSI Request Sense response data length.">SCSI_REQUESTSENSEDATA_LEN</a> ) ||
<a name="l00212"></a>00212        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html" title="SCSI Read Capacity Command Descriptor Block (CDB) typedef.">MSDSCSI_ReadCapacity_TypeDef</a>)     != <a class="code" href="group__Msd.html#ga32c98aaaced7b71e7a0271aea8f4d0e4" title="SCSI Read Capacity CDB length.">SCSI_READCAPACITY_LEN</a>     ) ||
<a name="l00213"></a>00213        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__ReadCapacityData__TypeDef.html" title="SCSI Read Capacity response data typedef.">MSDSCSI_ReadCapacityData_TypeDef</a>) != <a class="code" href="group__Msd.html#gab6ed4755185c4e6d8d0de6f8dd021e8c" title="SCSI Read Capacity response data length.">SCSI_READCAPACITYDATA_LEN</a> ) ||
<a name="l00214"></a>00214        ( <span class="keyword">sizeof</span>(<a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html" title="SCSI Start Stop Unit Command Descriptor Block (CDB) typedef.">MSDSCSI_StartStopUnit_TypeDef</a>)    != <a class="code" href="group__Msd.html#ga43e35f8b53e848752b68e1fd4dc51fea" title="SCSI Start Stop Unit CDB length.">SCSI_STARTSTOPUNIT_LEN</a>    )    )
<a name="l00215"></a>00215   {
<a name="l00216"></a>00216     DEBUG_USB_API_PUTS(<span class="stringliteral">&quot;\nMSDD_Init(), typedef size error&quot;</span>);
<a name="l00217"></a>00217     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00218"></a>00218     <span class="keywordflow">return</span>;
<a name="l00219"></a>00219   }
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="keywordflow">if</span> ( ( activityLedPort &gt;= gpioPortA ) &amp;&amp; ( activityLedPort &lt;= gpioPortF ) )
<a name="l00222"></a>00222     ledPort = activityLedPort;
<a name="l00223"></a>00223   <span class="keywordflow">else</span>
<a name="l00224"></a>00224     ledPort = -1;
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   ledPin     = activityLedPin;
<a name="l00227"></a>00227   msdState   = MSDD_IDLE;
<a name="l00228"></a>00228   pSenseData = (<a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a>*) &amp;NoSenseData;
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   <span class="keywordflow">if</span> ( ledPort != -1 )
<a name="l00231"></a>00231   {
<a name="l00232"></a>00232     CMU_ClockEnable(cmuClock_GPIO, <span class="keyword">true</span>);
<a name="l00233"></a>00233     GPIO_PinModeSet((GPIO_Port_TypeDef)ledPort, ledPin, gpioModePushPull, 0);
<a name="l00234"></a>00234   }
<a name="l00235"></a>00235 }
<a name="l00236"></a>00236 
<a name="l00237"></a>00237 <span class="comment">/**************************************************************************/</span>
<a name="l00246"></a><a class="code" href="group__Msd.html#ga0dfd9473471d01231de7541cfd7f5ede">00246</a> <span class="keywordtype">bool</span> <a class="code" href="group__Msd.html#ga0dfd9473471d01231de7541cfd7f5ede" title="Serve the MSD state machine.">MSDD_Handler</a>(<span class="keywordtype">void</span>)
<a name="l00247"></a>00247 {
<a name="l00248"></a>00248   <span class="keyword">static</span> uint32_t len;        <span class="comment">/* Note: len is static ! */</span>
<a name="l00249"></a>00249 
<a name="l00250"></a>00250   <span class="keywordflow">switch</span> (msdState)
<a name="l00251"></a>00251   {
<a name="l00252"></a>00252   <span class="keywordflow">case</span> MSDD_ACCESS_INDIRECT:
<a name="l00253"></a>00253     <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen)
<a name="l00254"></a>00254     {
<a name="l00255"></a>00255       len = EFM32_MIN(pCmdStatus-&gt;xferLen, pCmdStatus-&gt;maxBurst);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257       msdState = MSDD_IDLE;
<a name="l00258"></a>00258       <span class="keywordflow">if</span> (pCmdStatus-&gt;direction)
<a name="l00259"></a>00259       {
<a name="l00260"></a>00260         MSDDMEDIA_Read(pCmdStatus, mediaBuffer, len / 512);
<a name="l00261"></a>00261       }
<a name="l00262"></a>00262       UsbXferBotData(mediaBuffer, len, XferBotDataIndirectCallback);
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264     <span class="keywordflow">else</span>
<a name="l00265"></a>00265     {
<a name="l00266"></a>00266       <span class="comment">/* We are done ! */</span>
<a name="l00267"></a>00267       msdState = savedState;
<a name="l00268"></a>00268 
<a name="l00269"></a>00269       <span class="keywordflow">if</span> (msdState == MSDD_SEND_CSW)
<a name="l00270"></a>00270       {
<a name="l00271"></a>00271         SendCsw();
<a name="l00272"></a>00272         EnableNextCbw();
<a name="l00273"></a>00273         msdState = MSDD_WAITFOR_CBW;
<a name="l00274"></a>00274       }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msdState == MSDD_STALL_IN)
<a name="l00277"></a>00277       {
<a name="l00278"></a>00278         USBD_StallEp(MSD_BULK_IN);
<a name="l00279"></a>00279         msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00280"></a>00280       }
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282     <span class="keywordflow">break</span>;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <span class="keywordflow">case</span> MSDD_WRITE_INDIRECT:
<a name="l00285"></a>00285     MSDDMEDIA_Write(pCmdStatus, mediaBuffer, len / 512);
<a name="l00286"></a>00286     pCmdStatus-&gt;lba += len / 512;
<a name="l00287"></a>00287     msdState         = MSDD_ACCESS_INDIRECT;
<a name="l00288"></a>00288     <span class="keywordflow">break</span>;
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="keywordflow">case</span> MSDD_DO_CMD_TASK:
<a name="l00291"></a>00291     <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>[ 0 ] == <a class="code" href="group__Msd.html#ga732b33c6fded33c1e25db28a34f38315" title="SCSI Start Stop Unit command opcode.">SCSI_STARTSTOP_UNIT</a>)
<a name="l00292"></a>00292     {
<a name="l00293"></a>00293       MSDDMEDIA_Flush();
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295     <span class="comment">/* else if ( .... )  Add more when needed. */</span>
<a name="l00296"></a>00296     SendCsw();
<a name="l00297"></a>00297     EnableNextCbw();
<a name="l00298"></a>00298     msdState = MSDD_WAITFOR_CBW;
<a name="l00299"></a>00299     <span class="keywordflow">break</span>;
<a name="l00300"></a>00300 
<a name="l00301"></a>00301   <span class="keywordflow">default</span>:
<a name="l00302"></a>00302     <span class="keywordflow">break</span>;
<a name="l00303"></a>00303   }
<a name="l00304"></a>00304   <span class="keywordflow">return</span> (msdState == MSDD_WAITFOR_CBW) || (msdState == MSDD_IDLE);
<a name="l00305"></a>00305 }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="comment">/**************************************************************************/</span>
<a name="l00319"></a><a class="code" href="group__Msd.html#gafd14b40b8d009c6341c92a35b5e9ad42">00319</a> <span class="keywordtype">int</span> <a class="code" href="group__Msd.html#gafd14b40b8d009c6341c92a35b5e9ad42" title="Called whenever a USB setup command is received.">MSDD_SetupCmd</a>(<span class="keyword">const</span> USB_Setup_TypeDef *setup)
<a name="l00320"></a>00320 {
<a name="l00321"></a>00321   <span class="keywordtype">int</span> retVal;
<a name="l00322"></a>00322   <span class="keyword">static</span> uint32_t tmp;
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   retVal = USB_STATUS_REQ_UNHANDLED;
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="comment">/* Check if it is MSD class command: &quot;Bulk-Only Mass Storage Reset&quot; */</span>
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <span class="keywordflow">if</span> ( ( setup-&gt;Type      == USB_SETUP_TYPE_CLASS          ) &amp;&amp;
<a name="l00329"></a>00329        ( setup-&gt;Direction == USB_SETUP_DIR_OUT             ) &amp;&amp;
<a name="l00330"></a>00330        ( setup-&gt;Recipient == USB_SETUP_RECIPIENT_INTERFACE ) &amp;&amp;
<a name="l00331"></a>00331        ( setup-&gt;bRequest  == USB_MSD_BOTRESET              ) &amp;&amp;
<a name="l00332"></a>00332        ( setup-&gt;wValue    == 0                             ) &amp;&amp;
<a name="l00333"></a>00333        ( setup-&gt;wIndex    == MSD_INTERFACE_NO              ) &amp;&amp;
<a name="l00334"></a>00334        ( setup-&gt;wLength   == 0                             )    )
<a name="l00335"></a>00335   {
<a name="l00336"></a>00336     <span class="keywordflow">if</span> (msdState == MSDD_WAITFOR_RECOVERY)
<a name="l00337"></a>00337     {
<a name="l00338"></a>00338       msdState = MSDD_IDLE;
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340     retVal = USB_STATUS_OK;
<a name="l00341"></a>00341   }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 
<a name="l00344"></a>00344   <span class="comment">/* Check if it is MSD class command: &quot;Get Max LUN&quot; */</span>
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( setup-&gt;Type      == USB_SETUP_TYPE_CLASS          ) &amp;&amp;
<a name="l00347"></a>00347             ( setup-&gt;Direction == USB_SETUP_DIR_IN              ) &amp;&amp;
<a name="l00348"></a>00348             ( setup-&gt;Recipient == USB_SETUP_RECIPIENT_INTERFACE ) &amp;&amp;
<a name="l00349"></a>00349             ( setup-&gt;bRequest  == USB_MSD_GETMAXLUN             ) &amp;&amp;
<a name="l00350"></a>00350             ( setup-&gt;wValue    == 0                             ) &amp;&amp;
<a name="l00351"></a>00351             ( setup-&gt;wIndex    == MSD_INTERFACE_NO              ) &amp;&amp;
<a name="l00352"></a>00352             ( setup-&gt;wLength   == 1                             )    )
<a name="l00353"></a>00353   {
<a name="l00354"></a>00354     <span class="comment">/* Only one LUN (i.e. no support for multiple LUN&#39;s). Reply &quot;0&quot;. */</span>
<a name="l00355"></a>00355     tmp    = 0;
<a name="l00356"></a>00356     retVal = USBD_Write(0, (<span class="keywordtype">void</span>*) &amp;tmp, 1, NULL);
<a name="l00357"></a>00357   }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="comment">/* Check if it is a standard CLEAR_FEATURE endpoint command */</span>
<a name="l00361"></a>00361 
<a name="l00362"></a>00362   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( setup-&gt;Type      == USB_SETUP_TYPE_STANDARD      ) &amp;&amp;
<a name="l00363"></a>00363             ( setup-&gt;Direction == USB_SETUP_DIR_OUT            ) &amp;&amp;
<a name="l00364"></a>00364             ( setup-&gt;Recipient == USB_SETUP_RECIPIENT_ENDPOINT ) &amp;&amp;
<a name="l00365"></a>00365             ( setup-&gt;bRequest  == CLEAR_FEATURE                ) &amp;&amp;
<a name="l00366"></a>00366             ( setup-&gt;wValue    == USB_FEATURE_ENDPOINT_HALT    ) &amp;&amp;
<a name="l00367"></a>00367             ( setup-&gt;wLength   == 0                            )    )
<a name="l00368"></a>00368   {
<a name="l00369"></a>00369     <span class="keywordflow">if</span> ( ( ( setup-&gt;wIndex &amp; 0xFF) == MSD_BULK_OUT ) ||
<a name="l00370"></a>00370          ( ( setup-&gt;wIndex &amp; 0xFF) == MSD_BULK_IN  )    )
<a name="l00371"></a>00371     {
<a name="l00372"></a>00372       retVal = USB_STATUS_OK;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374       <span class="comment">/* Dont unstall ep&#39;s when waiting for reset recovery */</span>
<a name="l00375"></a>00375       <span class="keywordflow">if</span> (msdState != MSDD_WAITFOR_RECOVERY)
<a name="l00376"></a>00376       {
<a name="l00377"></a>00377         retVal = USBD_UnStallEp(setup-&gt;wIndex &amp; 0xFF);
<a name="l00378"></a>00378 
<a name="l00379"></a>00379         <span class="keywordflow">if</span> ((setup-&gt;wIndex &amp; 0xFF) == MSD_BULK_IN)
<a name="l00380"></a>00380         {
<a name="l00381"></a>00381           <span class="keywordflow">if</span> (msdState == MSDD_WAIT_FOR_INUNSTALLED)
<a name="l00382"></a>00382           {
<a name="l00383"></a>00383             SendCsw();
<a name="l00384"></a>00384             EnableNextCbw();
<a name="l00385"></a>00385             msdState = MSDD_WAITFOR_CBW;
<a name="l00386"></a>00386           }
<a name="l00387"></a>00387         }
<a name="l00388"></a>00388         <span class="keywordflow">else</span>
<a name="l00389"></a>00389         {
<a name="l00390"></a>00390           EnableNextCbw();
<a name="l00391"></a>00391           msdState = MSDD_WAITFOR_CBW;
<a name="l00392"></a>00392         }
<a name="l00393"></a>00393       }
<a name="l00394"></a>00394     }
<a name="l00395"></a>00395   }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397   <span class="keywordflow">return</span> retVal;
<a name="l00398"></a>00398 }
<a name="l00399"></a>00399 
<a name="l00400"></a>00400 <span class="comment">/**************************************************************************/</span>
<a name="l00410"></a><a class="code" href="group__Msd.html#ga8ee87f447439d9642c706b68e9905e4a">00410</a> <span class="keywordtype">void</span> <a class="code" href="group__Msd.html#ga8ee87f447439d9642c706b68e9905e4a" title="Called whenever the USB device has changed its device state.">MSDD_StateChangeEvent</a>( USBD_State_TypeDef oldState,
<a name="l00411"></a>00411                             USBD_State_TypeDef newState )
<a name="l00412"></a>00412 {
<a name="l00413"></a>00413   <span class="keywordflow">if</span> (newState == USBD_STATE_CONFIGURED)
<a name="l00414"></a>00414   {
<a name="l00415"></a>00415     <span class="comment">/* We have been configured, start MSD functionality ! */</span>
<a name="l00416"></a>00416     EnableNextCbw();
<a name="l00417"></a>00417     msdState = MSDD_WAITFOR_CBW;
<a name="l00418"></a>00418     turResponse = <span class="keyword">true</span>;           <span class="comment">// Set TEST UNIT READY response value.</span>
<a name="l00419"></a>00419   }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((oldState == USBD_STATE_CONFIGURED) &amp;&amp;
<a name="l00422"></a>00422            (newState != USBD_STATE_SUSPENDED))
<a name="l00423"></a>00423   {
<a name="l00424"></a>00424     <span class="comment">/* We have been de-configured */</span>
<a name="l00425"></a>00425     msdState = MSDD_IDLE;
<a name="l00426"></a>00426   }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newState == USBD_STATE_SUSPENDED)
<a name="l00429"></a>00429   {
<a name="l00430"></a>00430     <span class="comment">/* We have been suspended.                     */</span>
<a name="l00431"></a>00431     msdState = MSDD_IDLE;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433     <span class="comment">/* Reduce current consumption to below 2.5 mA. */</span>
<a name="l00434"></a>00434   }
<a name="l00435"></a>00435 }
<a name="l00436"></a>00436 
<a name="l00439"></a>00439 <span class="comment">/**************************************************************************/</span>
<a name="l00456"></a>00456 <span class="keyword">static</span> <span class="keywordtype">int</span> CbwCallback(USB_Status_TypeDef status,
<a name="l00457"></a>00457                        uint32_t xferred, uint32_t remaining)
<a name="l00458"></a>00458 {
<a name="l00459"></a>00459   (void) remaining;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="keywordflow">if</span> ( ( msdState == MSDD_WAITFOR_CBW ) &amp;&amp;
<a name="l00462"></a>00462        ( status   == USB_STATUS_OK    ) &amp;&amp;
<a name="l00463"></a>00463        ( xferred  == CBW_LEN          ) &amp;&amp;
<a name="l00464"></a>00464        ( CswValid()                   ) &amp;&amp;
<a name="l00465"></a>00465        ( CswMeaningful()              )    )
<a name="l00466"></a>00466   {
<a name="l00467"></a>00467     <span class="keywordflow">if</span> ( ledPort != -1 )
<a name="l00468"></a>00468       GPIO_PinOutToggle((GPIO_Port_TypeDef)ledPort, ledPin);
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <span class="comment">/* Check the SCSI command descriptor block (CDB) */</span>
<a name="l00471"></a>00471     ProcessScsiCdb();
<a name="l00472"></a>00472 
<a name="l00473"></a>00473     <span class="keywordflow">if</span> (pCmdStatus-&gt;valid)
<a name="l00474"></a>00474       pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_CMDPASSED;
<a name="l00475"></a>00475     <span class="keywordflow">else</span>
<a name="l00476"></a>00476       pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_CMDFAILED;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478     pCsw-&gt;dCSWSignature   = CSW_SIGNATURE;
<a name="l00479"></a>00479     pCsw-&gt;dCSWTag         = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a51e2064e5f20133e5ce96bb3d79be263" title="The CBW tag.">dCBWTag</a>;
<a name="l00480"></a>00480     pCsw-&gt;dCSWDataResidue = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a>;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     <span class="comment">/* Check the &quot;thirteen cases&quot; */</span>
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <span class="keywordflow">if</span> ((pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> != 0) &amp;&amp;
<a name="l00485"></a>00485         (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a> != pCmdStatus-&gt;direction))
<a name="l00486"></a>00486     {
<a name="l00487"></a>00487       <span class="comment">/* Handle cases 8 and 10 */</span>
<a name="l00488"></a>00488       pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490       <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>)
<a name="l00491"></a>00491       {
<a name="l00492"></a>00492         <span class="comment">/* Host expects to receive data, case 8 */</span>
<a name="l00493"></a>00493         USBD_StallEp(MSD_BULK_IN);
<a name="l00494"></a>00494         msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00495"></a>00495       }
<a name="l00496"></a>00496       <span class="keywordflow">else</span>
<a name="l00497"></a>00497       {
<a name="l00498"></a>00498         <span class="comment">/* Host expects to send data, case 10 */</span>
<a name="l00499"></a>00499         USBD_StallEp(MSD_BULK_OUT);
<a name="l00500"></a>00500         SendCsw();
<a name="l00501"></a>00501         msdState = MSDD_IDLE;
<a name="l00502"></a>00502       }
<a name="l00503"></a>00503     }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a> || (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == 0))
<a name="l00506"></a>00506     {
<a name="l00507"></a>00507       <span class="comment">/* SCSI IN commands or commands without data phase */</span>
<a name="l00508"></a>00508       <span class="comment">/* Handle cases 1-7 */</span>
<a name="l00509"></a>00509 
<a name="l00510"></a>00510       <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == 0)
<a name="l00511"></a>00511       {
<a name="l00512"></a>00512         <span class="comment">/* Host expects no data, case 1, 2 or 3 */</span>
<a name="l00513"></a>00513         <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen)
<a name="l00514"></a>00514         {
<a name="l00515"></a>00515           <span class="comment">/* Device has data to transmit, case 2 &amp; 3 */</span>
<a name="l00516"></a>00516           pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00517"></a>00517         }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519         <span class="keywordflow">if</span> ((pCmdStatus-&gt;xferLen == 0) &amp;&amp;
<a name="l00520"></a>00520             (pCmdStatus-&gt;xferType == XFER_INDIRECT))
<a name="l00521"></a>00521         {
<a name="l00522"></a>00522           <span class="comment">/* Commands with no data phase which require timeconsuming  */</span>
<a name="l00523"></a>00523           <span class="comment">/* processing are executed in MSDD_Handler()                */</span>
<a name="l00524"></a>00524           msdState = MSDD_DO_CMD_TASK;
<a name="l00525"></a>00525         }
<a name="l00526"></a>00526         <span class="keywordflow">else</span>
<a name="l00527"></a>00527         {
<a name="l00528"></a>00528           SendCsw();
<a name="l00529"></a>00529           EnableNextCbw();
<a name="l00530"></a>00530           msdState = MSDD_WAITFOR_CBW;
<a name="l00531"></a>00531         }
<a name="l00532"></a>00532       }
<a name="l00533"></a>00533       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == pCmdStatus-&gt;xferLen)
<a name="l00534"></a>00534       {
<a name="l00535"></a>00535         <span class="comment">/* Host and device agree on transferlength, case 6 */</span>
<a name="l00536"></a>00536         <span class="comment">/* Send data to host */</span>
<a name="l00537"></a>00537         msdState = MSDD_SEND_CSW;
<a name="l00538"></a>00538         XferBotData(pCmdStatus-&gt;xferLen);
<a name="l00539"></a>00539       }
<a name="l00540"></a>00540       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> &gt; pCmdStatus-&gt;xferLen)
<a name="l00541"></a>00541       {
<a name="l00542"></a>00542         <span class="comment">/* Host expects more data than device can provide, case 4 and 5 */</span>
<a name="l00543"></a>00543 
<a name="l00544"></a>00544         <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen &gt; 0)
<a name="l00545"></a>00545         {
<a name="l00546"></a>00546           <span class="comment">/* Device has data, case 5 */</span>
<a name="l00547"></a>00547           <span class="comment">/* Send data to host */</span>
<a name="l00548"></a>00548           msdState = MSDD_STALL_IN;
<a name="l00549"></a>00549           XferBotData(pCmdStatus-&gt;xferLen);
<a name="l00550"></a>00550         }
<a name="l00551"></a>00551         <span class="keywordflow">else</span>
<a name="l00552"></a>00552         {
<a name="l00553"></a>00553           <span class="comment">/* Device has no data, case 4 */</span>
<a name="l00554"></a>00554           USBD_StallEp(MSD_BULK_IN);
<a name="l00555"></a>00555           msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00556"></a>00556         }
<a name="l00557"></a>00557       }
<a name="l00558"></a>00558       <span class="keywordflow">else</span>
<a name="l00559"></a>00559       {
<a name="l00560"></a>00560         <span class="comment">/* Host expects less data than device will provide, case 7 */</span>
<a name="l00561"></a>00561         pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00562"></a>00562         <span class="comment">/* Send data to host */</span>
<a name="l00563"></a>00563         msdState = MSDD_SEND_CSW;
<a name="l00564"></a>00564         XferBotData(pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a>);
<a name="l00565"></a>00565       }
<a name="l00566"></a>00566     }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="keywordflow">else</span> <span class="comment">/* Host Direction is OUT and Host transferlength &gt; 0 */</span>
<a name="l00569"></a>00569     {
<a name="l00570"></a>00570       <span class="comment">/* SCSI OUT commands */</span>
<a name="l00571"></a>00571       <span class="comment">/* Handle cases 9, 11, 12 and 13 */</span>
<a name="l00572"></a>00572 
<a name="l00573"></a>00573       <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> == pCmdStatus-&gt;xferLen)
<a name="l00574"></a>00574       {
<a name="l00575"></a>00575         <span class="comment">/* Host and device agree on transferlength, case 12 */</span>
<a name="l00576"></a>00576 
<a name="l00577"></a>00577         <span class="comment">/* Read data from host */</span>
<a name="l00578"></a>00578         msdState = MSDD_SEND_CSW;
<a name="l00579"></a>00579         XferBotData(pCmdStatus-&gt;xferLen);
<a name="l00580"></a>00580       }
<a name="l00581"></a>00581       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a> &gt; pCmdStatus-&gt;xferLen)
<a name="l00582"></a>00582       {
<a name="l00583"></a>00583         <span class="comment">/* Host intend to send more data than device expects, case 9 &amp; 11 */</span>
<a name="l00584"></a>00584         pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_CMDFAILED;
<a name="l00585"></a>00585         USBD_StallEp(MSD_BULK_OUT);
<a name="l00586"></a>00586         SendCsw();
<a name="l00587"></a>00587         msdState = MSDD_IDLE;
<a name="l00588"></a>00588       }
<a name="l00589"></a>00589       <span class="keywordflow">else</span>
<a name="l00590"></a>00590       {
<a name="l00591"></a>00591         <span class="comment">/* Host has less data than device expects to receive, case 13 */</span>
<a name="l00592"></a>00592         pCsw-&gt;bCSWStatus = USB_CLASS_MSD_CSW_PHASEERROR;
<a name="l00593"></a>00593         USBD_StallEp(MSD_BULK_OUT);
<a name="l00594"></a>00594         SendCsw();
<a name="l00595"></a>00595         msdState = MSDD_IDLE;
<a name="l00596"></a>00596       }
<a name="l00597"></a>00597     }
<a name="l00598"></a>00598     <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00599"></a>00599   }
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   <span class="keywordflow">if</span> ((status == USB_STATUS_OK) &amp;&amp;
<a name="l00602"></a>00602       (USBD_GetUsbState() == USBD_STATE_CONFIGURED))
<a name="l00603"></a>00603   {
<a name="l00604"></a>00604     <span class="comment">/* Stall both Ep&#39;s and wait for reset recovery */</span>
<a name="l00605"></a>00605     USBD_StallEp(MSD_BULK_OUT);
<a name="l00606"></a>00606     USBD_StallEp(MSD_BULK_IN);
<a name="l00607"></a>00607     msdState = MSDD_WAITFOR_RECOVERY;
<a name="l00608"></a>00608   }
<a name="l00609"></a>00609 
<a name="l00610"></a>00610   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00611"></a>00611 }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="comment">/**************************************************************************/</span>
<a name="l00618"></a>00618 __STATIC_INLINE <span class="keywordtype">bool</span> CswMeaningful(<span class="keywordtype">void</span>)
<a name="l00619"></a>00619 {
<a name="l00620"></a>00620   <span class="keywordflow">if</span> ( ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a1abbfdf14047d26d30fe8f66eeb1411e" title="Reserved, expect 0.">Reserved1</a> == 0 ) &amp;&amp;
<a name="l00621"></a>00621        ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a75f9c429399372fbe1fb70467210db20" title="Obsolete, expect 0.">Obsolete</a>  == 0 ) &amp;&amp;
<a name="l00622"></a>00622        ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#ad93f3797202c31f12d8dda26326b36be" title="Reserved, expect 0.">Reserved2</a> == 0 ) &amp;&amp;
<a name="l00623"></a>00623        ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#adab4dcae6200ccb3a2a5d0671aba3be5" title="Device Logical Unit Number.">Lun</a>       == 0 ) &amp;&amp;
<a name="l00624"></a>00624        ( pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a764d1ea8ecdae55613ff3ad79a8f3461" title="Reserved, expect 0.">Reserved3</a> == 0 )    )
<a name="l00625"></a>00625   {
<a name="l00626"></a>00626     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00627"></a>00627   }
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00630"></a>00630 }
<a name="l00631"></a>00631 
<a name="l00632"></a>00632 <span class="comment">/**************************************************************************/</span>
<a name="l00637"></a>00637 __STATIC_INLINE <span class="keywordtype">bool</span> CswValid(<span class="keywordtype">void</span>)
<a name="l00638"></a>00638 {
<a name="l00639"></a>00639   <span class="keywordflow">return</span> pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a713e73e9aba992ba6d97837ba39dec8c" title="The CBW signature (ascii USBC).">dCBWSignature</a> == CBW_SIGNATURE ? <span class="keyword">true</span> : <span class="keyword">false</span>; <span class="comment">/* Ascii USBC */</span>
<a name="l00640"></a>00640 }
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 <span class="comment">/**************************************************************************/</span>
<a name="l00646"></a>00646 __STATIC_INLINE <span class="keywordtype">void</span> EnableNextCbw(<span class="keywordtype">void</span>)
<a name="l00647"></a>00647 {
<a name="l00648"></a>00648   USBD_Read(MSD_BULK_OUT, (<span class="keywordtype">void</span>*) &amp;cbw, USB_FS_BULK_EP_MAXSIZE, CbwCallback);
<a name="l00649"></a>00649 }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="comment">/**************************************************************************/</span>
<a name="l00656"></a>00656 <span class="keyword">static</span> <span class="keywordtype">void</span> ProcessScsiCdb(<span class="keywordtype">void</span>)
<a name="l00657"></a>00657 {
<a name="l00658"></a>00658   <a class="code" href="structMSDSCSI__Inquiry__TypeDef.html" title="SCSI Inquiry Command Descriptor Block (CDB) typedef.">MSDSCSI_Inquiry_TypeDef</a>       *cbI;
<a name="l00659"></a>00659   <a class="code" href="structMSDSCSI__RequestSense__TypeDef.html" title="SCSI Request Sense Command Descriptor Block (CDB) typedef.">MSDSCSI_RequestSense_TypeDef</a>  *cbRS;
<a name="l00660"></a>00660   <a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html" title="SCSI Read Capacity Command Descriptor Block (CDB) typedef.">MSDSCSI_ReadCapacity_TypeDef</a>  *cbRC;
<a name="l00661"></a>00661   <a class="code" href="structMSDSCSI__Read10__TypeDef.html" title="SCSI Read 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Read10_TypeDef</a>        *cbR10;
<a name="l00662"></a>00662   <a class="code" href="structMSDSCSI__Write10__TypeDef.html" title="SCSI Write 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Write10_TypeDef</a>       *cbW10;
<a name="l00663"></a>00663   <a class="code" href="structMSDSCSI__Verify10__TypeDef.html" title="SCSI Verify 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Verify10_TypeDef</a>      *cbV10;
<a name="l00664"></a>00664   <a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html" title="SCSI Start Stop Unit Command Descriptor Block (CDB) typedef.">MSDSCSI_StartStopUnit_TypeDef</a> *cbSSU;
<a name="l00665"></a>00665 
<a name="l00666"></a>00666   EFM32_ALIGN(4)
<a name="l00667"></a>00667   static <a class="code" href="structMSDSCSI__ReadCapacityData__TypeDef.html" title="SCSI Read Capacity response data typedef.">MSDSCSI_ReadCapacityData_TypeDef</a> ReadCapData __attribute__ ((aligned(4)));
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   pCmdStatus-&gt;valid    = false;
<a name="l00670"></a>00670   pCmdStatus-&gt;xferType = XFER_MEMORYMAPPED;
<a name="l00671"></a>00671   pCmdStatus-&gt;maxBurst = MSD_MAX_BURST;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673   switch (pCbw-&gt;CBWCB[ 0 ])
<a name="l00674"></a>00674   {
<a name="l00675"></a>00675   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#gab4c8f5b2d1f25d97b00b9df156ccc283" title="SCSI Inquiry command opcode.">SCSI_INQUIRY</a>:
<a name="l00676"></a>00676     cbI = (<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html" title="SCSI Inquiry Command Descriptor Block (CDB) typedef.">MSDSCSI_Inquiry_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00677"></a>00677 
<a name="l00678"></a>00678     if ((cbI-&gt;<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html#af899eee2e39c656937846058b75ec6c0" title="Enable Vital Product data.">Evpd</a> == 0) &amp;&amp; (cbI-&gt;<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html#a04ada094ef3e0a16ea93876216395476" title="Pagecode.">PageCode</a> == 0))
<a name="l00679"></a>00679     {
<a name="l00680"></a>00680       <span class="comment">/* Standard Inquiry data request */</span>
<a name="l00681"></a>00681       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00682"></a>00682       pCmdStatus-&gt;direction = MSD_DIR_DATA_IN;
<a name="l00683"></a>00683       pCmdStatus-&gt;pData     = (uint8_t*) &amp;InquiryData;
<a name="l00684"></a>00684       pCmdStatus-&gt;xferLen   = EFM32_MIN(<a class="code" href="group__Msd.html#ga59d92155a959caa17dee09196cf59e7c" title="SCSI Inquiry response data length.">SCSI_INQUIRYDATA_LEN</a>,
<a name="l00685"></a>00685                                         __REV16(cbI-&gt;<a class="code" href="structMSDSCSI__Inquiry__TypeDef.html#a425c76925763cc8e363882b9a16493e0" title="Number of inquiry data bytes requested.">AllocationLength</a>));
<a name="l00686"></a>00686     }
<a name="l00687"></a>00687     <span class="keywordflow">break</span>;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga10f4287430fb0b3832ef457bd413d709" title="SCSI Request Sense command opcode.">SCSI_REQUESTSENSE</a>:
<a name="l00690"></a>00690     cbRS = (<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html" title="SCSI Request Sense Command Descriptor Block (CDB) typedef.">MSDSCSI_RequestSense_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00691"></a>00691 
<a name="l00692"></a>00692     if ((cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#ae2b17b045b6184a08d78553837a90de9" title="Descriptor format.">Desc</a> == 0) &amp;&amp; (cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#a8bb0ae69d8e75ed18fdb619b465d748f" title="Reserved, expect 0.">Reserved1</a> == 0) &amp;&amp;
<a name="l00693"></a>00693         (cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#a198e363c27bbe1a92976ff6aca143eb7" title="Reserved, expect 0.">Reserved2</a> == 0) &amp;&amp; (cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#a6c5abb63ad406f601ca9532c095fe2e5" title="Reserved, expect 0.">Reserved3</a> == 0))
<a name="l00694"></a>00694     {
<a name="l00695"></a>00695       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00696"></a>00696       pCmdStatus-&gt;direction = MSD_DIR_DATA_IN;
<a name="l00697"></a>00697       pCmdStatus-&gt;pData     = (uint8_t*) pSenseData;
<a name="l00698"></a>00698       pCmdStatus-&gt;xferLen   = EFM32_MIN(<a class="code" href="group__Msd.html#ga5981ba77043dd5be09ef0c563d5acac1" title="SCSI Request Sense response data length.">SCSI_REQUESTSENSEDATA_LEN</a>,
<a name="l00699"></a>00699                                         cbRS-&gt;<a class="code" href="structMSDSCSI__RequestSense__TypeDef.html#af731f84bb4dd977080536bc124573bc5" title="Number of sense data bytes requested.">AllocationLength</a>);
<a name="l00700"></a>00700       pSenseData = (<a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a>*) &amp;NoSenseData;
<a name="l00701"></a>00701     }
<a name="l00702"></a>00702     <span class="keywordflow">break</span>;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga5f964a9cdf8ee464d1250534d85b67be" title="SCSI Read Capacity command opcode.">SCSI_READCAPACITY</a>:
<a name="l00705"></a>00705     cbRC = (<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html" title="SCSI Read Capacity Command Descriptor Block (CDB) typedef.">MSDSCSI_ReadCapacity_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707     if ((cbRC-&gt;<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html#a0c5c6644819e22145dddcebc72042fa0" title="Partial medium indicator.">Pmi</a> == 0) &amp;&amp; (cbRC-&gt;<a class="code" href="structMSDSCSI__ReadCapacity__TypeDef.html#a68cd5734a4019cd89f9880c7ea74b95b" title="Logical Block (sector) Address.">Lba</a> == 0))
<a name="l00708"></a>00708     {
<a name="l00709"></a>00709       ReadCapData.LogicalBlockAddress = __REV(MSDDMEDIA_GetSectorCount() - 1);
<a name="l00710"></a>00710       ReadCapData.LogicalBlockLength  = __REV(512);
<a name="l00711"></a>00711 
<a name="l00712"></a>00712       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00713"></a>00713       pCmdStatus-&gt;direction = MSD_DIR_DATA_IN;
<a name="l00714"></a>00714       pCmdStatus-&gt;pData     = (uint8_t*) &amp;ReadCapData;
<a name="l00715"></a>00715       pCmdStatus-&gt;xferLen   = <a class="code" href="group__Msd.html#gab6ed4755185c4e6d8d0de6f8dd021e8c" title="SCSI Read Capacity response data length.">SCSI_READCAPACITYDATA_LEN</a>;
<a name="l00716"></a>00716     }
<a name="l00717"></a>00717     <span class="keywordflow">break</span>;
<a name="l00718"></a>00718 
<a name="l00719"></a>00719   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga4f9d424a949ee51924aa88f283afb085" title="SCSI Read (10) command opcode.">SCSI_READ10</a>:
<a name="l00720"></a>00720     cbR10 = (<a class="code" href="structMSDSCSI__Read10__TypeDef.html" title="SCSI Read 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Read10_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     pCmdStatus-&gt;direction = MSD_DIR_DATA_IN;
<a name="l00723"></a>00723     pCmdStatus-&gt;valid     = MSDDMEDIA_CheckAccess(pCmdStatus,
<a name="l00724"></a>00724                                                   __REV(cbR10-&gt;<a class="code" href="structMSDSCSI__Read10__TypeDef.html#a0f7d380926a76054cfc9f1ba47e606b0" title="Logical Block (sector) Address.">Lba</a>),
<a name="l00725"></a>00725                                                   __REV16(cbR10-&gt;<a class="code" href="structMSDSCSI__Read10__TypeDef.html#ac761573476109ed41d9ae45932d3fcf4" title="Number of blocks (sectors) to transfer.">TransferLength</a>));
<a name="l00726"></a>00726     <span class="keywordflow">break</span>;
<a name="l00727"></a>00727 
<a name="l00728"></a>00728   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga4a9efd10e4c1670e2c3546f937e9cb34" title="SCSI Write (10) command opcode.">SCSI_WRITE10</a>:
<a name="l00729"></a>00729     cbW10 = (<a class="code" href="structMSDSCSI__Write10__TypeDef.html" title="SCSI Write 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Write10_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00730"></a>00730 
<a name="l00731"></a>00731     pCmdStatus-&gt;direction = MSD_DIR_DATA_OUT;
<a name="l00732"></a>00732     pCmdStatus-&gt;valid     = MSDDMEDIA_CheckAccess(pCmdStatus,
<a name="l00733"></a>00733                                                   __REV(cbW10-&gt;<a class="code" href="structMSDSCSI__Write10__TypeDef.html#a8e61a32441fc28c57dbc04a9962d0386" title="Logical Block (sector) Address.">Lba</a>),
<a name="l00734"></a>00734                                                   __REV16(cbW10-&gt;<a class="code" href="structMSDSCSI__Write10__TypeDef.html#a5473a605c45f7cda62e548f54d7091dd" title="Number of blocks (sectors) to transfer.">TransferLength</a>));
<a name="l00735"></a>00735     <span class="keywordflow">break</span>;
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga4f799250b498efb9dc2378a7a1baa302" title="SCSI Verify (10) command opcode.">SCSI_VERIFY10</a>:
<a name="l00738"></a>00738     cbV10 = (<a class="code" href="structMSDSCSI__Verify10__TypeDef.html" title="SCSI Verify 10 Command Descriptor Block (CDB) typedef.">MSDSCSI_Verify10_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740     if ((cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#a4cf6da4c4a0443bff4e1b3b9d78ebc1d" title="Byte check bit.">BytChk</a>      == 0) &amp;&amp; (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#afe13ed477f355fdd34c3d10843bc31f5" title="Reserved, expect 0.">Reserved1</a> == 0) &amp;&amp;
<a name="l00741"></a>00741         (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#a3f9d0c3d3f6a0d4258f5f5e7649f0471" title="Disable Page Out.">Dpo</a>         == 0) &amp;&amp; (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#ae54d995272dc054a0e9fbbd81f3f068c" title="Verify Protect field.">VrProtect</a> == 0) &amp;&amp;
<a name="l00742"></a>00742         (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#a78e4e235d994c3abc8711f5c64f794ac" title="Group Number field.">GroupNumber</a> == 0) &amp;&amp; (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#a01e41e3686ae7f1dce001471cebabc1b" title="Reserved, expect 0.">Reserved2</a> == 0) &amp;&amp;
<a name="l00743"></a>00743         (cbV10-&gt;<a class="code" href="structMSDSCSI__Verify10__TypeDef.html#adfe482cd9c3347df2e2bb5d4ac018890" title="Treat as a reserved field, expect 0.">Restricted</a>  == 0))
<a name="l00744"></a>00744     {
<a name="l00745"></a>00745       pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00746"></a>00746       pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00747"></a>00747       pCmdStatus-&gt;xferLen   = 0;
<a name="l00748"></a>00748     }
<a name="l00749"></a>00749     <span class="keywordflow">break</span>;
<a name="l00750"></a>00750 
<a name="l00751"></a>00751   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#gac15197fa8bd507ec529006c64f8437eb" title="SCSI Test Unit Ready command opcode.">SCSI_TESTUNIT_READY</a>:
<a name="l00752"></a>00752     pCmdStatus-&gt;valid     = turResponse;
<a name="l00753"></a>00753     pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00754"></a>00754     pCmdStatus-&gt;xferLen   = 0;
<a name="l00755"></a>00755     <span class="keywordflow">return</span>;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757   <span class="keywordflow">case</span> <a class="code" href="group__Msd.html#ga732b33c6fded33c1e25db28a34f38315" title="SCSI Start Stop Unit command opcode.">SCSI_STARTSTOP_UNIT</a>:
<a name="l00758"></a>00758     cbSSU = (<a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html" title="SCSI Start Stop Unit Command Descriptor Block (CDB) typedef.">MSDSCSI_StartStopUnit_TypeDef</a>*) &amp;pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#aa18393e006359b6cebf0bdfe47af4c5d" title="SCSI CDB.">CBWCB</a>;
<a name="l00759"></a>00759     if ((cbSSU-&gt;<a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html#a646ad0a2021235db4e290aea36936a94" title="Reserved, expect 0.">Reserved1</a>      == 0) &amp;&amp; (cbSSU-&gt;<a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html#a793c7ce8c4f511ecdcfcc65d6c028632" title="Reserved, expect 0.">Reserved2</a> == 0) &amp;&amp;
<a name="l00760"></a>00760         (cbSSU-&gt;<a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html#a178d7845df524ce000cd568862efaf87" title="Reserved, expect 0.">Reserved3</a>      == 0) &amp;&amp; (cbSSU-&gt;<a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html#af122206838857c33025506bc38300553" title="Reserved, expect 0.">Reserved4</a> == 0) &amp;&amp;
<a name="l00761"></a>00761         (cbSSU-&gt;<a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html#a8e58c6537123b18587dcb8d52b2be35a" title="Power Condition field.">PowerCondition</a> == 0) &amp;&amp; (cbSSU-&gt;<a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html#ade192c3c1d97bc4aae65977e9eb22c8f" title="Load Eject.">LoEj</a>      == 1) &amp;&amp;
<a name="l00762"></a>00762         (cbSSU-&gt;<a class="code" href="structMSDSCSI__StartStopUnit__TypeDef.html#adf0825ffb98db4975fb19e57bc9bcf1e" title="Start bit.">Start</a>          == 0))
<a name="l00763"></a>00763     {
<a name="l00764"></a>00764       <span class="comment">// Eject media.</span>
<a name="l00765"></a>00765       turResponse = <span class="keyword">false</span>;              <span class="comment">// Set TEST UNIT READY response value.</span>
<a name="l00766"></a>00766     }
<a name="l00767"></a>00767     pCmdStatus-&gt;valid     = <span class="keyword">true</span>;
<a name="l00768"></a>00768     pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00769"></a>00769     pCmdStatus-&gt;xferLen   = 0;
<a name="l00770"></a>00770     pCmdStatus-&gt;xferType  = XFER_INDIRECT;
<a name="l00771"></a>00771     <span class="keywordflow">break</span>;
<a name="l00772"></a>00772   }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774   <span class="keywordflow">if</span> (!pCmdStatus-&gt;valid)
<a name="l00775"></a>00775   {
<a name="l00776"></a>00776     pCmdStatus-&gt;xferLen   = 0;
<a name="l00777"></a>00777     pCmdStatus-&gt;direction = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#a084a414ac725c2455e1c15cc56d05abb" title="BOT transfer directon, 1=BOT IN.">Direction</a>;
<a name="l00778"></a>00778     pSenseData            = (<a class="code" href="structMSDSCSI__RequestSenseData__TypeDef.html" title="SCSI Request Sense response data typedef.">MSDSCSI_RequestSenseData_TypeDef</a>*) &amp;IllegalSenseData;
<a name="l00779"></a>00779   }
<a name="l00780"></a>00780 }
<a name="l00781"></a>00781 
<a name="l00782"></a>00782 <span class="comment">/**************************************************************************/</span>
<a name="l00786"></a>00786 __STATIC_INLINE <span class="keywordtype">void</span> SendCsw(<span class="keywordtype">void</span>)
<a name="l00787"></a>00787 {
<a name="l00788"></a>00788   <span class="keywordflow">if</span> ( ledPort != -1 )
<a name="l00789"></a>00789     GPIO_PinOutToggle((GPIO_Port_TypeDef)ledPort, ledPin);
<a name="l00790"></a>00790 
<a name="l00791"></a>00791   USBD_Write(MSD_BULK_IN, (<span class="keywordtype">void</span>*) &amp;csw, CSW_LEN, NULL);
<a name="l00792"></a>00792 }
<a name="l00793"></a>00793 
<a name="l00794"></a>00794 <span class="comment">/**************************************************************************/</span>
<a name="l00808"></a>00808 <span class="keyword">static</span> <span class="keywordtype">void</span> UsbXferBotData(uint8_t *data, uint32_t len,
<a name="l00809"></a>00809                            USB_XferCompleteCb_TypeDef cb)
<a name="l00810"></a>00810 {
<a name="l00811"></a>00811   <span class="keywordflow">if</span> (pCmdStatus-&gt;direction)
<a name="l00812"></a>00812   {
<a name="l00813"></a>00813     USBD_Write(MSD_BULK_IN, data, len, cb);
<a name="l00814"></a>00814   }
<a name="l00815"></a>00815   <span class="keywordflow">else</span>
<a name="l00816"></a>00816   {
<a name="l00817"></a>00817     USBD_Read(MSD_BULK_OUT, data, len, cb);
<a name="l00818"></a>00818   }
<a name="l00819"></a>00819 }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 <span class="comment">/**************************************************************************/</span>
<a name="l00829"></a>00829 <span class="keyword">static</span> <span class="keywordtype">void</span> XferBotData(uint32_t length)
<a name="l00830"></a>00830 {
<a name="l00831"></a>00831   pCmdStatus-&gt;xferLen   = length;
<a name="l00832"></a>00832   pCsw-&gt;dCSWDataResidue = pCbw-&gt;<a class="code" href="structMSDBOT__CBW__TypeDef.html#abf7f2eddb63bc80793fc668025fb2727" title="BOT transfer length.">dCBWDataTransferLength</a>;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834   <span class="keywordflow">if</span> (pCmdStatus-&gt;xferType == XFER_INDIRECT)
<a name="l00835"></a>00835   {
<a name="l00836"></a>00836     <span class="comment">/* Access media in &quot;background&quot; polling loop, i.e. in MSDD_Handler() */</span>
<a name="l00837"></a>00837     savedState = msdState;
<a name="l00838"></a>00838     msdState   = MSDD_ACCESS_INDIRECT;
<a name="l00839"></a>00839   }
<a name="l00840"></a>00840   <span class="keywordflow">else</span>
<a name="l00841"></a>00841   {
<a name="l00842"></a>00842     UsbXferBotData(pCmdStatus-&gt;pData,
<a name="l00843"></a>00843                    EFM32_MIN(length, pCmdStatus-&gt;maxBurst),
<a name="l00844"></a>00844                    XferBotDataCallback);
<a name="l00845"></a>00845   }
<a name="l00846"></a>00846 }
<a name="l00847"></a>00847 
<a name="l00848"></a>00848 <span class="comment">/**************************************************************************/</span>
<a name="l00867"></a>00867 <span class="keyword">static</span> <span class="keywordtype">int</span> XferBotDataCallback(USB_Status_TypeDef status,
<a name="l00868"></a>00868                                uint32_t xferred, uint32_t remaining)
<a name="l00869"></a>00869 {
<a name="l00870"></a>00870   (void) status;
<a name="l00871"></a>00871   (void) remaining;
<a name="l00872"></a>00872 
<a name="l00873"></a>00873   pCmdStatus-&gt;xferLen   -= xferred;
<a name="l00874"></a>00874   pCsw-&gt;dCSWDataResidue -= xferred;
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   <span class="keywordflow">if</span> (pCmdStatus-&gt;xferLen)
<a name="l00877"></a>00877   {
<a name="l00878"></a>00878     pCmdStatus-&gt;pData += xferred;
<a name="l00879"></a>00879     UsbXferBotData(pCmdStatus-&gt;pData,
<a name="l00880"></a>00880                    EFM32_MIN(pCmdStatus-&gt;xferLen, pCmdStatus-&gt;maxBurst),
<a name="l00881"></a>00881                    XferBotDataCallback);
<a name="l00882"></a>00882   }
<a name="l00883"></a>00883   <span class="keywordflow">else</span>
<a name="l00884"></a>00884   {
<a name="l00885"></a>00885     <span class="keywordflow">if</span> (msdState == MSDD_SEND_CSW)
<a name="l00886"></a>00886     {
<a name="l00887"></a>00887       SendCsw();
<a name="l00888"></a>00888       EnableNextCbw();
<a name="l00889"></a>00889       msdState = MSDD_WAITFOR_CBW;
<a name="l00890"></a>00890     }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (msdState == MSDD_STALL_IN)
<a name="l00893"></a>00893     {
<a name="l00894"></a>00894       USBD_StallEp(MSD_BULK_IN);
<a name="l00895"></a>00895       msdState = MSDD_WAIT_FOR_INUNSTALLED;
<a name="l00896"></a>00896     }
<a name="l00897"></a>00897   }
<a name="l00898"></a>00898 
<a name="l00899"></a>00899   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00900"></a>00900 }
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 <span class="comment">/**************************************************************************/</span>
<a name="l00919"></a>00919 <span class="keyword">static</span> <span class="keywordtype">int</span> XferBotDataIndirectCallback(USB_Status_TypeDef status,
<a name="l00920"></a>00920                                        uint32_t xferred, uint32_t remaining)
<a name="l00921"></a>00921 {
<a name="l00922"></a>00922   (void) status;
<a name="l00923"></a>00923   (void) remaining;
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   pCmdStatus-&gt;xferLen   -= xferred;
<a name="l00926"></a>00926   pCsw-&gt;dCSWDataResidue -= xferred;
<a name="l00927"></a>00927 
<a name="l00928"></a>00928   <span class="keywordflow">if</span> (pCmdStatus-&gt;direction)
<a name="l00929"></a>00929   {
<a name="l00930"></a>00930     pCmdStatus-&gt;lba += xferred / 512;
<a name="l00931"></a>00931     msdState         = MSDD_ACCESS_INDIRECT;
<a name="l00932"></a>00932   }
<a name="l00933"></a>00933   <span class="keywordflow">else</span>
<a name="l00934"></a>00934   {
<a name="l00935"></a>00935     msdState = MSDD_WRITE_INDIRECT;
<a name="l00936"></a>00936   }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
</pre></div></div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Sep 7 09:26:01 2015</small> for Board Support Package by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
