<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Board Support Package: common/drivers/cdc.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_c5ab7d5005c5f96afef39cd6ff9e2484.html">common</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_640347b79a58de25a4e6f9b018e8e1be.html">drivers</a>
  </div>
</div>
<div class="contents">
<h1>cdc.c</h1><a href="cdc_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**************************************************************************/</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &quot;em_device.h&quot;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &quot;em_common.h&quot;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;em_cmu.h&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;em_dma.h&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;em_gpio.h&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;em_usart.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;em_usb.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="bsp_8h.html" title="Board support package API definitions.">bsp.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="dmactrl_8h.html" title="DMA control data block.">dmactrl.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="cdc_8h.html" title="USB Communication Device Class (CDC) driver.">cdc.h</a>&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/**************************************************************************/</span>
<a name="l00093"></a>00093 <span class="comment">/*** Typedef&#39;s and defines. ***/</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="preprocessor">#define CDC_BULK_EP_SIZE  (USB_FS_BULK_EP_MAXSIZE) </span><span class="comment">/* This is the max. ep size.    */</span>
<a name="l00096"></a>00096 <span class="preprocessor">#define CDC_USB_RX_BUF_SIZ  CDC_BULK_EP_SIZE </span><span class="comment">/* Packet size when receiving on USB. */</span>
<a name="l00097"></a>00097 <span class="preprocessor">#define CDC_USB_TX_BUF_SIZ  127    </span><span class="comment">/* Packet size when transmitting on USB.  */</span>
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="comment">/* Calculate a timeout in ms corresponding to 5 char times on current     */</span>
<a name="l00100"></a>00100 <span class="comment">/* baudrate. Minimum timeout is set to 10 ms.                             */</span>
<a name="l00101"></a>00101 <span class="preprocessor">#define CDC_RX_TIMEOUT    EFM32_MAX(10U, 50000 / (cdcLineCoding.dwDTERate))</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>
<a name="l00103"></a>00103 <span class="comment">/* The serial port LINE CODING data structure, used to carry information  */</span>
<a name="l00104"></a>00104 <span class="comment">/* about serial port baudrate, parity etc. between host and device.       */</span>
<a name="l00105"></a>00105 EFM32_PACK_START(1)
<a name="l00106"></a>00106 typedef struct
<a name="l00107"></a>00107 {
<a name="l00108"></a>00108   uint32_t dwDTERate;               
<a name="l00109"></a>00109   uint8_t  bCharFormat;             
<a name="l00110"></a>00110   uint8_t  bParityType;             
<a name="l00111"></a>00111   uint8_t  bDataBits;               
<a name="l00112"></a>00112   uint8_t  dummy;                   
<a name="l00113"></a>00113 } __attribute__ ((packed)) cdcLineCoding_TypeDef;
<a name="l00114"></a>00114 EFM32_PACK_END()
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="comment">/*** Function prototypes. ***/</span>
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 static <span class="keywordtype">int</span>  UsbDataReceived(USB_Status_TypeDef status, uint32_t xferred,
<a name="l00120"></a>00120                             uint32_t remaining);
<a name="l00121"></a>00121 static <span class="keywordtype">void</span> DmaSetup(<span class="keywordtype">void</span>);
<a name="l00122"></a>00122 static <span class="keywordtype">int</span>  LineCodingReceived(USB_Status_TypeDef status,
<a name="l00123"></a>00123                                uint32_t xferred,
<a name="l00124"></a>00124                                uint32_t remaining);
<a name="l00125"></a>00125 static <span class="keywordtype">void</span> SerialPortInit(<span class="keywordtype">void</span>);
<a name="l00126"></a>00126 static <span class="keywordtype">void</span> UartRxTimeout(<span class="keywordtype">void</span>);
<a name="l00127"></a>00127 
<a name="l00128"></a>00128 <span class="comment">/*** Variables ***/</span>
<a name="l00129"></a>00129 
<a name="l00130"></a>00130 <span class="comment">/*</span>
<a name="l00131"></a>00131 <span class="comment"> * The LineCoding variable must be 4-byte aligned as it is used as USB</span>
<a name="l00132"></a>00132 <span class="comment"> * transmit and receive buffer.</span>
<a name="l00133"></a>00133 <span class="comment"> */</span>
<a name="l00134"></a>00134 EFM32_ALIGN(4)
<a name="l00135"></a>00135 EFM32_PACK_START(1)
<a name="l00136"></a>00136 static cdcLineCoding_TypeDef __attribute__ ((aligned(4))) cdcLineCoding =
<a name="l00137"></a>00137 {
<a name="l00138"></a>00138   115200, 0, 0, 8, 0
<a name="l00139"></a>00139 };
<a name="l00140"></a>00140 EFM32_PACK_END()
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 STATIC_UBUF(usbRxBuffer0,  CDC_USB_RX_BUF_SIZ);   <span class="comment">/* USB receive buffers.   */</span>
<a name="l00143"></a>00143 STATIC_UBUF(usbRxBuffer1,  CDC_USB_RX_BUF_SIZ);
<a name="l00144"></a>00144 STATIC_UBUF(uartRxBuffer0, CDC_USB_TX_BUF_SIZ);   <span class="comment">/* UART receive buffers.  */</span>
<a name="l00145"></a>00145 STATIC_UBUF(uartRxBuffer1, CDC_USB_TX_BUF_SIZ);
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 static const uint8_t  *usbRxBuffer[  2 ] = { usbRxBuffer0, usbRxBuffer1 };
<a name="l00148"></a>00148 <span class="keyword">static</span> <span class="keyword">const</span> uint8_t  *uartRxBuffer[ 2 ] = { uartRxBuffer0, uartRxBuffer1 };
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="keyword">static</span> <span class="keywordtype">int</span>            usbRxIndex, usbBytesReceived;
<a name="l00151"></a>00151 <span class="keyword">static</span> <span class="keywordtype">int</span>            uartRxIndex, uartRxCount;
<a name="l00152"></a>00152 <span class="keyword">static</span> <span class="keywordtype">int</span>            LastUsbTxCnt;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">static</span> <span class="keywordtype">bool</span>           dmaRxCompleted;
<a name="l00155"></a>00155 <span class="keyword">static</span> <span class="keywordtype">bool</span>           usbRxActive, dmaTxActive;
<a name="l00156"></a>00156 <span class="keyword">static</span> <span class="keywordtype">bool</span>           usbTxActive, dmaRxActive;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="keyword">static</span> DMA_CB_TypeDef DmaTxCallBack;    
<a name="l00159"></a>00159 <span class="keyword">static</span> DMA_CB_TypeDef DmaRxCallBack;
<a name="l00160"></a>00160 
<a name="l00163"></a>00163 <span class="comment">/**************************************************************************/</span>
<a name="l00166"></a><a class="code" href="group__Cdc.html#gaecd54ce9131e15785ad9cbd5105765d7">00166</a> <span class="keywordtype">void</span> <a class="code" href="group__Cdc.html#gaecd54ce9131e15785ad9cbd5105765d7" title="CDC device initialization.">CDC_Init</a>( <span class="keywordtype">void</span> )
<a name="l00167"></a>00167 {
<a name="l00168"></a>00168   SerialPortInit();
<a name="l00169"></a>00169   DmaSetup();
<a name="l00170"></a>00170 }
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="comment">/**************************************************************************/</span>
<a name="l00182"></a><a class="code" href="group__Cdc.html#gabb299273fea87474d24e85a3fe1ad4d0">00182</a> <span class="keywordtype">int</span> <a class="code" href="group__Cdc.html#gabb299273fea87474d24e85a3fe1ad4d0" title="Handle USB setup commands.">CDC_SetupCmd</a>(<span class="keyword">const</span> USB_Setup_TypeDef *setup)
<a name="l00183"></a>00183 {
<a name="l00184"></a>00184   <span class="keywordtype">int</span> retVal = USB_STATUS_REQ_UNHANDLED;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="keywordflow">if</span> ( ( setup-&gt;Type      == USB_SETUP_TYPE_CLASS          ) &amp;&amp;
<a name="l00187"></a>00187        ( setup-&gt;Recipient == USB_SETUP_RECIPIENT_INTERFACE )    )
<a name="l00188"></a>00188   {
<a name="l00189"></a>00189     <span class="keywordflow">switch</span> (setup-&gt;bRequest)
<a name="l00190"></a>00190     {
<a name="l00191"></a>00191     <span class="keywordflow">case</span> USB_CDC_GETLINECODING:
<a name="l00192"></a>00192       <span class="comment">/********************/</span>
<a name="l00193"></a>00193       <span class="keywordflow">if</span> ( ( setup-&gt;wValue    == 0                     ) &amp;&amp;
<a name="l00194"></a>00194            ( setup-&gt;wIndex    == CDC_CTRL_INTERFACE_NO ) &amp;&amp; <span class="comment">/* Interface no. */</span>
<a name="l00195"></a>00195            ( setup-&gt;wLength   == 7                     ) &amp;&amp; <span class="comment">/* Length of cdcLineCoding. */</span>
<a name="l00196"></a>00196            ( setup-&gt;Direction == USB_SETUP_DIR_IN      )    )
<a name="l00197"></a>00197       {
<a name="l00198"></a>00198         <span class="comment">/* Send current settings to USB host. */</span>
<a name="l00199"></a>00199         USBD_Write(0, (<span class="keywordtype">void</span>*) &amp;cdcLineCoding, 7, NULL);
<a name="l00200"></a>00200         retVal = USB_STATUS_OK;
<a name="l00201"></a>00201       }
<a name="l00202"></a>00202       <span class="keywordflow">break</span>;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     <span class="keywordflow">case</span> USB_CDC_SETLINECODING:
<a name="l00205"></a>00205       <span class="comment">/********************/</span>
<a name="l00206"></a>00206       <span class="keywordflow">if</span> ( ( setup-&gt;wValue    == 0                     ) &amp;&amp;
<a name="l00207"></a>00207            ( setup-&gt;wIndex    == CDC_CTRL_INTERFACE_NO ) &amp;&amp; <span class="comment">/* Interface no. */</span>
<a name="l00208"></a>00208            ( setup-&gt;wLength   == 7                     ) &amp;&amp; <span class="comment">/* Length of cdcLineCoding. */</span>
<a name="l00209"></a>00209            ( setup-&gt;Direction != USB_SETUP_DIR_IN      )    )
<a name="l00210"></a>00210       {
<a name="l00211"></a>00211         <span class="comment">/* Get new settings from USB host. */</span>
<a name="l00212"></a>00212         USBD_Read(0, (<span class="keywordtype">void</span>*) &amp;cdcLineCoding, 7, LineCodingReceived);
<a name="l00213"></a>00213         retVal = USB_STATUS_OK;
<a name="l00214"></a>00214       }
<a name="l00215"></a>00215       <span class="keywordflow">break</span>;
<a name="l00216"></a>00216 
<a name="l00217"></a>00217     <span class="keywordflow">case</span> USB_CDC_SETCTRLLINESTATE:
<a name="l00218"></a>00218       <span class="comment">/********************/</span>
<a name="l00219"></a>00219       <span class="keywordflow">if</span> ( ( setup-&gt;wIndex  == CDC_CTRL_INTERFACE_NO ) &amp;&amp;   <span class="comment">/* Interface no.  */</span>
<a name="l00220"></a>00220            ( setup-&gt;wLength == 0                     )    ) <span class="comment">/* No data.       */</span>
<a name="l00221"></a>00221       {
<a name="l00222"></a>00222         <span class="comment">/* Do nothing ( Non compliant behaviour !! ) */</span>
<a name="l00223"></a>00223         retVal = USB_STATUS_OK;
<a name="l00224"></a>00224       }
<a name="l00225"></a>00225       <span class="keywordflow">break</span>;
<a name="l00226"></a>00226     }
<a name="l00227"></a>00227   }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229   <span class="keywordflow">return</span> retVal;
<a name="l00230"></a>00230 }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 <span class="comment">/**************************************************************************/</span>
<a name="l00240"></a><a class="code" href="group__Cdc.html#gaab8bd37b2a51931c429dbec05e92c11f">00240</a> <span class="keywordtype">void</span> <a class="code" href="group__Cdc.html#gaab8bd37b2a51931c429dbec05e92c11f" title="Callback function called each time the USB device state is changed.">CDC_StateChangeEvent</a>( USBD_State_TypeDef oldState,
<a name="l00241"></a>00241                            USBD_State_TypeDef newState)
<a name="l00242"></a>00242 {
<a name="l00243"></a>00243   <span class="keywordflow">if</span> (newState == USBD_STATE_CONFIGURED)
<a name="l00244"></a>00244   {
<a name="l00245"></a>00245     <span class="comment">/* We have been configured, start CDC functionality ! */</span>
<a name="l00246"></a>00246 
<a name="l00247"></a>00247     <span class="keywordflow">if</span> (oldState == USBD_STATE_SUSPENDED)   <span class="comment">/* Resume ?   */</span>
<a name="l00248"></a>00248     {
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="comment">/* Start receiving data from USB host. */</span>
<a name="l00252"></a>00252     usbRxIndex  = 0;
<a name="l00253"></a>00253     usbRxActive = <span class="keyword">true</span>;
<a name="l00254"></a>00254     dmaTxActive = <span class="keyword">false</span>;
<a name="l00255"></a>00255     USBD_Read(CDC_EP_DATA_OUT, (<span class="keywordtype">void</span>*) usbRxBuffer[ usbRxIndex ],
<a name="l00256"></a>00256               CDC_USB_RX_BUF_SIZ, UsbDataReceived);
<a name="l00257"></a>00257 
<a name="l00258"></a>00258     <span class="comment">/* Start receiving data on UART. */</span>
<a name="l00259"></a>00259     uartRxIndex    = 0;
<a name="l00260"></a>00260     LastUsbTxCnt   = 0;
<a name="l00261"></a>00261     uartRxCount    = 0;
<a name="l00262"></a>00262     dmaRxActive    = <span class="keyword">true</span>;
<a name="l00263"></a>00263     usbTxActive    = <span class="keyword">false</span>;
<a name="l00264"></a>00264     dmaRxCompleted = <span class="keyword">true</span>;
<a name="l00265"></a>00265     DMA_ActivateBasic(CDC_UART_RX_DMA_CHANNEL, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l00266"></a>00266                       (<span class="keywordtype">void</span> *) uartRxBuffer[ uartRxIndex ],
<a name="l00267"></a>00267                       (<span class="keywordtype">void</span> *) &amp;(CDC_UART-&gt;RXDATA),
<a name="l00268"></a>00268                       CDC_USB_TX_BUF_SIZ - 1);
<a name="l00269"></a>00269     USBTIMER_Start(CDC_TIMER_ID, CDC_RX_TIMEOUT, UartRxTimeout);
<a name="l00270"></a>00270   }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((oldState == USBD_STATE_CONFIGURED) &amp;&amp;
<a name="l00273"></a>00273            (newState != USBD_STATE_SUSPENDED))
<a name="l00274"></a>00274   {
<a name="l00275"></a>00275     <span class="comment">/* We have been de-configured, stop CDC functionality. */</span>
<a name="l00276"></a>00276     USBTIMER_Stop(CDC_TIMER_ID);
<a name="l00277"></a>00277     <span class="comment">/* Stop DMA channels. */</span>
<a name="l00278"></a>00278     DMA-&gt;CHENC = ( 1 &lt;&lt; CDC_UART_TX_DMA_CHANNEL ) |
<a name="l00279"></a>00279                  ( 1 &lt;&lt; CDC_UART_RX_DMA_CHANNEL );
<a name="l00280"></a>00280   }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (newState == USBD_STATE_SUSPENDED)
<a name="l00283"></a>00283   {
<a name="l00284"></a>00284     <span class="comment">/* We have been suspended, stop CDC functionality. */</span>
<a name="l00285"></a>00285     <span class="comment">/* Reduce current consumption to below 2.5 mA.     */</span>
<a name="l00286"></a>00286     USBTIMER_Stop(CDC_TIMER_ID);
<a name="l00287"></a>00287     <span class="comment">/* Stop DMA channels. */</span>
<a name="l00288"></a>00288     DMA-&gt;CHENC = ( 1 &lt;&lt; CDC_UART_TX_DMA_CHANNEL ) |
<a name="l00289"></a>00289                  ( 1 &lt;&lt; CDC_UART_RX_DMA_CHANNEL );
<a name="l00290"></a>00290   }
<a name="l00291"></a>00291 }
<a name="l00292"></a>00292 
<a name="l00295"></a>00295 <span class="comment">/**************************************************************************/</span>
<a name="l00305"></a>00305 <span class="keyword">static</span> <span class="keywordtype">int</span> UsbDataReceived(USB_Status_TypeDef status,
<a name="l00306"></a>00306                            uint32_t xferred,
<a name="l00307"></a>00307                            uint32_t remaining)
<a name="l00308"></a>00308 {
<a name="l00309"></a>00309   (void) remaining;            <span class="comment">/* Unused parameter. */</span>
<a name="l00310"></a>00310 
<a name="l00311"></a>00311   <span class="keywordflow">if</span> ((status == USB_STATUS_OK) &amp;&amp; (xferred &gt; 0))
<a name="l00312"></a>00312   {
<a name="l00313"></a>00313     usbRxIndex ^= 1;
<a name="l00314"></a>00314 
<a name="l00315"></a>00315     <span class="keywordflow">if</span> (!dmaTxActive)
<a name="l00316"></a>00316     {
<a name="l00317"></a>00317       <span class="comment">/* dmaTxActive = false means that a new UART Tx DMA can be started. */</span>
<a name="l00318"></a>00318       dmaTxActive = <span class="keyword">true</span>;
<a name="l00319"></a>00319       DMA_ActivateBasic(CDC_UART_TX_DMA_CHANNEL, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l00320"></a>00320                         (<span class="keywordtype">void</span> *) &amp;(CDC_UART-&gt;TXDATA),
<a name="l00321"></a>00321                         (<span class="keywordtype">void</span> *) usbRxBuffer[ usbRxIndex ^ 1 ],
<a name="l00322"></a>00322                         xferred - 1);
<a name="l00323"></a>00323 
<a name="l00324"></a>00324       <span class="comment">/* Start a new USB receive transfer. */</span>
<a name="l00325"></a>00325       USBD_Read(CDC_EP_DATA_OUT, (<span class="keywordtype">void</span>*) usbRxBuffer[ usbRxIndex ],
<a name="l00326"></a>00326                 CDC_USB_RX_BUF_SIZ, UsbDataReceived);
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328     <span class="keywordflow">else</span>
<a name="l00329"></a>00329     {
<a name="l00330"></a>00330       <span class="comment">/* The UART transmit DMA callback function will start a new DMA. */</span>
<a name="l00331"></a>00331       usbRxActive      = <span class="keyword">false</span>;
<a name="l00332"></a>00332       usbBytesReceived = xferred;
<a name="l00333"></a>00333     }
<a name="l00334"></a>00334   }
<a name="l00335"></a>00335   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="comment">/**************************************************************************/</span>
<a name="l00345"></a>00345 <span class="keyword">static</span> <span class="keywordtype">void</span> DmaTxComplete(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> channel, <span class="keywordtype">bool</span> primary, <span class="keywordtype">void</span> *user)
<a name="l00346"></a>00346 {
<a name="l00347"></a>00347   (void) channel;              <span class="comment">/* Unused parameter. */</span>
<a name="l00348"></a>00348   (void) primary;              <span class="comment">/* Unused parameter. */</span>
<a name="l00349"></a>00349   (void) user;                 <span class="comment">/* Unused parameter. */</span>
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   <span class="comment">/*</span>
<a name="l00352"></a>00352 <span class="comment">   * As nested interrupts may occur and we rely on variables usbRxActive</span>
<a name="l00353"></a>00353 <span class="comment">   * and dmaTxActive etc, we must handle this function as a critical region.</span>
<a name="l00354"></a>00354 <span class="comment">   */</span>
<a name="l00355"></a>00355   INT_Disable();
<a name="l00356"></a>00356 
<a name="l00357"></a>00357   <span class="keywordflow">if</span> (!usbRxActive)
<a name="l00358"></a>00358   {
<a name="l00359"></a>00359     <span class="comment">/* usbRxActive = false means that an USB receive packet has been received.*/</span>
<a name="l00360"></a>00360     DMA_ActivateBasic(CDC_UART_TX_DMA_CHANNEL, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l00361"></a>00361                       (<span class="keywordtype">void</span> *) &amp;(CDC_UART-&gt;TXDATA),
<a name="l00362"></a>00362                       (<span class="keywordtype">void</span> *) usbRxBuffer[ usbRxIndex ^ 1 ],
<a name="l00363"></a>00363                       usbBytesReceived - 1);
<a name="l00364"></a>00364 
<a name="l00365"></a>00365     <span class="comment">/* Start a new USB receive transfer. */</span>
<a name="l00366"></a>00366     usbRxActive = <span class="keyword">true</span>;
<a name="l00367"></a>00367     USBD_Read(CDC_EP_DATA_OUT, (<span class="keywordtype">void</span>*) usbRxBuffer[ usbRxIndex ],
<a name="l00368"></a>00368               CDC_USB_RX_BUF_SIZ, UsbDataReceived);
<a name="l00369"></a>00369   }
<a name="l00370"></a>00370   <span class="keywordflow">else</span>
<a name="l00371"></a>00371   {
<a name="l00372"></a>00372     <span class="comment">/* The USB receive complete callback function will start a new DMA. */</span>
<a name="l00373"></a>00373     dmaTxActive = <span class="keyword">false</span>;
<a name="l00374"></a>00374   }
<a name="l00375"></a>00375 
<a name="l00376"></a>00376   INT_Enable();
<a name="l00377"></a>00377 }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379 <span class="comment">/**************************************************************************/</span>
<a name="l00389"></a>00389 <span class="keyword">static</span> <span class="keywordtype">int</span> UsbDataTransmitted(USB_Status_TypeDef status,
<a name="l00390"></a>00390                               uint32_t xferred,
<a name="l00391"></a>00391                               uint32_t remaining)
<a name="l00392"></a>00392 {
<a name="l00393"></a>00393   (void) xferred;              <span class="comment">/* Unused parameter. */</span>
<a name="l00394"></a>00394   (void) remaining;            <span class="comment">/* Unused parameter. */</span>
<a name="l00395"></a>00395 
<a name="l00396"></a>00396   <span class="keywordflow">if</span> (status == USB_STATUS_OK)
<a name="l00397"></a>00397   {
<a name="l00398"></a>00398     <span class="keywordflow">if</span> (!dmaRxActive)
<a name="l00399"></a>00399     {
<a name="l00400"></a>00400       <span class="comment">/* dmaRxActive = false means that a new UART Rx DMA can be started. */</span>
<a name="l00401"></a>00401 
<a name="l00402"></a>00402       USBD_Write(CDC_EP_DATA_IN, (<span class="keywordtype">void</span>*) uartRxBuffer[ uartRxIndex ^ 1],
<a name="l00403"></a>00403                  uartRxCount, UsbDataTransmitted);
<a name="l00404"></a>00404       LastUsbTxCnt = uartRxCount;
<a name="l00405"></a>00405 
<a name="l00406"></a>00406       dmaRxActive    = <span class="keyword">true</span>;
<a name="l00407"></a>00407       dmaRxCompleted = <span class="keyword">true</span>;
<a name="l00408"></a>00408       DMA_ActivateBasic(CDC_UART_RX_DMA_CHANNEL, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l00409"></a>00409                         (<span class="keywordtype">void</span> *) uartRxBuffer[ uartRxIndex ],
<a name="l00410"></a>00410                         (<span class="keywordtype">void</span> *) &amp;(CDC_UART-&gt;RXDATA),
<a name="l00411"></a>00411                         CDC_USB_TX_BUF_SIZ - 1);
<a name="l00412"></a>00412       uartRxCount = 0;
<a name="l00413"></a>00413       USBTIMER_Start(CDC_TIMER_ID, CDC_RX_TIMEOUT, UartRxTimeout);
<a name="l00414"></a>00414     }
<a name="l00415"></a>00415     <span class="keywordflow">else</span>
<a name="l00416"></a>00416     {
<a name="l00417"></a>00417       <span class="comment">/* The UART receive DMA callback function will start a new DMA. */</span>
<a name="l00418"></a>00418       usbTxActive = <span class="keyword">false</span>;
<a name="l00419"></a>00419     }
<a name="l00420"></a>00420   }
<a name="l00421"></a>00421   <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00422"></a>00422 }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 <span class="comment">/**************************************************************************/</span>
<a name="l00431"></a>00431 <span class="keyword">static</span> <span class="keywordtype">void</span> DmaRxComplete(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> channel, <span class="keywordtype">bool</span> primary, <span class="keywordtype">void</span> *user)
<a name="l00432"></a>00432 {
<a name="l00433"></a>00433   (void) channel;              <span class="comment">/* Unused parameter. */</span>
<a name="l00434"></a>00434   (void) primary;              <span class="comment">/* Unused parameter. */</span>
<a name="l00435"></a>00435   (void) user;                 <span class="comment">/* Unused parameter. */</span>
<a name="l00436"></a>00436 
<a name="l00437"></a>00437   <span class="comment">/*</span>
<a name="l00438"></a>00438 <span class="comment">   * As nested interrupts may occur and we rely on variables usbTxActive</span>
<a name="l00439"></a>00439 <span class="comment">   * and dmaRxActive etc, we must handle this function as a critical region.</span>
<a name="l00440"></a>00440 <span class="comment">   */</span>
<a name="l00441"></a>00441   INT_Disable();
<a name="l00442"></a>00442 
<a name="l00443"></a>00443   uartRxIndex ^= 1;
<a name="l00444"></a>00444 
<a name="l00445"></a>00445   <span class="keywordflow">if</span> (dmaRxCompleted)
<a name="l00446"></a>00446   {
<a name="l00447"></a>00447     uartRxCount = CDC_USB_TX_BUF_SIZ;
<a name="l00448"></a>00448   }
<a name="l00449"></a>00449   <span class="keywordflow">else</span>
<a name="l00450"></a>00450   {
<a name="l00451"></a>00451     uartRxCount = CDC_USB_TX_BUF_SIZ - 1 -
<a name="l00452"></a>00452                   ((<a class="code" href="group__DmaCtrl.html#ga0fc5cf50e34b24c0883a6ef6dce0681c" title="DMA control block array, requires proper alignment.">dmaControlBlock</a>[ 1 ].CTRL &amp; _DMA_CTRL_N_MINUS_1_MASK)
<a name="l00453"></a>00453                    &gt;&gt; _DMA_CTRL_N_MINUS_1_SHIFT);
<a name="l00454"></a>00454   }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456   <span class="keywordflow">if</span> (!usbTxActive)
<a name="l00457"></a>00457   {
<a name="l00458"></a>00458     <span class="comment">/* usbTxActive = false means that a new USB packet can be transferred. */</span>
<a name="l00459"></a>00459     usbTxActive = <span class="keyword">true</span>;
<a name="l00460"></a>00460     USBD_Write(CDC_EP_DATA_IN, (<span class="keywordtype">void</span>*) uartRxBuffer[ uartRxIndex ^ 1],
<a name="l00461"></a>00461                uartRxCount, UsbDataTransmitted);
<a name="l00462"></a>00462     LastUsbTxCnt = uartRxCount;
<a name="l00463"></a>00463 
<a name="l00464"></a>00464     <span class="comment">/* Start a new UART receive DMA. */</span>
<a name="l00465"></a>00465     dmaRxCompleted = <span class="keyword">true</span>;
<a name="l00466"></a>00466     DMA_ActivateBasic(CDC_UART_RX_DMA_CHANNEL, <span class="keyword">true</span>, <span class="keyword">false</span>,
<a name="l00467"></a>00467                       (<span class="keywordtype">void</span> *) uartRxBuffer[ uartRxIndex ],
<a name="l00468"></a>00468                       (<span class="keywordtype">void</span> *) &amp;(CDC_UART-&gt;RXDATA),
<a name="l00469"></a>00469                       CDC_USB_TX_BUF_SIZ - 1);
<a name="l00470"></a>00470     uartRxCount = 0;
<a name="l00471"></a>00471     USBTIMER_Start(CDC_TIMER_ID, CDC_RX_TIMEOUT, UartRxTimeout);
<a name="l00472"></a>00472   }
<a name="l00473"></a>00473   <span class="keywordflow">else</span>
<a name="l00474"></a>00474   {
<a name="l00475"></a>00475     <span class="comment">/* The USB transmit complete callback function will start a new DMA. */</span>
<a name="l00476"></a>00476     dmaRxActive = <span class="keyword">false</span>;
<a name="l00477"></a>00477     USBTIMER_Stop(CDC_TIMER_ID);
<a name="l00478"></a>00478   }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   INT_Enable();
<a name="l00481"></a>00481 }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483 <span class="comment">/**************************************************************************/</span>
<a name="l00490"></a>00490 <span class="keyword">static</span> <span class="keywordtype">void</span> UartRxTimeout(<span class="keywordtype">void</span>)
<a name="l00491"></a>00491 {
<a name="l00492"></a>00492   <span class="keywordtype">int</span>      cnt;
<a name="l00493"></a>00493   uint32_t dmaCtrl;
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   dmaCtrl = <a class="code" href="group__DmaCtrl.html#ga0fc5cf50e34b24c0883a6ef6dce0681c" title="DMA control block array, requires proper alignment.">dmaControlBlock</a>[ 1 ].CTRL;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497   <span class="comment">/* Has the DMA just completed ? */</span>
<a name="l00498"></a>00498   <span class="keywordflow">if</span> ((dmaCtrl &amp; _DMA_CTRL_CYCLE_CTRL_MASK) == DMA_CTRL_CYCLE_CTRL_INVALID)
<a name="l00499"></a>00499   {
<a name="l00500"></a>00500     <span class="keywordflow">return</span>;
<a name="l00501"></a>00501   }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503   cnt = CDC_USB_TX_BUF_SIZ - 1 -
<a name="l00504"></a>00504         ((dmaCtrl &amp; _DMA_CTRL_N_MINUS_1_MASK) &gt;&gt; _DMA_CTRL_N_MINUS_1_SHIFT);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506   <span class="keywordflow">if</span> ((cnt == 0) &amp;&amp; (LastUsbTxCnt == CDC_BULK_EP_SIZE))
<a name="l00507"></a>00507   {
<a name="l00508"></a>00508     <span class="comment">/*</span>
<a name="l00509"></a>00509 <span class="comment">     * No activity on UART Rx, send a ZERO length USB package if last USB</span>
<a name="l00510"></a>00510 <span class="comment">     * USB package sent was CDC_BULK_EP_SIZE (max. EP size) long.</span>
<a name="l00511"></a>00511 <span class="comment">     */</span>
<a name="l00512"></a>00512     <span class="comment">/* Stop Rx DMA channel. */</span>
<a name="l00513"></a>00513     DMA-&gt;CHENC     = 1 &lt;&lt; CDC_UART_RX_DMA_CHANNEL;
<a name="l00514"></a>00514     dmaRxCompleted = <span class="keyword">false</span>;
<a name="l00515"></a>00515     <span class="comment">/* Call DMA completion callback. */</span>
<a name="l00516"></a>00516     DmaRxComplete(CDC_UART_RX_DMA_CHANNEL, <span class="keyword">true</span>, NULL);
<a name="l00517"></a>00517     <span class="keywordflow">return</span>;
<a name="l00518"></a>00518   }
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   <span class="keywordflow">if</span> ((cnt &gt; 0) &amp;&amp; (cnt == uartRxCount))
<a name="l00521"></a>00521   {
<a name="l00522"></a>00522     <span class="comment">/*</span>
<a name="l00523"></a>00523 <span class="comment">     * There is curently no activity on UART Rx but some chars have been</span>
<a name="l00524"></a>00524 <span class="comment">     * received. Stop DMA and transmit the chars we have got so far on USB.</span>
<a name="l00525"></a>00525 <span class="comment">     */</span>
<a name="l00526"></a>00526     <span class="comment">/* Stop Rx DMA channel. */</span>
<a name="l00527"></a>00527     DMA-&gt;CHENC     = 1 &lt;&lt; CDC_UART_RX_DMA_CHANNEL;
<a name="l00528"></a>00528     dmaRxCompleted = <span class="keyword">false</span>;
<a name="l00529"></a>00529     <span class="comment">/* Call DMA completion callback. */</span>
<a name="l00530"></a>00530     DmaRxComplete(CDC_UART_RX_DMA_CHANNEL, <span class="keyword">true</span>, NULL);
<a name="l00531"></a>00531     <span class="keywordflow">return</span>;
<a name="l00532"></a>00532   }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534   <span class="comment">/* Restart timer to continue monitoring. */</span>
<a name="l00535"></a>00535   uartRxCount = cnt;
<a name="l00536"></a>00536   USBTIMER_Start(CDC_TIMER_ID, CDC_RX_TIMEOUT, UartRxTimeout);
<a name="l00537"></a>00537 }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539 <span class="comment">/**************************************************************************/</span>
<a name="l00551"></a>00551 <span class="keyword">static</span> <span class="keywordtype">int</span> LineCodingReceived(USB_Status_TypeDef status,
<a name="l00552"></a>00552                               uint32_t xferred,
<a name="l00553"></a>00553                               uint32_t remaining)
<a name="l00554"></a>00554 {
<a name="l00555"></a>00555   uint32_t frame = 0;
<a name="l00556"></a>00556   (void) remaining;
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   <span class="comment">/* We have received new serial port communication settings from USB host. */</span>
<a name="l00559"></a>00559   <span class="keywordflow">if</span> ((status == USB_STATUS_OK) &amp;&amp; (xferred == 7))
<a name="l00560"></a>00560   {
<a name="l00561"></a>00561     <span class="comment">/* Check bDataBits, valid values are: 5, 6, 7, 8 or 16 bits. */</span>
<a name="l00562"></a>00562     <span class="keywordflow">if</span> (cdcLineCoding.bDataBits == 5)
<a name="l00563"></a>00563       frame |= USART_FRAME_DATABITS_FIVE;
<a name="l00564"></a>00564 
<a name="l00565"></a>00565     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bDataBits == 6)
<a name="l00566"></a>00566       frame |= USART_FRAME_DATABITS_SIX;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bDataBits == 7)
<a name="l00569"></a>00569       frame |= USART_FRAME_DATABITS_SEVEN;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bDataBits == 8)
<a name="l00572"></a>00572       frame |= USART_FRAME_DATABITS_EIGHT;
<a name="l00573"></a>00573 
<a name="l00574"></a>00574     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bDataBits == 16)
<a name="l00575"></a>00575       frame |= USART_FRAME_DATABITS_SIXTEEN;
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     <span class="keywordflow">else</span>
<a name="l00578"></a>00578       <span class="keywordflow">return</span> USB_STATUS_REQ_ERR;
<a name="l00579"></a>00579 
<a name="l00580"></a>00580     <span class="comment">/* Check bParityType, valid values are: 0=None 1=Odd 2=Even 3=Mark 4=Space  */</span>
<a name="l00581"></a>00581     <span class="keywordflow">if</span> (cdcLineCoding.bParityType == 0)
<a name="l00582"></a>00582       frame |= USART_FRAME_PARITY_NONE;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bParityType == 1)
<a name="l00585"></a>00585       frame |= USART_FRAME_PARITY_ODD;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bParityType == 2)
<a name="l00588"></a>00588       frame |= USART_FRAME_PARITY_EVEN;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bParityType == 3)
<a name="l00591"></a>00591       <span class="keywordflow">return</span> USB_STATUS_REQ_ERR;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bParityType == 4)
<a name="l00594"></a>00594       <span class="keywordflow">return</span> USB_STATUS_REQ_ERR;
<a name="l00595"></a>00595 
<a name="l00596"></a>00596     <span class="keywordflow">else</span>
<a name="l00597"></a>00597       <span class="keywordflow">return</span> USB_STATUS_REQ_ERR;
<a name="l00598"></a>00598 
<a name="l00599"></a>00599     <span class="comment">/* Check bCharFormat, valid values are: 0=1 1=1.5 2=2 stop bits */</span>
<a name="l00600"></a>00600     <span class="keywordflow">if</span> (cdcLineCoding.bCharFormat == 0)
<a name="l00601"></a>00601       frame |= USART_FRAME_STOPBITS_ONE;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bCharFormat == 1)
<a name="l00604"></a>00604       frame |= USART_FRAME_STOPBITS_ONEANDAHALF;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cdcLineCoding.bCharFormat == 2)
<a name="l00607"></a>00607       frame |= USART_FRAME_STOPBITS_TWO;
<a name="l00608"></a>00608 
<a name="l00609"></a>00609     <span class="keywordflow">else</span>
<a name="l00610"></a>00610       <span class="keywordflow">return</span> USB_STATUS_REQ_ERR;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     <span class="comment">/* Program new UART baudrate etc. */</span>
<a name="l00613"></a>00613     CDC_UART-&gt;FRAME = frame;
<a name="l00614"></a>00614     USART_BaudrateAsyncSet(CDC_UART, 0, cdcLineCoding.dwDTERate, usartOVS16);
<a name="l00615"></a>00615 
<a name="l00616"></a>00616     <span class="keywordflow">return</span> USB_STATUS_OK;
<a name="l00617"></a>00617   }
<a name="l00618"></a>00618   <span class="keywordflow">return</span> USB_STATUS_REQ_ERR;
<a name="l00619"></a>00619 }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621 <span class="comment">/**************************************************************************/</span>
<a name="l00624"></a>00624 <span class="keyword">static</span> <span class="keywordtype">void</span> DmaSetup(<span class="keywordtype">void</span>)
<a name="l00625"></a>00625 {
<a name="l00626"></a>00626   <span class="comment">/* DMA configuration structs. */</span>
<a name="l00627"></a>00627   DMA_Init_TypeDef       dmaInit;
<a name="l00628"></a>00628   DMA_CfgChannel_TypeDef chnlCfgTx, chnlCfgRx;
<a name="l00629"></a>00629   DMA_CfgDescr_TypeDef   descrCfgTx, descrCfgRx;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631   <span class="comment">/* Initialize the DMA. */</span>
<a name="l00632"></a>00632   dmaInit.hprot        = 0;
<a name="l00633"></a>00633   dmaInit.controlBlock = <a class="code" href="group__DmaCtrl.html#ga0fc5cf50e34b24c0883a6ef6dce0681c" title="DMA control block array, requires proper alignment.">dmaControlBlock</a>;
<a name="l00634"></a>00634   DMA_Init(&amp;dmaInit);
<a name="l00635"></a>00635 
<a name="l00636"></a>00636   <span class="comment">/*---------- Configure DMA channel for UART Tx. ----------*/</span>
<a name="l00637"></a>00637 
<a name="l00638"></a>00638   <span class="comment">/* Setup the interrupt callback routine */</span>
<a name="l00639"></a>00639   DmaTxCallBack.cbFunc  = DmaTxComplete;
<a name="l00640"></a>00640   DmaTxCallBack.userPtr = NULL;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642   <span class="comment">/* Setup the channel */</span>
<a name="l00643"></a>00643   chnlCfgTx.highPri   = <span class="keyword">false</span>;    <span class="comment">/* Can&#39;t use with peripherals. */</span>
<a name="l00644"></a>00644   chnlCfgTx.enableInt = <span class="keyword">true</span>;     <span class="comment">/* Interrupt needed when buffers are used. */</span>
<a name="l00645"></a>00645   chnlCfgTx.select    = CDC_TX_DMA_SIGNAL;
<a name="l00646"></a>00646   chnlCfgTx.cb        = &amp;DmaTxCallBack;
<a name="l00647"></a>00647   DMA_CfgChannel(CDC_UART_TX_DMA_CHANNEL, &amp;chnlCfgTx);
<a name="l00648"></a>00648 
<a name="l00649"></a>00649   <span class="comment">/* Setup channel descriptor. */</span>
<a name="l00650"></a>00650   <span class="comment">/* Destination is UART Tx data register and doesn&#39;t move. */</span>
<a name="l00651"></a>00651   descrCfgTx.dstInc = dmaDataIncNone;
<a name="l00652"></a>00652   descrCfgTx.srcInc = dmaDataInc1;
<a name="l00653"></a>00653   descrCfgTx.size   = dmaDataSize1;
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <span class="comment">/* We have time to arbitrate again for each sample. */</span>
<a name="l00656"></a>00656   descrCfgTx.arbRate = dmaArbitrate1;
<a name="l00657"></a>00657   descrCfgTx.hprot   = 0;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   <span class="comment">/* Configure primary descriptor. */</span>
<a name="l00660"></a>00660   DMA_CfgDescr(CDC_UART_TX_DMA_CHANNEL, <span class="keyword">true</span>, &amp;descrCfgTx);
<a name="l00661"></a>00661 
<a name="l00662"></a>00662   <span class="comment">/*---------- Configure DMA channel for UART Rx. ----------*/</span>
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <span class="comment">/* Setup the interrupt callback routine. */</span>
<a name="l00665"></a>00665   DmaRxCallBack.cbFunc  = DmaRxComplete;
<a name="l00666"></a>00666   DmaRxCallBack.userPtr = NULL;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668   <span class="comment">/* Setup the channel */</span>
<a name="l00669"></a>00669   chnlCfgRx.highPri   = <span class="keyword">false</span>;    <span class="comment">/* Can&#39;t use with peripherals. */</span>
<a name="l00670"></a>00670   chnlCfgRx.enableInt = <span class="keyword">true</span>;     <span class="comment">/* Interrupt needed when buffers are used. */</span>
<a name="l00671"></a>00671   chnlCfgRx.select    = CDC_RX_DMA_SIGNAL;
<a name="l00672"></a>00672   chnlCfgRx.cb        = &amp;DmaRxCallBack;
<a name="l00673"></a>00673   DMA_CfgChannel(CDC_UART_RX_DMA_CHANNEL, &amp;chnlCfgRx);
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="comment">/* Setup channel descriptor. */</span>
<a name="l00676"></a>00676   <span class="comment">/* Source is UART Rx data register and doesn&#39;t move. */</span>
<a name="l00677"></a>00677   descrCfgRx.dstInc = dmaDataInc1;
<a name="l00678"></a>00678   descrCfgRx.srcInc = dmaDataIncNone;
<a name="l00679"></a>00679   descrCfgRx.size   = dmaDataSize1;
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <span class="comment">/* We have time to arbitrate again for each sample. */</span>
<a name="l00682"></a>00682   descrCfgRx.arbRate = dmaArbitrate1;
<a name="l00683"></a>00683   descrCfgRx.hprot   = 0;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685   <span class="comment">/* Configure primary descriptor. */</span>
<a name="l00686"></a>00686   DMA_CfgDescr(CDC_UART_RX_DMA_CHANNEL, <span class="keyword">true</span>, &amp;descrCfgRx);
<a name="l00687"></a>00687 }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="comment">/**************************************************************************/</span>
<a name="l00692"></a>00692 <span class="keyword">static</span> <span class="keywordtype">void</span> SerialPortInit(<span class="keywordtype">void</span>)
<a name="l00693"></a>00693 {
<a name="l00694"></a>00694   USART_InitAsync_TypeDef init  = USART_INITASYNC_DEFAULT;
<a name="l00695"></a>00695 
<a name="l00696"></a>00696   <span class="comment">/* Configure GPIO pins. */</span>
<a name="l00697"></a>00697   CMU_ClockEnable(cmuClock_GPIO, <span class="keyword">true</span>);
<a name="l00698"></a>00698   <span class="comment">/* To avoid false start, configure output as high. */</span>
<a name="l00699"></a>00699   GPIO_PinModeSet(CDC_UART_TX_PORT, CDC_UART_TX_PIN, gpioModePushPull, 1);
<a name="l00700"></a>00700   GPIO_PinModeSet(CDC_UART_RX_PORT, CDC_UART_RX_PIN, gpioModeInput, 0);
<a name="l00701"></a>00701 
<a name="l00702"></a>00702   <span class="comment">/* Enable DK mainboard RS232/UART switch. */</span>
<a name="l00703"></a>00703   CDC_ENABLE_DK_UART_SWITCH();
<a name="l00704"></a>00704 
<a name="l00705"></a>00705   <span class="comment">/* Enable peripheral clocks. */</span>
<a name="l00706"></a>00706   CMU_ClockEnable(cmuClock_HFPER, <span class="keyword">true</span>);
<a name="l00707"></a>00707   CMU_ClockEnable(CDC_UART_CLOCK, <span class="keyword">true</span>);
<a name="l00708"></a>00708 
<a name="l00709"></a>00709   <span class="comment">/* Configure UART for basic async operation. */</span>
<a name="l00710"></a>00710   init.enable = usartDisable;
<a name="l00711"></a>00711   USART_InitAsync(CDC_UART, &amp;init);
<a name="l00712"></a>00712 
<a name="l00713"></a>00713   <span class="comment">/* Enable Tx/Rx pins and set correct UART location. */</span>
<a name="l00714"></a>00714   CDC_UART-&gt;ROUTE = CDC_UART_ROUTE;
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   <span class="comment">/* Finally enable it */</span>
<a name="l00717"></a>00717   USART_Enable(CDC_UART, usartEnable);
<a name="l00718"></a>00718 }
<a name="l00719"></a>00719 
</pre></div></div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Sep 7 09:26:01 2015</small> for Board Support Package by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
