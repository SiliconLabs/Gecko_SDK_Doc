<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Board Support Package: common/drivers/nandflash.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_c5ab7d5005c5f96afef39cd6ff9e2484.html">common</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_640347b79a58de25a4e6f9b018e8e1be.html">drivers</a>
  </div>
</div>
<div class="contents">
<h1>nandflash.c</h1><a href="nandflash_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**************************************************************************/</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;stddef.h&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;em_device.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;em_dma.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;em_ebi.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;<a class="code" href="dmactrl_8h.html" title="DMA control data block.">dmactrl.h</a>&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;<a class="code" href="nandflash_8h.html" title="EFM32GG_STK3700 nandflash driver.">nandflash.h</a>&quot;</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/**************************************************************************/</span>
<a name="l00042"></a>00042 <span class="comment">/* Define how NAND flash control signals is connected to the EFM32GG. */</span>
<a name="l00043"></a>00043 <span class="preprocessor">#define NAND_POWER_PORT         1</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#define NAND_POWER_PIN          (1 &lt;&lt; 15)</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#define NAND_READY_PORT         3</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">#define NAND_READY_PIN          (1 &lt;&lt; 15)</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CE_PORT            3</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CE_PIN             (1 &lt;&lt; 14)</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#define NAND_WP_PORT            3</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#define NAND_WP_PIN             (1 &lt;&lt; 13)</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#define NAND_ALE_BIT            24</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CLE_BIT            25</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="comment">/* Values secifically for Numonyx NAND256W3A. */</span>
<a name="l00055"></a>00055 <span class="preprocessor">#define NAND256W3A_SIGNATURE    0x7520</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#define NAND256W3A_SIZE         (32 * 1024 * 1024)</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#define NAND256W3A_PAGESIZE     512</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#define NAND256W3A_BLOCKSIZE    (16 * 1024)</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span>
<a name="l00060"></a>00060 <span class="comment">/* Generic NAND flash definitions. */</span>
<a name="l00061"></a>00061 <span class="preprocessor">#define NAND_PAGEADDR_MASK      (NAND256W3A_PAGESIZE - 1)</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#define NAND_BLOCKADDR_MASK     (NAND256W3A_BLOCKSIZE - 1)</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a>00064 <span class="preprocessor">#define NAND_RDA_CMD            0x00</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RDB_CMD            0x01</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RDC_CMD            0x50</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RDSIGN_CMD         0x90</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RDSTATUS_CMD       0x70</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#define NAND_PAGEPROG1_CMD      0x80</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="preprocessor">#define NAND_PAGEPROG2_CMD      0x10</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CPBPROG1_CMD       0x00</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CPBPROG2_CMD       0x8A</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CPBPROG3_CMD       0x10</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span><span class="preprocessor">#define NAND_BLOCKERASE1_CMD    0x60</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span><span class="preprocessor">#define NAND_BLOCKERASE2_CMD    0xD0</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="preprocessor">#define NAND_RST_CMD            0xFF</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span>
<a name="l00078"></a>00078 <span class="preprocessor">#define NAND_STATUS_SR7         0x80</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#define NAND_STATUS_SR6         0x40</span>
<a name="l00080"></a>00080 <span class="preprocessor"></span><span class="preprocessor">#define NAND_STATUS_SR0         0x01</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 <span class="comment">/* NAND access macros. */</span>
<a name="l00083"></a>00083 <span class="preprocessor">#define NAND_DATA8              *pNandData8</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#define NAND_DATA16             *pNandData16</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#define NAND_DATA32             *pNandData32</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span><span class="preprocessor">#define NAND_ADDR               *pNandAddr</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#define NAND_CMD                *pNandCmd</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span>
<a name="l00089"></a>00089 <span class="comment">/* DMA configuration structures. */</span>
<a name="l00090"></a>00090 <span class="keyword">static</span> <span class="keyword">const</span> DMA_Init_TypeDef dmaInit =
<a name="l00091"></a>00091 {
<a name="l00092"></a>00092   .hprot        = 0,
<a name="l00093"></a>00093   .controlBlock = <a class="code" href="group__DmaCtrl.html#ga0fc5cf50e34b24c0883a6ef6dce0681c" title="DMA control block array, requires proper alignment.">dmaControlBlock</a>
<a name="l00094"></a>00094 };
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="keyword">static</span> <span class="keyword">const</span> DMA_CfgChannel_TypeDef chnCfg =
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098   .highPri   = <span class="keyword">false</span>,     <span class="comment">/* Default priority */</span>
<a name="l00099"></a>00099   .enableInt = <span class="keyword">false</span>,     <span class="comment">/* No interrupt on transfer completion */</span>
<a name="l00100"></a>00100   .select    = 0,         <span class="comment">/* Memory-memory transfers */</span>
<a name="l00101"></a>00101   .cb        = NULL       <span class="comment">/* No transfer completion callback */</span>
<a name="l00102"></a>00102 };
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="keyword">static</span> <span class="keyword">const</span> DMA_CfgDescr_TypeDef descCfgWr =
<a name="l00105"></a>00105 {
<a name="l00106"></a>00106   .dstInc  = dmaDataIncNone,
<a name="l00107"></a>00107   .srcInc  = dmaDataInc4,
<a name="l00108"></a>00108   .size    = dmaDataSize4,
<a name="l00109"></a>00109   .arbRate = dmaArbitrate1,
<a name="l00110"></a>00110   .hprot   = 0
<a name="l00111"></a>00111 };
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="keyword">static</span> <span class="keyword">const</span> DMA_CfgDescr_TypeDef descCfgRd =
<a name="l00114"></a>00114 {
<a name="l00115"></a>00115   .dstInc  = dmaDataInc4,
<a name="l00116"></a>00116   .srcInc  = dmaDataIncNone,
<a name="l00117"></a>00117   .size    = dmaDataSize4,
<a name="l00118"></a>00118   .arbRate = dmaArbitrate1,
<a name="l00119"></a>00119   .hprot   = 0
<a name="l00120"></a>00120 };
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="comment">/* Private variables. */</span>
<a name="l00123"></a>00123 <span class="keyword">static</span> <a class="code" href="structNANDFLASH__Info__TypeDef.html" title="NANDFLASH device information structure.">NANDFLASH_Info_TypeDef</a> flashInfo;
<a name="l00124"></a>00124 <span class="keyword">static</span> <span class="keywordtype">bool</span>                   flashInitialized = <span class="keyword">false</span>;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126 <span class="keyword">static</span> uint8_t <span class="keyword">volatile</span>       *pNandData8;
<a name="l00127"></a>00127 <span class="keyword">static</span> uint16_t <span class="keyword">volatile</span>      *pNandData16;
<a name="l00128"></a>00128 <span class="keyword">static</span> uint32_t <span class="keyword">volatile</span>      *pNandData32;
<a name="l00129"></a>00129 <span class="keyword">static</span> uint8_t <span class="keyword">volatile</span>       *pNandAddr;
<a name="l00130"></a>00130 <span class="keyword">static</span> uint8_t <span class="keyword">volatile</span>       *pNandCmd;
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="comment">/* Private function prototypes. */</span>
<a name="l00133"></a>00133 __STATIC_INLINE <span class="keywordtype">void</span>      chipEnable(<span class="keywordtype">bool</span> enable);
<a name="l00134"></a>00134 <span class="keyword">static</span> <span class="keywordtype">int</span>       flashInterrogate(<span class="keywordtype">void</span>);
<a name="l00135"></a>00135 __STATIC_INLINE <span class="keywordtype">void</span>      powerEnable(<span class="keywordtype">bool</span> enable);
<a name="l00136"></a>00136 <span class="keyword">static</span> uint16_t  readSignature(<span class="keywordtype">void</span>);
<a name="l00137"></a>00137 <span class="keyword">static</span> uint8_t   readStatus(<span class="keywordtype">void</span>);
<a name="l00138"></a>00138 <span class="keyword">static</span> <span class="keywordtype">void</span>      reset(<span class="keywordtype">void</span>);
<a name="l00139"></a>00139 <span class="keyword">static</span> <span class="keywordtype">void</span>      dmaRead(uint8_t *dst, <span class="keywordtype">int</span> count);
<a name="l00140"></a>00140 <span class="keyword">static</span> <span class="keywordtype">void</span>      dmaWrite(uint8_t *src, <span class="keywordtype">int</span> count);
<a name="l00141"></a>00141 __STATIC_INLINE <span class="keywordtype">void</span>      waitReady(<span class="keywordtype">void</span>);
<a name="l00142"></a>00142 __STATIC_INLINE <span class="keywordtype">void</span>      writeProtect(<span class="keywordtype">bool</span> enable);
<a name="l00143"></a>00143 
<a name="l00146"></a>00146 <span class="comment">/***************************************************************************/</span>
<a name="l00156"></a><a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907">00156</a> <span class="keywordtype">bool</span> <a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(uint32_t address)
<a name="l00157"></a>00157 {
<a name="l00158"></a>00158   <span class="keywordflow">if</span> (flashInitialized)
<a name="l00159"></a>00159   {
<a name="l00160"></a>00160     <span class="keywordflow">if</span> ((address &gt;= flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a1ad0484a1860a34da353b54929de8810" title="The device base address in cpu memory map.">baseAddress</a>) &amp;&amp;
<a name="l00161"></a>00161         (address &lt; (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a1ad0484a1860a34da353b54929de8810" title="The device base address in cpu memory map.">baseAddress</a> + flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a50ce1667eeb1d371798ed0fff1a82b5c" title="Total device size in bytes.">deviceSize</a>)))
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00164"></a>00164     }
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00168"></a>00168 }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="comment">/***************************************************************************/</span>
<a name="l00188"></a><a class="code" href="group__NandFlash.html#ga89e673d7489781772b09cd59fae7f434">00188</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga89e673d7489781772b09cd59fae7f434" title="Copy a page within the device to a new location.">NANDFLASH_CopyPage</a>(uint32_t dstAddr, uint32_t srcAddr)
<a name="l00189"></a>00189 {
<a name="l00190"></a>00190   <span class="keywordtype">int</span> status;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00193"></a>00193   {
<a name="l00194"></a>00194     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00195"></a>00195     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00196"></a>00196   }
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   dstAddr &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00199"></a>00199   srcAddr &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00200"></a>00200 
<a name="l00201"></a>00201   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(dstAddr) ||
<a name="l00202"></a>00202       !<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(srcAddr) ||
<a name="l00203"></a>00203       <span class="comment">/* Address bit 24 must be equal for source and destination page. */</span>
<a name="l00204"></a>00204       ((dstAddr &amp; (1 &lt;&lt; 24)) != (srcAddr &amp; (1 &lt;&lt; 24))))
<a name="l00205"></a>00205   {
<a name="l00206"></a>00206     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00207"></a>00207     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00208"></a>00208   }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210   writeProtect(<span class="keyword">false</span>);
<a name="l00211"></a>00211   chipEnable(<span class="keyword">true</span>);
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   NAND_CMD  = NAND_CPBPROG1_CMD;
<a name="l00214"></a>00214   NAND_ADDR = (uint8_t) srcAddr;
<a name="l00215"></a>00215   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00216"></a>00216   NAND_ADDR = (uint8_t)(srcAddr &gt;&gt; 9);
<a name="l00217"></a>00217   NAND_ADDR = (uint8_t)(srcAddr &gt;&gt; 17);
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   waitReady();
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   NAND_CMD  = NAND_CPBPROG2_CMD;
<a name="l00222"></a>00222   NAND_ADDR = (uint8_t) dstAddr;
<a name="l00223"></a>00223   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00224"></a>00224   NAND_ADDR = (uint8_t)(dstAddr &gt;&gt; 9);
<a name="l00225"></a>00225   NAND_ADDR = (uint8_t)(dstAddr &gt;&gt; 17);
<a name="l00226"></a>00226   NAND_CMD  = NAND_CPBPROG3_CMD;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228   waitReady();
<a name="l00229"></a>00229 
<a name="l00230"></a>00230   status = (readStatus() &amp; NAND_STATUS_SR0) ?
<a name="l00231"></a>00231            <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ae747e446bff895ff1c9fe46e1db04c67" title="Nand flash write error, block is &amp;quot;bad&amp;quot;.">NANDFLASH_WRITE_ERROR</a> : <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   chipEnable(<span class="keyword">false</span>);
<a name="l00234"></a>00234   writeProtect(<span class="keyword">true</span>);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236   <span class="keywordflow">return</span> status;
<a name="l00237"></a>00237 }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="comment">/***************************************************************************/</span>
<a name="l00248"></a><a class="code" href="group__NandFlash.html#ga29aff61f11d96570357f048c5599f103">00248</a> <a class="code" href="structNANDFLASH__Info__TypeDef.html" title="NANDFLASH device information structure.">NANDFLASH_Info_TypeDef</a> *<a class="code" href="group__NandFlash.html#ga29aff61f11d96570357f048c5599f103" title="Return a pointer to a NANDFLASH_Info_TypeDef structure, which contain vital nand...">NANDFLASH_DeviceInfo</a>(<span class="keywordtype">void</span>)
<a name="l00249"></a>00249 {
<a name="l00250"></a>00250   <span class="keywordflow">if</span> (flashInitialized)
<a name="l00251"></a>00251   {
<a name="l00252"></a>00252     <span class="keywordflow">return</span> &amp;flashInfo;
<a name="l00253"></a>00253   }
<a name="l00254"></a>00254   <span class="keywordflow">return</span> NULL;
<a name="l00255"></a>00255 }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="comment">/***************************************************************************/</span>
<a name="l00275"></a><a class="code" href="group__NandFlash.html#ga5f05f548912d09981e531480b6802700">00275</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga5f05f548912d09981e531480b6802700" title="Check generated ECC against ECC read from device and correct data if possible.">NANDFLASH_EccCorrect</a>(uint32_t generatedEcc, uint32_t readEcc, uint8_t *data)
<a name="l00276"></a>00276 {
<a name="l00278"></a>00278 <span class="preprocessor">  #define ECC_MASK24    0x00FFFFFF          </span><span class="comment">/* 24 valid ECC parity bits. */</span>
<a name="l00279"></a>00279 <span class="preprocessor">  #define ECC_MASK      0x00555555          </span><span class="comment">/* 12 ECC parity bits.       */</span>
<a name="l00280"></a>00280 
<a name="l00282"></a>00282   <span class="keywordtype">int</span>      count, bitNum, byteAddr;
<a name="l00283"></a>00283   uint32_t mask;
<a name="l00284"></a>00284   uint32_t syndrome;
<a name="l00285"></a>00285   uint32_t eccP;                            <span class="comment">/* 12 even ECC parity bits. */</span>
<a name="l00286"></a>00286   uint32_t eccPn;                           <span class="comment">/* 12 odd ECC parity bits.  */</span>
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   syndrome = (generatedEcc ^ readEcc) &amp; ECC_MASK24;
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="keywordflow">if</span> (syndrome == 0)
<a name="l00291"></a>00291     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;             <span class="comment">/* No errors in data. */</span>
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   eccPn = syndrome &amp; ECC_MASK;              <span class="comment">/* Get twelve odd parity bits.  */</span>
<a name="l00294"></a>00294   eccP  = (syndrome &gt;&gt; 1) &amp; ECC_MASK;       <span class="comment">/* Get twelve even parity bits. */</span>
<a name="l00295"></a>00295 
<a name="l00296"></a>00296   <span class="keywordflow">if</span> ((eccPn ^ eccP) == ECC_MASK)           <span class="comment">/* 1-bit correctable error ? */</span>
<a name="l00297"></a>00297   {
<a name="l00298"></a>00298     bitNum = (eccP &amp; 0x01) |
<a name="l00299"></a>00299              ((eccP &gt;&gt; 1) &amp; 0x02) |
<a name="l00300"></a>00300              ((eccP &gt;&gt; 2) &amp; 0x04);
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     byteAddr = ((eccP &gt;&gt; 6) &amp; 0x001) |
<a name="l00303"></a>00303                ((eccP &gt;&gt; 7) &amp; 0x002) |
<a name="l00304"></a>00304                ((eccP &gt;&gt; 8) &amp; 0x004) |
<a name="l00305"></a>00305                ((eccP &gt;&gt; 9) &amp; 0x008) |
<a name="l00306"></a>00306                ((eccP &gt;&gt; 10) &amp; 0x010) |
<a name="l00307"></a>00307                ((eccP &gt;&gt; 11) &amp; 0x020) |
<a name="l00308"></a>00308                ((eccP &gt;&gt; 12) &amp; 0x040) |
<a name="l00309"></a>00309                ((eccP &gt;&gt; 13) &amp; 0x080) |
<a name="l00310"></a>00310                ((eccP &gt;&gt; 14) &amp; 0x100);
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     data[ byteAddr ] ^= 1 &lt;&lt; bitNum;
<a name="l00313"></a>00313 
<a name="l00314"></a>00314     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00315"></a>00315   }
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   <span class="comment">/* Count number of one&#39;s in the syndrome. */</span>
<a name="l00318"></a>00318   count = 0;
<a name="l00319"></a>00319   mask  = 0x00800000;
<a name="l00320"></a>00320   <span class="keywordflow">while</span> (mask)
<a name="l00321"></a>00321   {
<a name="l00322"></a>00322     <span class="keywordflow">if</span> (syndrome &amp; mask)
<a name="l00323"></a>00323       count++;
<a name="l00324"></a>00324     mask &gt;&gt;= 1;
<a name="l00325"></a>00325   }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327   <span class="keywordflow">if</span> (count == 1)                           <span class="comment">/* Error in the ECC itself. */</span>
<a name="l00328"></a>00328     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a015251afa4ae85548ba1239c4825d699" title="Illegal ECC value read from spare area.">NANDFLASH_ECC_ERROR</a>;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773af5863d48609dca796592be1a067e080f" title="Uncorrectable data error in page.">NANDFLASH_ECC_UNCORRECTABLE</a>;       <span class="comment">/* Unable to correct data. */</span>
<a name="l00331"></a>00331 
<a name="l00333"></a>00333 <span class="preprocessor">  #undef ECC_MASK</span>
<a name="l00334"></a>00334 <span class="preprocessor"></span><span class="preprocessor">  #undef ECC_MASK24</span>
<a name="l00335"></a>00335 <span class="preprocessor"></span>
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="comment">/***************************************************************************/</span>
<a name="l00353"></a><a class="code" href="group__NandFlash.html#gab6b041fc25f751a48aea91db3409f094">00353</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#gab6b041fc25f751a48aea91db3409f094" title="Erase a block in the nand flash.">NANDFLASH_EraseBlock</a>(uint32_t address)
<a name="l00354"></a>00354 {
<a name="l00355"></a>00355   <span class="keywordtype">int</span> status;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00358"></a>00358   {
<a name="l00359"></a>00359     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00360"></a>00360     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00361"></a>00361   }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363   address &amp;= ~NAND_BLOCKADDR_MASK;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00366"></a>00366   {
<a name="l00367"></a>00367     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00368"></a>00368     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00369"></a>00369   }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371   writeProtect(<span class="keyword">false</span>);
<a name="l00372"></a>00372   chipEnable(<span class="keyword">true</span>);
<a name="l00373"></a>00373 
<a name="l00374"></a>00374   NAND_CMD = NAND_BLOCKERASE1_CMD;
<a name="l00375"></a>00375   <span class="comment">/* Coloumn address, bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00376"></a>00376   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00377"></a>00377   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00378"></a>00378   NAND_CMD  = NAND_BLOCKERASE2_CMD;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   waitReady();
<a name="l00381"></a>00381 
<a name="l00382"></a>00382   status = (readStatus() &amp; NAND_STATUS_SR0) ?
<a name="l00383"></a>00383            <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ae747e446bff895ff1c9fe46e1db04c67" title="Nand flash write error, block is &amp;quot;bad&amp;quot;.">NANDFLASH_WRITE_ERROR</a> : <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   chipEnable(<span class="keyword">false</span>);
<a name="l00386"></a>00386   writeProtect(<span class="keyword">true</span>);
<a name="l00387"></a>00387 
<a name="l00388"></a>00388   <span class="keywordflow">return</span> status;
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="comment">/***************************************************************************/</span>
<a name="l00407"></a><a class="code" href="group__NandFlash.html#ga77237e34d1ad7e9ea927c64f77ec6e24">00407</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga77237e34d1ad7e9ea927c64f77ec6e24" title="Initialize the NANDFLASH module.">NANDFLASH_Init</a>(<span class="keywordtype">int</span> dmaCh)
<a name="l00408"></a>00408 {
<a name="l00409"></a>00409   <span class="keywordflow">if</span> ((dmaCh &lt; -1) || (dmaCh &gt;= DMA_CHAN_COUNT))
<a name="l00410"></a>00410   {
<a name="l00411"></a>00411     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00412"></a>00412     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a504fbafcb79cd7d9fc26007e6e3e6772" title="Invalid parameter to NANDFLASH_Init().">NANDFLASH_INVALID_SETUP</a>;
<a name="l00413"></a>00413   }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> = dmaCh;
<a name="l00416"></a>00416 
<a name="l00417"></a>00417   <span class="keywordflow">if</span> (dmaCh &gt;= 0)
<a name="l00418"></a>00418   {
<a name="l00419"></a>00419     DMA_Init((<span class="keywordtype">void</span>*) &amp;dmaInit);              <span class="comment">/* Initialize the DMA */</span>
<a name="l00420"></a>00420     DMA_CfgChannel(dmaCh, (<span class="keywordtype">void</span>*) &amp;chnCfg);  <span class="comment">/* Configure the DMA channel */</span>
<a name="l00421"></a>00421   }
<a name="l00422"></a>00422 
<a name="l00423"></a>00423   <span class="keywordflow">return</span> flashInterrogate();
<a name="l00424"></a>00424 }
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="comment">/***************************************************************************/</span>
<a name="l00442"></a><a class="code" href="group__NandFlash.html#gac4148bf559466d233cccf815adbeb95d">00442</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#gac4148bf559466d233cccf815adbeb95d" title="Mark a block as bad.">NANDFLASH_MarkBadBlock</a>(uint32_t address)
<a name="l00443"></a>00443 {
<a name="l00444"></a>00444   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00445"></a>00445   {
<a name="l00446"></a>00446     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00447"></a>00447     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00448"></a>00448   }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450   address &amp;= ~NAND_BLOCKADDR_MASK;
<a name="l00451"></a>00451 
<a name="l00452"></a>00452   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00453"></a>00453   {
<a name="l00454"></a>00454     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00455"></a>00455     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00456"></a>00456   }
<a name="l00457"></a>00457 
<a name="l00458"></a>00458   writeProtect(<span class="keyword">false</span>);
<a name="l00459"></a>00459   chipEnable(<span class="keyword">true</span>);
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   NAND_CMD  = NAND_RDC_CMD;
<a name="l00462"></a>00462   NAND_CMD  = NAND_PAGEPROG1_CMD;
<a name="l00463"></a>00463   NAND_ADDR = (uint8_t) address;
<a name="l00464"></a>00464   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDC_CMD. */</span>
<a name="l00465"></a>00465   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00466"></a>00466   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   <span class="comment">/* Write bad block marker 0x00 to the 6th byte in the spare area */</span>
<a name="l00469"></a>00469   NAND_DATA32 = 0xFFFFFFFF;
<a name="l00470"></a>00470   NAND_DATA16 = 0x00FF;
<a name="l00471"></a>00471   NAND_CMD    = NAND_PAGEPROG2_CMD;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473   waitReady();
<a name="l00474"></a>00474   readStatus();
<a name="l00475"></a>00475 
<a name="l00476"></a>00476   chipEnable(<span class="keyword">false</span>);
<a name="l00477"></a>00477   writeProtect(<span class="keyword">true</span>);
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00480"></a>00480 }
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="comment">/***************************************************************************/</span>
<a name="l00500"></a><a class="code" href="group__NandFlash.html#gac7c2bddd174fa07c8140b38c7584cc59">00500</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#gac7c2bddd174fa07c8140b38c7584cc59" title="Read a page from nand device.">NANDFLASH_ReadPage</a>(uint32_t address, uint8_t *buffer)
<a name="l00501"></a>00501 {
<a name="l00502"></a>00502   uint32_t i, readEcc, *p;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00505"></a>00505   {
<a name="l00506"></a>00506     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00507"></a>00507     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00508"></a>00508   }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510   address &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00511"></a>00511 
<a name="l00512"></a>00512   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00513"></a>00513   {
<a name="l00514"></a>00514     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00515"></a>00515     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00516"></a>00516   }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   chipEnable(<span class="keyword">true</span>);
<a name="l00519"></a>00519 
<a name="l00520"></a>00520   NAND_CMD  = NAND_RDA_CMD;
<a name="l00521"></a>00521   NAND_ADDR = (uint8_t) address;
<a name="l00522"></a>00522   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00523"></a>00523   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00524"></a>00524   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   waitReady();
<a name="l00527"></a>00527 
<a name="l00528"></a>00528   EBI_StartNandEccGen();
<a name="l00529"></a>00529 
<a name="l00530"></a>00530   <span class="keywordflow">if</span> (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> == -1)
<a name="l00531"></a>00531   {
<a name="l00532"></a>00532     p = (uint32_t*) buffer;
<a name="l00533"></a>00533     <span class="keywordflow">for</span> (i = 0; i &lt; flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a> / 4; i++)
<a name="l00534"></a>00534     {
<a name="l00535"></a>00535       *p++ = NAND_DATA32;
<a name="l00536"></a>00536     }
<a name="l00537"></a>00537   }
<a name="l00538"></a>00538   <span class="keywordflow">else</span>
<a name="l00539"></a>00539   {
<a name="l00540"></a>00540     dmaRead(buffer, flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a>);
<a name="l00541"></a>00541   }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a> = EBI_StopNandEccGen();
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="keywordflow">if</span> (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> == -1)
<a name="l00546"></a>00546   {
<a name="l00547"></a>00547     p = (uint32_t*) flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>;
<a name="l00548"></a>00548     for (i = 0; i &lt; flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a> / 4; i++)
<a name="l00549"></a>00549     {
<a name="l00550"></a>00550       *p++ = NAND_DATA32;
<a name="l00551"></a>00551     }
<a name="l00552"></a>00552   }
<a name="l00553"></a>00553   <span class="keywordflow">else</span>
<a name="l00554"></a>00554   {
<a name="l00555"></a>00555     dmaRead(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>, flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a>);
<a name="l00556"></a>00556   }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   chipEnable(<span class="keyword">false</span>);
<a name="l00559"></a>00559 
<a name="l00560"></a>00560   readEcc  = flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>[ <a class="code" href="group__NandFlash.html#ga68202c2af9400be750e866347c1ae77e" title="Spare area position of ECC byte 0 (LSB).">NAND_SPARE_ECC0_POS</a> ];
<a name="l00561"></a>00561   readEcc += flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>[ <a class="code" href="group__NandFlash.html#ga291ef2093c6334b58316c7eb96359cec" title="Spare area position of ECC byte 1.">NAND_SPARE_ECC1_POS</a> ] &lt;&lt; 8;
<a name="l00562"></a>00562   readEcc += flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#afcedb33282c21d6215a3460c1d730f1a" title="Spare area content from last read page or spare operation.">spare</a>[ <a class="code" href="group__NandFlash.html#ga0acc344f59146337478dd4099f7bef7c" title="Spare area position of ECC byte 2 (MSB).">NAND_SPARE_ECC2_POS</a> ] &lt;&lt; 16;
<a name="l00563"></a>00563 
<a name="l00564"></a>00564   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#ga5f05f548912d09981e531480b6802700" title="Check generated ECC against ECC read from device and correct data if possible.">NANDFLASH_EccCorrect</a>(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a>, readEcc, buffer);
<a name="l00565"></a>00565 }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="comment">/***************************************************************************/</span>
<a name="l00581"></a><a class="code" href="group__NandFlash.html#ga9a52019a2c065536e1c707aea6f27830">00581</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga9a52019a2c065536e1c707aea6f27830" title="Read the spare area content of a page.">NANDFLASH_ReadSpare</a>(uint32_t address, uint8_t *buffer)
<a name="l00582"></a>00582 {
<a name="l00583"></a>00583   uint32_t i, *p;
<a name="l00584"></a>00584 
<a name="l00585"></a>00585   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00586"></a>00586   {
<a name="l00587"></a>00587     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00588"></a>00588     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00589"></a>00589   }
<a name="l00590"></a>00590 
<a name="l00591"></a>00591   address &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00594"></a>00594   {
<a name="l00595"></a>00595     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00596"></a>00596     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00597"></a>00597   }
<a name="l00598"></a>00598 
<a name="l00599"></a>00599   chipEnable(<span class="keyword">true</span>);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   NAND_CMD  = NAND_RDC_CMD;
<a name="l00602"></a>00602   NAND_ADDR = (uint8_t) address;
<a name="l00603"></a>00603   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDC_CMD. */</span>
<a name="l00604"></a>00604   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00605"></a>00605   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   waitReady();
<a name="l00608"></a>00608 
<a name="l00609"></a>00609   <span class="keywordflow">if</span> (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> == -1)
<a name="l00610"></a>00610   {
<a name="l00611"></a>00611     p = (uint32_t*) buffer;
<a name="l00612"></a>00612     <span class="keywordflow">for</span> (i = 0; i &lt; flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a> / 4; i++)
<a name="l00613"></a>00613     {
<a name="l00614"></a>00614       *p++ = NAND_DATA32;
<a name="l00615"></a>00615     }
<a name="l00616"></a>00616   }
<a name="l00617"></a>00617   <span class="keywordflow">else</span>
<a name="l00618"></a>00618   {
<a name="l00619"></a>00619     dmaRead(buffer, flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a>);
<a name="l00620"></a>00620   }
<a name="l00621"></a>00621 
<a name="l00622"></a>00622   chipEnable(<span class="keyword">false</span>);
<a name="l00623"></a>00623 
<a name="l00624"></a>00624   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00625"></a>00625 }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627 <span class="comment">/***************************************************************************/</span>
<a name="l00646"></a><a class="code" href="group__NandFlash.html#ga1414ac5f995f6e37bef82297ff2f51a5">00646</a> <span class="keywordtype">int</span> <a class="code" href="group__NandFlash.html#ga1414ac5f995f6e37bef82297ff2f51a5" title="Write a page in nand device.">NANDFLASH_WritePage</a>(uint32_t address, uint8_t *buffer)
<a name="l00647"></a>00647 {
<a name="l00648"></a>00648   <span class="keywordtype">int</span>      status;
<a name="l00649"></a>00649   uint32_t i, *p;
<a name="l00650"></a>00650 
<a name="l00651"></a>00651   <span class="keywordflow">if</span> (!flashInitialized)
<a name="l00652"></a>00652   {
<a name="l00653"></a>00653     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00654"></a>00654     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ab8d069e1e61cae1f551dedeca98b56e2" title="Nand module has not been initialized.">NANDFLASH_NOT_INITIALIZED</a>;
<a name="l00655"></a>00655   }
<a name="l00656"></a>00656 
<a name="l00657"></a>00657   address &amp;= ~NAND_PAGEADDR_MASK;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   <span class="keywordflow">if</span> (!<a class="code" href="group__NandFlash.html#ga439db746d35d38bd98b554084bd15907" title="Check if an address is valid for the nand flash device.">NANDFLASH_AddressValid</a>(address))
<a name="l00660"></a>00660   {
<a name="l00661"></a>00661     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00662"></a>00662     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a8d605a0e6e4998814d4c4dfdba0323dd" title="Invalid nand flash address.">NANDFLASH_INVALID_ADDRESS</a>;
<a name="l00663"></a>00663   }
<a name="l00664"></a>00664 
<a name="l00665"></a>00665   writeProtect(<span class="keyword">false</span>);
<a name="l00666"></a>00666   chipEnable(<span class="keyword">true</span>);
<a name="l00667"></a>00667 
<a name="l00668"></a>00668   NAND_CMD  = NAND_RDA_CMD;
<a name="l00669"></a>00669   NAND_CMD  = NAND_PAGEPROG1_CMD;
<a name="l00670"></a>00670   NAND_ADDR = (uint8_t) address;
<a name="l00671"></a>00671   <span class="comment">/* Address bit 8 is not used, implicitely defined by NAND_RDA_CMD. */</span>
<a name="l00672"></a>00672   NAND_ADDR = (uint8_t)(address &gt;&gt; 9);
<a name="l00673"></a>00673   NAND_ADDR = (uint8_t)(address &gt;&gt; 17);
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="comment">/* Wait for EBI idle in case of EBI writeBuffer is enabled */</span>
<a name="l00676"></a>00676   <span class="keywordflow">while</span> (EBI-&gt;STATUS &amp; EBI_STATUS_AHBACT)
<a name="l00677"></a>00677   {
<a name="l00678"></a>00678   }
<a name="l00679"></a>00679   EBI_StartNandEccGen();
<a name="l00680"></a>00680 
<a name="l00681"></a>00681   <span class="keywordflow">if</span> (flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a> == -1)
<a name="l00682"></a>00682   {
<a name="l00683"></a>00683     p = (uint32_t*) buffer;
<a name="l00684"></a>00684     <span class="keywordflow">for</span> (i = 0; i &lt; flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a> / 4; i++)
<a name="l00685"></a>00685     {
<a name="l00686"></a>00686       NAND_DATA32 = *p++;
<a name="l00687"></a>00687     }
<a name="l00688"></a>00688   }
<a name="l00689"></a>00689   <span class="keywordflow">else</span>
<a name="l00690"></a>00690   {
<a name="l00691"></a>00691     dmaWrite(buffer, flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a>);
<a name="l00692"></a>00692   }
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   <span class="comment">/* Wait for EBI idle in case of EBI writeBuffer is enabled */</span>
<a name="l00695"></a>00695   <span class="keywordflow">while</span> (EBI-&gt;STATUS &amp; EBI_STATUS_AHBACT)
<a name="l00696"></a>00696   {
<a name="l00697"></a>00697   }
<a name="l00698"></a>00698   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a> = EBI_StopNandEccGen();
<a name="l00699"></a>00699 
<a name="l00700"></a>00700   <span class="comment">/* Write ECC to spare area */</span>
<a name="l00701"></a>00701   NAND_DATA32 = 0xFFFFFFFF;
<a name="l00702"></a>00702   NAND_DATA16 = 0xFFFF;
<a name="l00703"></a>00703   NAND_DATA8  = flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a>;
<a name="l00704"></a>00704   NAND_DATA8  = flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a> &gt;&gt; 8;
<a name="l00705"></a>00705   NAND_DATA8  = flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ac1f8aca107c0ee0aa8ebd67d151c1ff8" title="Result of ECC generation from last read/written page.">ecc</a> &gt;&gt; 16;
<a name="l00706"></a>00706   NAND_CMD    = NAND_PAGEPROG2_CMD;
<a name="l00707"></a>00707 
<a name="l00708"></a>00708   waitReady();
<a name="l00709"></a>00709 
<a name="l00710"></a>00710   status = (readStatus() &amp; NAND_STATUS_SR0) ?
<a name="l00711"></a>00711            <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773ae747e446bff895ff1c9fe46e1db04c67" title="Nand flash write error, block is &amp;quot;bad&amp;quot;.">NANDFLASH_WRITE_ERROR</a> : <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713   chipEnable(<span class="keyword">false</span>);
<a name="l00714"></a>00714   writeProtect(<span class="keyword">true</span>);
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   <span class="keywordflow">return</span> status;
<a name="l00717"></a>00717 }
<a name="l00718"></a>00718 
<a name="l00721"></a>00721 <span class="comment">/***************************************************************************/</span>
<a name="l00724"></a>00724 __STATIC_INLINE <span class="keywordtype">void</span> chipEnable(<span class="keywordtype">bool</span> enable)
<a name="l00725"></a>00725 {
<a name="l00726"></a>00726   <span class="keywordflow">if</span> (enable)
<a name="l00727"></a>00727   {
<a name="l00728"></a>00728     GPIO-&gt;P[NAND_CE_PORT].DOUTCLR = NAND_CE_PIN;
<a name="l00729"></a>00729   }
<a name="l00730"></a>00730   <span class="keywordflow">else</span>
<a name="l00731"></a>00731   {
<a name="l00732"></a>00732     GPIO-&gt;P[NAND_CE_PORT].DOUTSET = NAND_CE_PIN;
<a name="l00733"></a>00733   }
<a name="l00734"></a>00734 }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736 <span class="comment">/***************************************************************************/</span>
<a name="l00739"></a>00739 <span class="keyword">static</span> <span class="keywordtype">int</span> flashInterrogate(<span class="keywordtype">void</span>)
<a name="l00740"></a>00740 {
<a name="l00741"></a>00741   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a1ad0484a1860a34da353b54929de8810" title="The device base address in cpu memory map.">baseAddress</a> = EBI_BankAddress(EBI_BANK0);
<a name="l00742"></a>00742 
<a name="l00743"></a>00743   pNandData8  = (uint8_t <span class="keyword">volatile</span>*) flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a1ad0484a1860a34da353b54929de8810" title="The device base address in cpu memory map.">baseAddress</a>;
<a name="l00744"></a>00744   pNandData16 = (uint16_t <span class="keyword">volatile</span>*) pNandData8;
<a name="l00745"></a>00745   pNandData32 = (uint32_t <span class="keyword">volatile</span>*) pNandData8;
<a name="l00746"></a>00746   pNandAddr   = pNandData8 + (1 &lt;&lt; NAND_ALE_BIT);
<a name="l00747"></a>00747   pNandCmd    = pNandData8 + (1 &lt;&lt; NAND_CLE_BIT);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749   powerEnable(<span class="keyword">true</span>);
<a name="l00750"></a>00750   waitReady();
<a name="l00751"></a>00751   chipEnable(<span class="keyword">true</span>);
<a name="l00752"></a>00752   reset();
<a name="l00753"></a>00753 
<a name="l00754"></a>00754   <span class="keywordflow">if</span> (readSignature() != NAND256W3A_SIGNATURE)
<a name="l00755"></a>00755   {
<a name="l00756"></a>00756     EFM_ASSERT(<span class="keyword">false</span>);
<a name="l00757"></a>00757     <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6434929fd0044be49277f4b3c5b95d26" title="Invalid (unsupported) flash device.">NANDFLASH_INVALID_DEVICE</a>;
<a name="l00758"></a>00758   }
<a name="l00759"></a>00759 
<a name="l00760"></a>00760   chipEnable(<span class="keyword">false</span>);
<a name="l00761"></a>00761 
<a name="l00762"></a>00762   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a86fa0f38e71a4d26d3e5708c50f0e28b" title="The device manufacturer code.">manufacturerCode</a> = (uint8_t) NAND256W3A_SIGNATURE;
<a name="l00763"></a>00763   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a18af4ceede2c81c5139a20e68724b810" title="The device ID .">deviceCode</a>       = (uint8_t)(NAND256W3A_SIGNATURE &gt;&gt; 8);
<a name="l00764"></a>00764   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a50ce1667eeb1d371798ed0fff1a82b5c" title="Total device size in bytes.">deviceSize</a>       = NAND256W3A_SIZE;
<a name="l00765"></a>00765   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#af7dc70e21592c452a68e9a5e0ff5a528" title="Device page size in bytes.">pageSize</a>         = NAND256W3A_PAGESIZE;
<a name="l00766"></a>00766   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a7bd5dc10a7325e04a521231d1c4f1979" title="Device page spare size in bytes.">spareSize</a>        = <a class="code" href="group__NandFlash.html#gaa9340348b9962d9ef5c0adec85cf4009" title="Spare area size of Numonyx NAND256W3A.">NAND256W3A_SPARESIZE</a>;
<a name="l00767"></a>00767   flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#ad61a70b5bebfac7669e503164a0809b6" title="Device block size in bytes.">blockSize</a>        = NAND256W3A_BLOCKSIZE;
<a name="l00768"></a>00768 
<a name="l00769"></a>00769   flashInitialized = <span class="keyword">true</span>;
<a name="l00770"></a>00770 
<a name="l00771"></a>00771   <span class="keywordflow">return</span> <a class="code" href="group__NandFlash.html#gga1f0b4320b42b215cd63dac9ef5f70773a6b6589ecb6a873a559ee78eafd250a87" title="No errors detected.">NANDFLASH_STATUS_OK</a>;
<a name="l00772"></a>00772 }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 <span class="comment">/***************************************************************************/</span>
<a name="l00777"></a>00777 __STATIC_INLINE <span class="keywordtype">void</span> powerEnable(<span class="keywordtype">bool</span> enable)
<a name="l00778"></a>00778 {
<a name="l00779"></a>00779   <span class="keywordflow">if</span> (enable)
<a name="l00780"></a>00780   {
<a name="l00781"></a>00781     GPIO-&gt;P[NAND_POWER_PORT].DOUTSET = NAND_POWER_PIN;
<a name="l00782"></a>00782   }
<a name="l00783"></a>00783   <span class="keywordflow">else</span>
<a name="l00784"></a>00784   {
<a name="l00785"></a>00785     GPIO-&gt;P[NAND_POWER_PORT].DOUTCLR = NAND_POWER_PIN;
<a name="l00786"></a>00786   }
<a name="l00787"></a>00787 }
<a name="l00788"></a>00788 
<a name="l00789"></a>00789 <span class="comment">/***************************************************************************/</span>
<a name="l00792"></a>00792 <span class="keyword">static</span> uint16_t readSignature(<span class="keywordtype">void</span>)
<a name="l00793"></a>00793 {
<a name="l00794"></a>00794   NAND_CMD = NAND_RDSIGN_CMD;
<a name="l00795"></a>00795   <span class="keywordflow">return</span> NAND_DATA16;
<a name="l00796"></a>00796 }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798 <span class="comment">/***************************************************************************/</span>
<a name="l00801"></a>00801 <span class="keyword">static</span> uint8_t readStatus(<span class="keywordtype">void</span>)
<a name="l00802"></a>00802 {
<a name="l00803"></a>00803   NAND_CMD = NAND_RDSTATUS_CMD;
<a name="l00804"></a>00804   <span class="keywordflow">return</span> NAND_DATA8;
<a name="l00805"></a>00805 }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 <span class="comment">/***************************************************************************/</span>
<a name="l00810"></a>00810 <span class="keyword">static</span> <span class="keywordtype">void</span> reset(<span class="keywordtype">void</span>)
<a name="l00811"></a>00811 {
<a name="l00812"></a>00812   NAND_CMD = NAND_RST_CMD;
<a name="l00813"></a>00813   waitReady();
<a name="l00814"></a>00814 }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816 <span class="comment">/***************************************************************************/</span>
<a name="l00819"></a>00819 <span class="keyword">static</span> <span class="keywordtype">void</span> dmaRead(uint8_t *dst, <span class="keywordtype">int</span> count)
<a name="l00820"></a>00820 {
<a name="l00821"></a>00821   DMA_CfgDescr(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>, <span class="keyword">true</span>, (<span class="keywordtype">void</span>*) &amp;descCfgRd);
<a name="l00822"></a>00822   DMA_ActivateAuto(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>, <span class="keyword">true</span>, dst, (<span class="keywordtype">void</span>*) pNandData32, (count / 4) - 1);
<a name="l00823"></a>00823   <span class="keywordflow">while</span> ((<a class="code" href="group__DmaCtrl.html#ga0fc5cf50e34b24c0883a6ef6dce0681c" title="DMA control block array, requires proper alignment.">dmaControlBlock</a>[flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>].CTRL &amp; _DMA_CTRL_CYCLE_CTRL_MASK)
<a name="l00824"></a>00824          != DMA_CTRL_CYCLE_CTRL_INVALID)
<a name="l00825"></a>00825   {
<a name="l00826"></a>00826   }
<a name="l00827"></a>00827 }
<a name="l00828"></a>00828 
<a name="l00829"></a>00829 <span class="comment">/***************************************************************************/</span>
<a name="l00832"></a>00832 <span class="keyword">static</span> <span class="keywordtype">void</span> dmaWrite(uint8_t *src, <span class="keywordtype">int</span> count)
<a name="l00833"></a>00833 {
<a name="l00834"></a>00834   DMA_CfgDescr(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>, <span class="keyword">true</span>, (<span class="keywordtype">void</span>*) &amp;descCfgWr);
<a name="l00835"></a>00835   DMA_ActivateAuto(flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>, <span class="keyword">true</span>, (<span class="keywordtype">void</span>*) pNandData32, src, (count / 4) - 1);
<a name="l00836"></a>00836   <span class="keywordflow">while</span> ((<a class="code" href="group__DmaCtrl.html#ga0fc5cf50e34b24c0883a6ef6dce0681c" title="DMA control block array, requires proper alignment.">dmaControlBlock</a>[flashInfo.<a class="code" href="structNANDFLASH__Info__TypeDef.html#a8bd465d15390d99ec898ab23d9c8cbb6" title="The DMA channel used, -1 if DMA is not used.">dmaCh</a>].CTRL &amp; _DMA_CTRL_CYCLE_CTRL_MASK)
<a name="l00837"></a>00837          != DMA_CTRL_CYCLE_CTRL_INVALID)
<a name="l00838"></a>00838   {
<a name="l00839"></a>00839   }
<a name="l00840"></a>00840 }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 <span class="comment">/***************************************************************************/</span>
<a name="l00845"></a>00845 __STATIC_INLINE <span class="keywordtype">void</span> waitReady(<span class="keywordtype">void</span>)
<a name="l00846"></a>00846 {
<a name="l00847"></a>00847   <span class="comment">/* Wait for EBI idle in case of EBI writeBuffer is enabled */</span>
<a name="l00848"></a>00848   <span class="keywordflow">while</span> (EBI-&gt;STATUS &amp; EBI_STATUS_AHBACT)
<a name="l00849"></a>00849   {
<a name="l00850"></a>00850   }
<a name="l00851"></a>00851   <span class="comment">/* Wait on Ready/Busy pin to become high */</span>
<a name="l00852"></a>00852   <span class="keywordflow">while</span> ((GPIO-&gt;P[NAND_READY_PORT].DIN &amp; NAND_READY_PIN) == 0)
<a name="l00853"></a>00853   {
<a name="l00854"></a>00854   }
<a name="l00855"></a>00855 }
<a name="l00856"></a>00856 
<a name="l00857"></a>00857 <span class="comment">/***************************************************************************/</span>
<a name="l00860"></a>00860 __STATIC_INLINE <span class="keywordtype">void</span> writeProtect(<span class="keywordtype">bool</span> enable)
<a name="l00861"></a>00861 {
<a name="l00862"></a>00862   <span class="keywordflow">if</span> (enable)
<a name="l00863"></a>00863   {
<a name="l00864"></a>00864     GPIO-&gt;P[NAND_WP_PORT].DOUTCLR = NAND_WP_PIN;
<a name="l00865"></a>00865   }
<a name="l00866"></a>00866   <span class="keywordflow">else</span>
<a name="l00867"></a>00867   {
<a name="l00868"></a>00868     GPIO-&gt;P[NAND_WP_PORT].DOUTSET = NAND_WP_PIN;
<a name="l00869"></a>00869   }
<a name="l00870"></a>00870 }
<a name="l00871"></a>00871 
</pre></div></div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Sep 7 09:26:01 2015</small> for Board Support Package by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
