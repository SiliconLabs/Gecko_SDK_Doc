<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Board Support Package: Display</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Display<br/>
<small>
[<a class="el" href="group__Drivers.html">Drivers</a>]</small>
</h1>
<p><br/>
  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for Display:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__Display.png" border="0" alt="" usemap="#group____Display_map"/>
<map name="group____Display_map" id="group____Display">
<area shape="rect" id="node1" href="group__Drivers.html" title="Drivers" alt="" coords="6,5,69,32"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDISPLAY__Geometry__t.html">DISPLAY_Geometry_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display geometry specification.  <a href="structDISPLAY__Geometry__t.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDISPLAY__Device__t.html">DISPLAY_Device_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display device data structure, including a specification of how the display device behaves.  <a href="structDISPLAY__Device__t.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#gaa5cb853e3c35b188018b6d2f4c6c3889">DISPLAY_EMSTATUS_OK</a>&nbsp;&nbsp;&nbsp;(0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EMSTATUS codes of the display interface.  <a href="#gaa5cb853e3c35b188018b6d2f4c6c3889"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#gaabe27c6f9c511ac92eac044824e1c872">DISPLAY_EMSTATUS_NOT_ENOUGH_MEMORY</a>&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 1)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Not enough memory.  <a href="#gaabe27c6f9c511ac92eac044824e1c872"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#ga0defe5f0f1084825a66db88e778a247c">DISPLAY_EMSTATUS_OUT_OF_RANGE</a>&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameters out of range.  <a href="#ga0defe5f0f1084825a66db88e778a247c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#ga240d185bd6e0b6cd8853b8c78dd58a84">DISPLAY_EMSTATUS_INVALID_PARAMETER</a>&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 3)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invalid parameter.  <a href="#ga240d185bd6e0b6cd8853b8c78dd58a84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#gaf7615e11a85c3d937684d38134c5d40a">DISPLAY_EMSTATUS_NOT_SUPPORTED</a>&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 4)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Feature/option not supported.  <a href="#gaf7615e11a85c3d937684d38134c5d40a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#ga58856b40a639a3fbf48f29e973fc999c">DISPLAY_EMSTATUS_NOT_INITIALIZED</a>&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 5)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Feature/option not supported.  <a href="#ga58856b40a639a3fbf48f29e973fc999c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#ga8a775bf2210d707628d704572d9e1c98">DISPLAY_PixelMatrix_t</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pixel matrix handle.  <a href="#ga8a775bf2210d707628d704572d9e1c98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef EMSTATUS(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#ga48dd700724997f2d2ab4bff02fccf067">pDisplayDeviceDriverInitFunction_t</a> )(void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Display device driver init function pointer type.  <a href="#ga48dd700724997f2d2ab4bff02fccf067"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#ga582477144c2aad1388d54d6291e67107">DISPLAY_ColourMode_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__Display.html#gga582477144c2aad1388d54d6291e67107a2910774544083e2712c26216df0d9168">DISPLAY_COLOUR_MODE_MONOCHROME</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__Display.html#gga582477144c2aad1388d54d6291e67107ad56d271b8f1513162e2cb9e27f5098af">DISPLAY_COLOUR_MODE_MONOCHROME_INVERSE</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Display device colour modes. </p>
 <a href="group__Display.html#ga582477144c2aad1388d54d6291e67107">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#ga9bd101ffd5a8bdde4095b5b6e0f44cfc">DISPLAY_AddressMode_t</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__Display.html#gga9bd101ffd5a8bdde4095b5b6e0f44cfca1ccd9c1fe86bb016315d028c3e7c0b3d">DISPLAY_ADDRESSING_BY_ROWS_ONLY</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__Display.html#gga9bd101ffd5a8bdde4095b5b6e0f44cfca23fa7f2d52cb134a99bd309415e57339">DISPLAY_ADDRESSING_BY_ROWS_AND_COLUMNS</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Display device address modes. </p>
 <a href="group__Display.html#ga9bd101ffd5a8bdde4095b5b6e0f44cfc">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EMSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#gac24539de0b03459a9efdcd13b0954dc8">DISPLAY_Init</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the DISPLAY module.  <a href="#gac24539de0b03459a9efdcd13b0954dc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EMSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#gafa320dfc335fac0f70ca28fe8150b0de">DISPLAY_DriverRefresh</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refresh all DISPLAY devices.  <a href="#gafa320dfc335fac0f70ca28fe8150b0de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EMSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#ga156caca2b556cc968f8f4f106a68628a">DISPLAY_DeviceGet</a> (int displayDeviceNo, <a class="el" href="structDISPLAY__Device__t.html">DISPLAY_Device_t</a> *device)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the display device data structure corresponding to the device number.  <a href="#ga156caca2b556cc968f8f4f106a68628a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EMSTATUS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Display.html#ga2750609ed9e2a9f80719eb4025aa1842">DISPLAY_DeviceRegister</a> (<a class="el" href="structDISPLAY__Device__t.html">DISPLAY_Device_t</a> *device)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a display device.  <a href="#ga2750609ed9e2a9f80719eb4025aa1842"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><br/>
 </p>
<p>Display device driver stack library.</p>
<h2><a class="anchor" id="display_doc">
Display Device Driver Stack</a></h2>
<p>The source files for the DISPLAY device driver stack library resides in the kits/common/drivers directory and follows the naming convention: display<em>module_name</em>.c/h.</p>
<ul>
<li><a class="el" href="group__Display.html#display_intro">Introduction</a> </li>
<li><a class="el" href="group__Display.html#display_getting_started">Getting Started</a> </li>
<li><a class="el" href="group__Display.html#display_driver_programming">DISPLAY Device Driver Programming</a> </li>
<li><a class="el" href="group__Display.html#display_config_all">DISPLAY Device Driver Stack Configuration.</a></li>
</ul>
<p><br/>
 </p>
<h2><a class="anchor" id="display_intro">
Introduction</a></h2>
<p>The DISPLAY device driver stack implements a common API for different types of display devices. Thus making it easy to port applications between different hardware and software platforms. Additionally the DISPLAY device driver stack implements a Platform Abstraction Layer (PAL) in order to provide abstractions of hardware and software services needed by the specific display device drivers. Thus making it easy to port the DISPLAY device driver stack itself between different platforms.</p>
<p>The stack provides a configuration interface via dedicated configuration files in order to suit various application and platform requirements. Please refer to <a class="el" href="group__Display.html#display_config_all">DISPLAY Device Driver Stack Configuration.</a> for more information.</p>
<p>There are also several example programs in order to get you started fast.</p>
<p>We recommend that you read through this documentation, and then proceed to build and test a few example programs in order to get started.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="display_getting_started">
Getting Started</a></h2>
<p>This section contains brief descriptions of some of the functions in the API. You will find detailed information on input and output parameters and return values by clicking on the hyperlinked function names. It may also be a good idea to study the code in the example programs.</p>
<p>Your application code must include one header file, <em><a class="el" href="display_8h.html" title="Display device interface.">display.h</a></em>, which defines the user interface of the DISPLAY module which is common for all display devices.</p>
<p>The first step an application should do is to call the <em> <a class="el" href="group__Display.html#gac24539de0b03459a9efdcd13b0954dc8" title="Initialize the DISPLAY module.">DISPLAY_Init()</a> </em> function which initializes the DISPLAY driver stack. This includes calling the initialization functions of all registered display device drivers which will initialize the specific display device(s) and make them readily available through the DISPLAY interface defined in <a class="el" href="display_8h.html" title="Display device interface.">display.h</a>.</p>
<p>It is good practice that the user programmer checks the return value of the <a class="el" href="group__Display.html#gac24539de0b03459a9efdcd13b0954dc8" title="Initialize the DISPLAY module.">DISPLAY_Init()</a> call, and for the sake of it, all calls in of the DISPLAY device driver interface. All functions in the DISPLAY device driver interface return an <em>EMSTATUS</em> code which indicates whether the operation was successful or not, and what type of error may have occurred. The possible error codes are listed in <a class="el" href="display_8h.html" title="Display device interface.">display.h</a>.</p>
<p>The second step is typically to retrieve the properties of a DISPLAY device. This can be done by calling the <em> <a class="el" href="group__Display.html#ga156caca2b556cc968f8f4f106a68628a" title="Get the display device data structure corresponding to the device number.">DISPLAY_DeviceGet()</a> </em> function which receives the following two parameters: </p>
<ul>
<li><em> displayDeviceNo </em> which is a unique device number of one of the existing display devices in the system. Othen this value is zero because often there is just one display device in the system. </li>
<li><em> displayDevice </em> which is a pointer to a <em><a class="el" href="structDISPLAY__Device__t.html" title="Display device data structure, including a specification of how the display device...">DISPLAY_Device_t</a></em> structure which will be populated with the properties of the specified display device if the function is successful.</li>
</ul>
<p>If <em> <a class="el" href="group__Display.html#ga156caca2b556cc968f8f4f106a68628a" title="Get the display device data structure corresponding to the device number.">DISPLAY_DeviceGet()</a> </em> is successful, the specified <em> <a class="el" href="structDISPLAY__Device__t.html" title="Display device data structure, including a specification of how the display device...">DISPLAY_Device_t</a> </em> structure contains the properties of the display device. The properties include the <em> geometry </em> (<a class="el" href="structDISPLAY__Geometry__t.html">DISPLAY_Geometry_t</a>), the <em> colour mode </em> (<a class="el" href="group__Display.html#ga582477144c2aad1388d54d6291e67107">DISPLAY_ColourMode_t</a>) and the <em> address mode </em> (<a class="el" href="group__Display.html#ga9bd101ffd5a8bdde4095b5b6e0f44cfc">DISPLAY_AddressMode_t</a>) of the display device. Additionally the <em> <a class="el" href="structDISPLAY__Device__t.html" title="Display device data structure, including a specification of how the display device...">DISPLAY_Device_t</a> </em> structure contains function pointers to the device specific functions of the display device. The user should be aware that the device driver need not support all the function pointers of the <em> <a class="el" href="structDISPLAY__Device__t.html" title="Display device data structure, including a specification of how the display device...">DISPLAY_Device_t</a> </em> structure. Therefore the user should check if the function pointer is NULL before calling it.</p>
<p>The <em> pPixelMatrixDraw() </em> function is used to move and show the contents of a framebuffer (or pixel matrix buffer) onto the display device. A pixel matrix buffer is a 'partial' framebuffer which covers only part, or the whole, of the geometry of the display.</p>
<p>The format of the pixel data in the pixel matrix buffer is defined by the <a class="el" href="group__Display.html#ga582477144c2aad1388d54d6291e67107">DISPLAY_ColourMode_t</a>. At the time of writing only two colour modi are defined in <a class="el" href="group__Display.html#ga582477144c2aad1388d54d6291e67107">DISPLAY_ColourMode_t</a> : </p>
<ul>
<li>DISPLAY_COLOUR_MODE_MONOCHROME and </li>
<li>DISPLAY_COLOUR_MODE_MONOCHROME_INVERSE</li>
</ul>
<p>The DISPLAY_COLOUR_MODE_MONOCHROME mode defines a pixel bit value of 0 as white, and a pixel bit value of 1 as black. The DISPLAY_COLOUR_MODE_MONOCHROME_INVERSE mode is the opposite, and thus defines a pixel bit value of 0 as black, and a pixel bit value of 1 as white.</p>
<p>The pixel matrix buffer format for the monochrome modi is defined as a byte array where </p>
<ul>
<li>bit 0 of the 0th byte is pixel 0 on line 0, top left on the display, </li>
<li>bit 1 of the 0th byte is pixel 1 on line 0, </li>
<li>..., </li>
<li>bit 7 of the 15th byte is pixel 127 on line 0, </li>
<li>bit 0 of the 16th byte is pixel 0 on line 1, </li>
<li>..., </li>
<li>bit 7 of the 2047th byte is pixel 127 on line 127, bottom right on the display.</li>
</ul>
<p>Some device drivers may need/want to support a pixelMatrix allocation function, pointed to by <em> pPixelMatrixAllocate </em>, in order to handle device specific data structures related to the pixel matrix buffers. The pixel matrix buffers allocated with the <em> pPixelMatrixAllocate </em> function may also include control data/padding in order to accomodate for efficient use of the underlying hardware. If the <em> stride </em> member of <a class="el" href="structDISPLAY__Geometry__t.html">DISPLAY_Geometry_t</a> structure is bigger than the <em> width </em> member, the pixel matrix buffer contains such control data, and should not be overwritten by the user, unless the user knows how to handle this data (which is usually not necessary).</p>
<p>The user can make use of graphic libraries such as EMWIN and GLIB in order to draw graphical objects in the pixel matrix buffers. Please refer to the documentation of EMWIN and/or GLIB in reptile/emwin/src/Doc and reptile/glib respectively. The documentation of GLIB is embedded in the source code.</p>
<p>NOTE: There is an issue with EMWIN that does not allow drawing on framebuffers of size 128x128 which happens to the size of the Sharp Memory LCD model LS013B7DH03. The DISPLAY interface supports a workaround that allows the user to allocate bigger framebuffers (pixelMatrix buffers) by using the userStride parameter which is included in the DISPLAY interface when EMWIN_WORKAROUND is defined. Therefore, in order to use EMWIN on the LS013B7DH03, the user must define EMWIN_WORKAROUND (typically in displayconfigapp.h) and request a userStride of at least 160 bits, not 128 bits which is the real width (in pixels) of the LS013B7DH03.</p>
<p>The <em> pPixelMatrixClear </em> function clears the contents of the pixel matrix buffer by setting it all to the default background colour.</p>
<p>The <em> pDriverRefresh </em> function should be called if the system resources. e.g. bus clock frequency, has undergone any changes. The <em> pDriverRefresh </em> function will recalibrate internal parameters associated with the display devices.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="display_driver_programming">
DISPLAY Device Driver Programming</a></h2>
<p>This section contains a brief introduction to writing device drivers for specific display devices that can run properly in the DISPLAY device driver stack.</p>
<p>If you want to implement a new DISPLAY device driver, basically you need to implement an initialization function that populates a <em> <a class="el" href="structDISPLAY__Device__t.html" title="Display device data structure, including a specification of how the display device...">DISPLAY_Device_t</a> </em> data structure with the properties of the display device. At least the <em> geometry </em> <a class="el" href="structDISPLAY__Geometry__t.html">DISPLAY_Geometry_t</a>, the <em> colour mode </em> <a class="el" href="group__Display.html#ga582477144c2aad1388d54d6291e67107">DISPLAY_ColourMode_t</a>, the <em> address mode </em> <a class="el" href="group__Display.html#ga9bd101ffd5a8bdde4095b5b6e0f44cfc">DISPLAY_AddressMode_t</a>, and the <em> pPixelMatrixDraw </em> function must be implemented. Whether the rest of the device specific functions may need to be implemented depends on the type of display device and application requirements. Also, the device driver programmer should be aware that the upper layers and examples of the DISPLAY device driver stack does not support all types of display devices and is continually being updated for new display devices. Therefore the upper layers and examples may need to be updated in order for existing software to work with a new display device driver.</p>
<p>We recommend to study the existing DISPLAY device driver(s). At the time of writing this text, there exists only one DISPLAY device driver for the Sharp Memory LCD (model LS013B7DH03) implemented in <a class="el" href="displayls013b7dh03_8c.html" title="Display driver for the Sharp Memory LCD LS013B7DH03.">displayls013b7dh03.c</a>/h.</p>
<p>When the <em> <a class="el" href="structDISPLAY__Device__t.html" title="Display device data structure, including a specification of how the display device...">DISPLAY_Device_t</a> </em> data structure is properly populated it should be registered in the DISPLAY module by calling the <em> DISPLAY_DeviceRegister </em> function (declared in <a class="el" href="displaybackend_8h.html" title="Display device backend interface.">displaybackend.h</a>) with a pointer to the <a class="el" href="structDISPLAY__Device__t.html" title="Display device data structure, including a specification of how the display device...">DISPLAY_Device_t</a> structure as parameter. This will make the display device available via the DISPLAY interface which is used by existing upper layer modules, examples and applications directly.</p>
<p>In order to automatically initialize the new display device driver from withing the <em> DISPLAY_Init </em> function, the driver initialization function can be added to the list of initialization functions in <em> displayconfig.h </em>: </p>
<div class="fragment"><pre class="fragment">
// Define all display device driver initialization functions here.
#define DISPLAY_DEVICE_DRIVER_INIT_FUNCTIONS \
  {                                          \
    DISPLAY_Ls013b7dh03Init,                 \
    NULL                                     \
  }
  </pre></div><p>The <em> displayconfig.h </em> file should also include #define inclusion constants for the specific display device drivers included in the system. Typically there is only one display device, however some systems may add more than one display devices if present.</p>
<p>Additionally, we recommended to implement a platform abstraction layer in order to facilitate for easy porting of the display device driver between different hardware and software platforms. The <em> <a class="el" href="displaypal_8h.html" title="Platform Abstraction Layer (PAL) interface for DISPLAY driver.">displaypal.h</a> </em> file declares an interface that abstracts the platform specifics required by the Sharp Memory LCD (model LS013B7DH03) device driver implemented in <a class="el" href="displayls013b7dh03_8c.html" title="Display driver for the Sharp Memory LCD LS013B7DH03.">displayls013b7dh03.c</a>. And <a class="el" href="displaypalemlib_8c.html" title="Platform Abstraction Layer (PAL) for DISPLAY driver on EMLIB based platforms.">displaypalemlib.c</a> implements the PAL functions on top of EMLIB. A new device driver may need additional hardware and software services and the <a class="el" href="displaypal_8h.html" title="Platform Abstraction Layer (PAL) interface for DISPLAY driver.">displaypal.h</a> can be extended to support any such device.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="display_config_all">
DISPLAY Device Driver Stack Configuration.</a></h2>
<p>This section contains a description of the configuration interface of the DISPLAY device driver stack. The configuraion interface consists of a set of configuration files: </p>
<ul>
<li>One for each module in the DISPLAY device driver stack, where the platform default configurations are specified. </li>
<li>One for each application called <em> displayconfigapp.h </em> in which the user can specify application specific configurations and override defaults if desired. </li>
<li>And one that ties everything together by including all configuration files, called <a class="el" href="displayconfigall_8h.html" title="Main configuration file for the DISPLAY driver software stack.">displayconfigall.h</a> (included in <a class="el" href="display_8h.html" title="Display device interface.">display.h</a>).</li>
</ul>
<p>Normally the application programmer just need to deal with the application specific configuration file <em> displayconfigapp.h </em> which typically should be minimalistic and easy to setup. Below is a list of the typical configuration parameters that the application programmer may need to relate to on a given platform/kit:</p>
<div class="fragment"><pre class="fragment">
#define PIXEL_MATRIX_ALLOC_SUPPORT
      Specifies whether the DISPLAY device driver stack should include
      support for allocation of pixel matrices. The user should be aware
      that this may pull in malloc which consumes a relatively large amount
      of memory which is typically not wanted on kits with small amount of
      RAM. The user can define USE_STATIC_PIXEL_MATRIX_POOL in order to
      avoid malloc from being used.

#define USE_STATIC_PIXEL_MATRIX_POOL
      Specifies to use a statically allocated buffer pool to allocate pixel
      matrix buffers from. The user can specify the size of the pixel matrix
      buffer pool with PIXEL_MATRIX_POOL_SIZE.
      NOTE:
      The allocator does not support free'ing pixel matrices. It allocates
      continuosly from the static pool without keeping track of the sizes of
      old allocations. I.e. this is a one-shot allocator, and the  user should
      allocate buffers once at the beginning of the program.

#define PIXEL_MATRIX_POOL_SIZE
      Specifies the size of the static pixel matrix buffer pool. The pool size
      is highly application dependent, and the application programmer should
      consider to minimize this on system with a small amount of RAM.

#define INCLUDE_TEXTDISPLAY_SUPPORT
      Specifies whether to include TEXTDISPLAY support which implements a
      line based text output terminal interface supporting the C language
      stdout (standard output) interface including functions like printf,
      puts, putchar, etc.  The application programmer must select only one
      of the following fonts.

#define TEXTDISPLAY_FONT_6x8
      Select a font which is 6 pixels wide and 8 pixels high, resulting in
      21 column and 16 lines on a 128x128 display.

#define TEXTDISPLAY_FONT_8x8
      Select a font which is 8 pixels wide and 8 pixels high, resulting in
      16 column and 16 lines on a 128x128 display.

#define TEXTDISPLAY_NUMBER_FONT_16x20
      Select a _NUMBERS_ONLY_ font which is 16 pixels wide and 20 pixels high,
      resulting in 8 column and 6 lines on a 128x128 display.
      Note that this font does not include letters. It includes only the
      number characters 0,1,2,3,4,5,6,7,8,9 and additionally the colon ':' sign.
      This font is used by the digital clock mode in the clock example on the
      Zero Gecko starting kit (EFM32ZG_STK3200).

#define INCLUDE_VIDEO_TERMINAL_ESCAPE_SEQUENCE_SUPPORT
      Include support for some VT52/VT100 escape sequences in order to move the
      cursor around the screen without clearing the existing characters. Please
      refer to the textdisplay.h file for a list of supported escape sequence
      codes.

#define RETARGETTEXTDISPLAY_SCROLL_MODE
      Set to 'true' to enable scroll mode on the text display device where
      stdout is retargeted. Set to 'false' to disable scroll mode.

#define RETARGETTEXTDISPLAY_LINE_FEED_MODE
      Set to 'true' to enable adding Carriage Return (CR) to Line Feed (LF)
      characters on the text display device where stdout is retargeted.
      Set to 'false' to disable line feed mode.

#define PAL_TIMER_REPEAT_FUNCTION
      Specify a function that can register a callback function to be called
      repeatedly at a given frequency. On some platforms, like the
      EFM32ZG_STK3200, the DISPLAY driver Platform Abstraction Layer (PAL)
      uses the RTC to time and toggle the EXTCOMIN pin of the Sharp memory
      LCD per default. However, some applications, like the clock example
      want to use the RTC to keep track of time, i.e. generate interrupt
      every second. Therefore such applications need to support a
      'timer repeat' service function in order to support the PAL and
      take control over the RTC on the application level. E.g. the clock
      example implements a function (RtcIntCallbackRegister)) that
      enables the PAL to register the callback function that needs to be
      called in order to toggle the EXTCOMIN pin.
  </pre></div><p>The rest of this section lists and describes the configuration parameters included in the module configuration files which are set to default values specific for the kit/platform. Each development kit from Silicon Labs that supports the DISPLAY Device driver stack includes a unique set of these configuration files in the kits/kit_name/config folder.</p>
<p><br/>
 </p>
<h3><a class="anchor" id="display_config">
DISPLAY Module Configuration</a></h3>
<p>This section includes descriptions of the configuration parameters for the DISPLAY Module specified in displayconfig.h.</p>
<div class="fragment"><pre class="fragment">
#define INCLUDE_DISPLAY_SHARP_LS013B7DH03
      Include support for the SHARP Memory LCD model LS013B7DH03.

#define DISPLAY_DEVICES_MAX
      Maximum number of display devices the display module is configured
      to support. This number may be increased if the system includes more
      than one display device. However, the number should be kept low in order
      to save memory.

#define DISPLAY0_WIDTH and DISPLAY0_HEIGHT
      Specifies the geometry of display device #0 in the system. (I.e. on the
      Zero Gecko Kit (EFM32ZG_STK3200) the Sharp Memory LCD is 128x128 pixels
      high and wide, the DISPLAY0_WIDTH and DISPLAY0_HEIGHT should be 128.
      These defines can be used to declare static framebuffers in the
      application in order to save extra memory consumed by malloc.

#define DISPLAY_DEVICE_DRIVER_INIT_FUNCTIONS
      Lists the display device driver initialization function to be called
      automaticallyt by &lt;em&gt; DISPLAY_Init &lt;/em&gt;.
  </pre></div><p><br/>
 </p>
<h3><a class="anchor" id="display_ls013b7dh03config">
Sharp Memory LCD Configuration</a></h3>
<p>This section includes descriptions of the configuration parameters for the Sharp Memory LCD Device Driver specified in displayls013b7dh03config.h.</p>
<div class="fragment"><pre class="fragment">
#define SHARP_MEMLCD_DEVICE_NAME
      Name of display device.

#define LCD_PORT_SCLK and LCD_PIN_SCLK
      Location of SPI clock pin.

#define LCD_PORT_SI and LCD_PIN_SI
      Location of SPI Slave Input pin.

#define LCD_PORT_SCS and LCD_PIN_SCS
      Location of SPI Chip Select pin.

#define LCD_PORT_EXTCOMIN and LCD_PIN_EXTCOMIN
      Location of External COM inversion signal pin.

#define LCD_PORT_DISP_SEL and LCD_PIN_DISP_SEL
      Location of Display on/off pin.

#define LCD_PORT_DISP_PWR and LCD_PIN_DISP_PWR
      Location of Display Power pin (if present on kit).

#define LCD_PORT_EXTMODE and LCD_PIN_EXTMODE
      Location of External COM inversion mode pin.

#define POLARITY_INVERSION_EXTCOMIN
      Select how LCD polarity inversion should be handled.
      If POLARITY_INVERSION_EXTCOMIN is defined, the EXTMODE pin is set to HIGH,
      and the polarity inversion is armed for every rising edge of the EXTCOMIN
      pin. The actual polarity inversion is triggered at the next transision of
      SCS. This mode is recommended because it causes less CPU and SPI load
      than the alternative mode, see below.
      If POLARITY_INVERSION_EXTCOMIN is undefined, the EXTMODE pin is set to
      LOW, and the polarity inversion is toggled by sending an SPI command.
      This mode causes more CPU and SPI load than using the EXTCOMIN pin mode.

#define POLARITY_INVERSION_EXTCOMIN_PAL_AUTO_TOGGLE
      Define POLARITY_INVERSION_EXTCOMIN_PAL_AUTO_TOGGLE if you want the PAL
      (Platform Abstraction Layer interface) to automatically toggle the
      EXTCOMIN pin.
      If the PAL_TIMER_REPEAT function is defined the EXTCOMIN toggling is
      handled by a timer repeat system, then
      POLARITY_INVERSION_EXTCOMIN_PAL_AUTO_TOGGLE should be undefined.
  </pre></div><p><br/>
 </p>
<h3><a class="anchor" id="display_palconfig">
PAL Configuration</a></h3>
<p>This section includes descriptions of the configuration parameters for the PAL (Platform Abstraction Layer) specified in displaypalconfig.h.</p>
<div class="fragment"><pre class="fragment">
     // The user should select one of the following as  RTC clock source.
#define PAL_RTC_CLOCK_LFXO
      Selects the LFXO oscillator as source for the RTC clock.

#define PAL_RTC_CLOCK_LFRCO
      Selects the LFRCO oscillator as source for the RTC clock.

#define PAL_RTC_CLOCK_ULFRCO
      Selects the ULFRCO oscillator as source for the RTC clock.

#define PAL_SPI_USART_UNIT
      Select which USART device to use as SPI interface.

#define PAL_SPI_USART_CLOCK
      Select which USART clock is used to clock the SPI interface.

#define PAL_SPI_USART_LOCATION
      Route location of the USART/SPI pins.

#define PAL_SPI_BAUDRATE
      Specifies the SPI baud rate.
  </pre></div><p><br/>
 </p>
<h3><a class="anchor" id="display_textdisplayconfig">
TEXTDISPLAY Configuration</a></h3>
<p>The configuration of the TEXTDISPLAY and RETARGETTEXTDISPLAY is described in <a class="el" href="group__Textdisplay.html#textdisplay_doc">TextDisplay Library</a> and <a class="el" href="group__RetargetIo.html#retargettextdisplay_doc">Retarget TextDisplay Module</a>.</p>
<p>See <a class="el" href="group__Display.html#display_doc">Display Device Driver Stack</a> for more information. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga240d185bd6e0b6cd8853b8c78dd58a84"></a><!-- doxytag: member="display.h::DISPLAY_EMSTATUS_INVALID_PARAMETER" ref="ga240d185bd6e0b6cd8853b8c78dd58a84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAY_EMSTATUS_INVALID_PARAMETER&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Invalid parameter. </p>

<p>Definition at line <a class="el" href="display_8h_source.html#l00050">50</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaabe27c6f9c511ac92eac044824e1c872"></a><!-- doxytag: member="display.h::DISPLAY_EMSTATUS_NOT_ENOUGH_MEMORY" ref="gaabe27c6f9c511ac92eac044824e1c872" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAY_EMSTATUS_NOT_ENOUGH_MEMORY&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Not enough memory. </p>

<p>Definition at line <a class="el" href="display_8h_source.html#l00048">48</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

<p>Referenced by <a class="el" href="display_8c_source.html#l00172">DISPLAY_DeviceRegister()</a>.</p>

</div>
</div>
<a class="anchor" id="ga58856b40a639a3fbf48f29e973fc999c"></a><!-- doxytag: member="display.h::DISPLAY_EMSTATUS_NOT_INITIALIZED" ref="ga58856b40a639a3fbf48f29e973fc999c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAY_EMSTATUS_NOT_INITIALIZED&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 5)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Feature/option not supported. </p>

<p>Definition at line <a class="el" href="display_8h_source.html#l00052">52</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

<p>Referenced by <a class="el" href="display_8c_source.html#l00139">DISPLAY_DeviceGet()</a>, <a class="el" href="display_8c_source.html#l00172">DISPLAY_DeviceRegister()</a>, and <a class="el" href="display_8c_source.html#l00097">DISPLAY_DriverRefresh()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf7615e11a85c3d937684d38134c5d40a"></a><!-- doxytag: member="display.h::DISPLAY_EMSTATUS_NOT_SUPPORTED" ref="gaf7615e11a85c3d937684d38134c5d40a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAY_EMSTATUS_NOT_SUPPORTED&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 4)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Feature/option not supported. </p>

<p>Definition at line <a class="el" href="display_8h_source.html#l00051">51</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa5cb853e3c35b188018b6d2f4c6c3889"></a><!-- doxytag: member="display.h::DISPLAY_EMSTATUS_OK" ref="gaa5cb853e3c35b188018b6d2f4c6c3889" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAY_EMSTATUS_OK&nbsp;&nbsp;&nbsp;(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>EMSTATUS codes of the display interface. </p>
<p>Operation successful. </p>

<p>Definition at line <a class="el" href="display_8h_source.html#l00047">47</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

<p>Referenced by <a class="el" href="display_8c_source.html#l00139">DISPLAY_DeviceGet()</a>, <a class="el" href="display_8c_source.html#l00172">DISPLAY_DeviceRegister()</a>, <a class="el" href="display_8c_source.html#l00097">DISPLAY_DriverRefresh()</a>, <a class="el" href="display_8c_source.html#l00064">DISPLAY_Init()</a>, <a class="el" href="retargettextdisplay_8c_source.html#l00047">RETARGET_TextDisplayInit()</a>, and <a class="el" href="textdisplay_8c_source.html#l00210">TEXTDISPLAY_New()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0defe5f0f1084825a66db88e778a247c"></a><!-- doxytag: member="display.h::DISPLAY_EMSTATUS_OUT_OF_RANGE" ref="ga0defe5f0f1084825a66db88e778a247c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISPLAY_EMSTATUS_OUT_OF_RANGE&nbsp;&nbsp;&nbsp;(DISPLAY_EMSTATUS_BASE | 2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parameters out of range. </p>

<p>Definition at line <a class="el" href="display_8h_source.html#l00049">49</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

<p>Referenced by <a class="el" href="display_8c_source.html#l00139">DISPLAY_DeviceGet()</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga8a775bf2210d707628d704572d9e1c98"></a><!-- doxytag: member="display.h::DISPLAY_PixelMatrix_t" ref="ga8a775bf2210d707628d704572d9e1c98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__Display.html#ga8a775bf2210d707628d704572d9e1c98">DISPLAY_PixelMatrix_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pixel matrix handle. </p>

<p>Definition at line <a class="el" href="display_8h_source.html#l00083">83</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga48dd700724997f2d2ab4bff02fccf067"></a><!-- doxytag: member="display.h::pDisplayDeviceDriverInitFunction_t" ref="ga48dd700724997f2d2ab4bff02fccf067" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EMSTATUS(* <a class="el" href="group__Display.html#ga48dd700724997f2d2ab4bff02fccf067">pDisplayDeviceDriverInitFunction_t</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Display device driver init function pointer type. </p>
<p>The displayconfig.h file includes a table that contains the default display devices to initialize. </p>

<p>Definition at line <a class="el" href="display_8h_source.html#l00165">165</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga9bd101ffd5a8bdde4095b5b6e0f44cfc"></a><!-- doxytag: member="display.h::DISPLAY_AddressMode_t" ref="ga9bd101ffd5a8bdde4095b5b6e0f44cfc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Display.html#ga9bd101ffd5a8bdde4095b5b6e0f44cfc">DISPLAY_AddressMode_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Display device address modes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9bd101ffd5a8bdde4095b5b6e0f44cfca1ccd9c1fe86bb016315d028c3e7c0b3d"></a><!-- doxytag: member="DISPLAY_ADDRESSING_BY_ROWS_ONLY" ref="gga9bd101ffd5a8bdde4095b5b6e0f44cfca1ccd9c1fe86bb016315d028c3e7c0b3d" args="" -->DISPLAY_ADDRESSING_BY_ROWS_ONLY</em>&nbsp;</td><td>
<p>Display device is addressed by rows only. </p>
<p>I.e. a full line of pixel data is required to update a single pixel. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9bd101ffd5a8bdde4095b5b6e0f44cfca23fa7f2d52cb134a99bd309415e57339"></a><!-- doxytag: member="DISPLAY_ADDRESSING_BY_ROWS_AND_COLUMNS" ref="gga9bd101ffd5a8bdde4095b5b6e0f44cfca23fa7f2d52cb134a99bd309415e57339" args="" -->DISPLAY_ADDRESSING_BY_ROWS_AND_COLUMNS</em>&nbsp;</td><td>
<p>Display device is addressed by both rows and columns. </p>
<p>I.e. single pixel updates is supported. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="display_8h_source.html#l00070">70</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga582477144c2aad1388d54d6291e67107"></a><!-- doxytag: member="display.h::DISPLAY_ColourMode_t" ref="ga582477144c2aad1388d54d6291e67107" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Display.html#ga582477144c2aad1388d54d6291e67107">DISPLAY_ColourMode_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Display device colour modes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga582477144c2aad1388d54d6291e67107a2910774544083e2712c26216df0d9168"></a><!-- doxytag: member="DISPLAY_COLOUR_MODE_MONOCHROME" ref="gga582477144c2aad1388d54d6291e67107a2910774544083e2712c26216df0d9168" args="" -->DISPLAY_COLOUR_MODE_MONOCHROME</em>&nbsp;</td><td>
<p>White = pixel bit value = 0, Black = pixel bit value = 1. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga582477144c2aad1388d54d6291e67107ad56d271b8f1513162e2cb9e27f5098af"></a><!-- doxytag: member="DISPLAY_COLOUR_MODE_MONOCHROME_INVERSE" ref="gga582477144c2aad1388d54d6291e67107ad56d271b8f1513162e2cb9e27f5098af" args="" -->DISPLAY_COLOUR_MODE_MONOCHROME_INVERSE</em>&nbsp;</td><td>
<p>Black = pixel bit value = 0, White = pixel bit value = 1. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="display_8h_source.html#l00060">60</a> of file <a class="el" href="display_8h_source.html">display.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga156caca2b556cc968f8f4f106a68628a"></a><!-- doxytag: member="display.h::DISPLAY_DeviceGet" ref="ga156caca2b556cc968f8f4f106a68628a" args="(int displayDeviceNo, DISPLAY_Device_t *device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EMSTATUS DISPLAY_DeviceGet </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>displayDeviceNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structDISPLAY__Device__t.html">DISPLAY_Device_t</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the display device data structure corresponding to the device number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>displayDeviceNo</em>&nbsp;</td><td>Unique device number of one of the display devices in the system.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>device</em>&nbsp;</td><td>Pointer to a <em><a class="el" href="structDISPLAY__Device__t.html" title="Display device data structure, including a specification of how the display device...">DISPLAY_Device_t</a></em> structure which will be populated with the properties of the specified display device if the function is successful.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EMSTATUS code of the operation. </dd></dl>

<p>Definition at line <a class="el" href="display_8c_source.html#l00139">139</a> of file <a class="el" href="display_8c_source.html">display.c</a>.</p>

<p>References <a class="el" href="display_8h_source.html#l00052">DISPLAY_EMSTATUS_NOT_INITIALIZED</a>, <a class="el" href="display_8h_source.html#l00047">DISPLAY_EMSTATUS_OK</a>, and <a class="el" href="display_8h_source.html#l00049">DISPLAY_EMSTATUS_OUT_OF_RANGE</a>.</p>

<p>Referenced by <a class="el" href="retargettextdisplay_8c_source.html#l00047">RETARGET_TextDisplayInit()</a>, and <a class="el" href="textdisplay_8c_source.html#l00210">TEXTDISPLAY_New()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__Display_ga156caca2b556cc968f8f4f106a68628a_icgraph.png" border="0" usemap="#group__Display_ga156caca2b556cc968f8f4f106a68628a_icgraph_map" alt=""></div>
<map name="group__Display_ga156caca2b556cc968f8f4f106a68628a_icgraph_map" id="group__Display_ga156caca2b556cc968f8f4f106a68628a_icgraph">
<area shape="rect" id="node3" href="group__RetargetIo.html#ga1f514c0ebfe9dd2c24f293be0edfaf9b" title="Initialize/retarget a TEXTDISPLAY device to receivie stdout(put)." alt="" coords="369,5,543,32"/><area shape="rect" id="node5" href="group__Textdisplay.html#ga0a9d10a115aa9baddd7c189f0d824570" title="Create a new text display device." alt="" coords="187,31,320,57"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga2750609ed9e2a9f80719eb4025aa1842"></a><!-- doxytag: member="displaybackend.h::DISPLAY_DeviceRegister" ref="ga2750609ed9e2a9f80719eb4025aa1842" args="(DISPLAY_Device_t *device)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EMSTATUS DISPLAY_DeviceRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structDISPLAY__Device__t.html">DISPLAY_Device_t</a> *&nbsp;</td>
          <td class="paramname"> <em>device</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a display device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>The display device structure which specifies the properties of the display.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EMSTATUS code of the operation. </dd></dl>

<p>Definition at line <a class="el" href="display_8c_source.html#l00172">172</a> of file <a class="el" href="display_8c_source.html">display.c</a>.</p>

<p>References <a class="el" href="display_8h_source.html#l00048">DISPLAY_EMSTATUS_NOT_ENOUGH_MEMORY</a>, <a class="el" href="display_8h_source.html#l00052">DISPLAY_EMSTATUS_NOT_INITIALIZED</a>, and <a class="el" href="display_8h_source.html#l00047">DISPLAY_EMSTATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="gafa320dfc335fac0f70ca28fe8150b0de"></a><!-- doxytag: member="display.h::DISPLAY_DriverRefresh" ref="gafa320dfc335fac0f70ca28fe8150b0de" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EMSTATUS DISPLAY_DriverRefresh </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Refresh all DISPLAY devices. </p>
<p>This function requests all DISPLAY device drivers to update their internal state with respect to system resource changes, like a bus clock frequency. This function may need to be called after system changes.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>EMSTATUS code of the operation. </dd></dl>

<p>Definition at line <a class="el" href="display_8c_source.html#l00097">97</a> of file <a class="el" href="display_8c_source.html">display.c</a>.</p>

<p>References <a class="el" href="display_8h_source.html#l00052">DISPLAY_EMSTATUS_NOT_INITIALIZED</a>, <a class="el" href="display_8h_source.html#l00047">DISPLAY_EMSTATUS_OK</a>, and <a class="el" href="display_8h_source.html#l00155">DISPLAY_Device_t::pDriverRefresh</a>.</p>

</div>
</div>
<a class="anchor" id="gac24539de0b03459a9efdcd13b0954dc8"></a><!-- doxytag: member="display.h::DISPLAY_Init" ref="gac24539de0b03459a9efdcd13b0954dc8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EMSTATUS DISPLAY_Init </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the DISPLAY module. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>EMSTATUS code of the operation. </dd></dl>

<p>Definition at line <a class="el" href="display_8c_source.html#l00064">64</a> of file <a class="el" href="display_8c_source.html">display.c</a>.</p>

<p>References <a class="el" href="display_8h_source.html#l00047">DISPLAY_EMSTATUS_OK</a>.</p>

</div>
</div>
</div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Sep 7 09:26:26 2015</small> for Board Support Package by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
