<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>EFM32 Giant Gecko Software Documentation: USB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EFM32 Giant Gecko Software Documentation
   &#160;<span id="projectnumber">efm32gg-doc-4.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="../../index.html"><span>Documentation&#160;Home</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__USB.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">USB</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>USB HOST and DEVICE protocol stacks. </p><pre class="fragment"></pre><p>. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__USB__COMMON"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__COMMON.html">USB_COMMON</a></td></tr>
<tr class="memdesc:group__USB__COMMON"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common parts for both HOST and DEVICE USB stacks, see <a class="el" href="group__USB.html">USB device stack library</a> and <a class="el" href="group__USB.html">USB host stack library</a> pages for device and host library documentation. </p><pre class="fragment"></pre><p>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__USB__DEVICE"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html">USB_DEVICE</a></td></tr>
<tr class="memdesc:group__USB__DEVICE"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB DEVICE protocol stack, see <a class="el" href="group__USB.html">USB device stack library</a> page for detailed documentation. </p><pre class="fragment"></pre><p>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__USB__HOST"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__HOST.html">USB_HOST</a></td></tr>
<tr class="memdesc:group__USB__HOST"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB HOST protocol stack, see <a class="el" href="group__USB.html">USB host stack library</a> page for detailed documentation. </p><pre class="fragment"></pre><p>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>


<h3><a class="anchor" id="usb_device"></a>USB device stack library</h3><div class="textblock">The source files for the USB device stack resides in the usb directory and follows the naming convention: em_usbd<em>nnn</em>.c/h.<ul>
<li><a class="el" href="group__USB.html#usb_device_intro">Introduction</a> </li>
<li><a class="el" href="group__USB.html#usb_device_api">The device stack API</a> </li>
<li><a class="el" href="group__USB.html#usb_device_conf">Configuring the device stack</a> </li>
<li><a class="el" href="group__USB.html#usb_device_powersave">Energy-saving modes</a> </li>
<li><a class="el" href="group__USB.html#usb_device_example1">Vendor unique device example application</a></li>
</ul>
<p><br />
 <h1><a class="anchor" id="usb_device_intro"></a>
Introduction</h1>
<p>The USB device protocol stack provides an API which makes it possible to create USB devices with a minimum of effort. The device stack supports control, bulk, interrupt and isochronous transfers.</p>
<p>The stack is highly configurable to suit various needs, it does also contain useful debugging features together with several demonstration projects to get you started fast.</p>
<p>We recommend that you read through this documentation, then proceed to build and test a few example projects before you start designing your own device.</p>
<p><br />
 </p>
<h1><a class="anchor" id="usb_device_api"></a>
The device stack API</h1>
<p>This section contains brief descriptions of the functions in the API. You will find detailed information on input and output parameters and return values by clicking on the hyperlinked function names. It is also a good idea to study the code in the USB demonstration projects.</p>
<p>Your application code must include one header file: <em><a class="el" href="em__usb_8h.html" title="USB protocol stack library API for EFM32/EZR32. ">em_usb.h</a></em>.</p>
<p>All functions defined in the API can be called from within interrupt handlers.</p>
<p>The USB stack use a hardware timer to keep track of time. TIMER0 is the default choice, refer to <a class="el" href="group__USB.html#usb_device_conf">Configuring the device stack</a> for other possibilities. Your application must not use the selected timer.</p>
<p><b>Pitfalls:</b><br />
 The USB peripheral will fill your receive buffers in quantities of WORD's (4 bytes). Transmit and receive buffers must be WORD aligned, in addition when allocating storage for receive buffers, round size up to next WORD boundary. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size for the relevant endpoint to avoid data corruption.</p>
<p>Transmit buffers passed to USBD_Write()  must be statically allocated because USBD_Write()  only initiates the transfer. When the host decide to actually perform the transfer, your data must be available.</p>
<p><br />
 <a class="el" href="group__USB__DEVICE.html#ga0e5f5bd847e7cc1c4c384bb6b7f0ce77">USBD_Init()</a> <br />
 This function is called to register your device and all its properties with the device stack. The application must fill in a <a class="el" href="structUSBD__Init__TypeDef.html">USBD_Init_TypeDef</a> structure prior to calling. Refer to <a class="el" href="group__USB.html#DeviceInitCallbacks">DeviceInitCallbacks</a> for the optional callback functions defined within this structure. When this function has been called your device is ready to be enumerated by the USB host.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga9e0a1cf705301d9e035feff27ea41cda">USBD_Read()</a>, <a class="el" href="group__USB__DEVICE.html#ga656c8d2935af97156bc0babdc43c32ee">USBD_Write()</a> <br />
 These functions initiate data transfers. <br />
  USBD_Read()  initiate a transfer of data <em>from</em> host <em>to</em> device (an <em>OUT</em> transfer in USB terminology). <br />
  USBD_Write()  initiate a transfer of data <em>from</em> device <em>to</em> host (an <em>IN</em> transfer).</p>
<p>When the USB host actually performs the transfer, your application will be notified by means of a callback function which you provide (optionally). Refer to <a class="el" href="group__USB.html#TransferCallback">TransferCallback</a> for details of the callback functionality.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga83f32dfa4f6a5d010e413967850c52b2">USBD_AbortTransfer()</a>, <a class="el" href="group__USB__DEVICE.html#ga325117af9b3a9ad1df068cf3b19dc1ba">USBD_AbortAllTransfers()</a> <br />
 These functions terminate transfers that are initiated, but has not yet taken place. If a transfer is initiated with USBD_Read()
    or USBD_Write(),  but the USB host never actually peform the transfers, these functions will deactivate the transfer setup to make the USB device endpoint hardware ready for new (and potentially) different transfers.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga71b9264662d74666e4b058984e3346e5">USBD_Connect()</a>, <a class="el" href="group__USB__DEVICE.html#ga2d952f8cf9bde552cfd5559ae47e70fc">USBD_Disconnect()</a> <br />
 These functions turns the data-line (D+ or D-) pullup on or off. They can be used to force reenumeration. It's good practice to delay at least one second between USBD_Disconnect() and USBD_Connect()  to allow the USB host to unload the currently active device driver.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga9eb41fa7508126bea30d672b777e250f">USBD_EpIsBusy()</a> <br />
 Check if an endpoint is busy.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga9bf435e62169bfb3ee0a43ef0e9d009d">USBD_StallEp()</a>, <a class="el" href="group__USB__DEVICE.html#gacb0ed1c21fd4aecfe96060ea87a617a8">USBD_UnStallEp()</a> <br />
 These functions stalls or un-stalls an endpoint. This functionality may not be needed by your application, but the USB device stack use them in response to standard setup commands SET_FEATURE and CLEAR_FEATURE. They may be useful when implementing some USB classes, e.g. a mass storage device use them extensively.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga9fb12718f509c578656e4fc08bc40f69">USBD_RemoteWakeup()</a> <br />
 Used in SUSPENDED state (see <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>) to signal resume to host. It's the applications responsibility to adhere to the USB standard which states that a device can not signal resume before it has been SUSPENDED for at least 5 ms. The function will also check the configuration descriptor defined by the application to see if it is legal for the device to signal resume.</p>
<p><a class="el" href="group__USB__DEVICE.html#gab4e55bb0aacaa90aab28a79e9b131b0f">USBD_GetUsbState()</a> <br />
 Returns the device USB state (see <a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a>). Refer to Figure 9-1. "Device State Diagram" in the USB revision 2.0 specification.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga7c151fd9cf5ab159d8a74cf65a27975f">USBD_GetUsbStateName()</a> <br />
 Returns a text string naming a given USB device state.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga958a83c23eaa9fd51672808ac7c3fa65">USBD_SafeToEnterEM2()</a> <br />
 Check if it is ok to enter energy mode EM2. Refer to the <a class="el" href="group__USB.html#usb_device_powersave">Energy-saving modes</a> section for more information.</p>
<p><br />
 <a class="anchor" id="TransferCallback"></a><b>The transfer complete callback function:</b> <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#ga2fa15407a4ef650bbd9f69dbddad6977" title="USB transfer callback function. ">USB_XferCompleteCb_TypeDef()</a> is called when a transfer completes. It is called with three parameters, the status of the transfer, the number of bytes transferred and the number of bytes remaining. It may not always be needed to have a callback on transfer completion, but you should keep in mind that a transfer may be aborted when you least expect it. A transfer will be aborted if host stalls the endpoint, if host resets your device, if host unconfigures your device or if you unplug your device cable and the device is selfpowered.  USB_XferCompleteCb_TypeDef()  is also called if your application use USBD_AbortTransfer() or USBD_AbortAllTransfers()
     calls. </p><dl class="section note"><dt>Note</dt><dd>This callback is called from within an interrupt handler with interrupts disabled.</dd></dl>
<p><br />
 <a class="anchor" id="DeviceInitCallbacks"></a><b>Optional callbacks passed to the stack via the <a class="el" href="group__USB__DEVICE.html#ga0e5f5bd847e7cc1c4c384bb6b7f0ce77">USBD_Init()</a> function:</b> <br />
 <br />
 These callbacks are all optional, and it is up to the application programmer to decide if the application needs the functionality they provide. </p><dl class="section note"><dt>Note</dt><dd>These callbacks are all called from within an interrupt handler with interrupts disabled.</dd></dl>
<p><a class="el" href="group__USB__DEVICE.html#ga34f1b34e168438a4d2b475bef5103820" title="USB Reset callback function. ">USBD_UsbResetCb_TypeDef()</a> is called each time reset signalling is sensed on the USB wire.</p>
<p><br />
 <a class="el" href="group__USB__DEVICE.html#ga6ed47bd813327a60229b6b9e90a331c0" title="USB Start Of Frame (SOF) interrupt callback function. ">USBD_SofIntCb_TypeDef()</a> is called with framenumber as a parameter on each SOF interrupt.</p>
<p><br />
 <a class="el" href="group__USB__DEVICE.html#ga437ac57b8fb58de07cf10ba94740b54a" title="USB State change callback function. ">USBD_DeviceStateChangeCb_TypeDef()</a> is called whenever the device state change. Useful for detecting e.g. SUSPENDED state change in order to reduce current consumption of buspowered devices. The USB HID keyboard example project has a good example on how to use this callback.</p>
<p><br />
 <a class="el" href="group__USB__DEVICE.html#ga8bb00f127c19df8b5b2ac421ae109082" title="USB power mode callback function. ">USBD_IsSelfPoweredCb_TypeDef()</a> is called by the device stack when host queries the device with a standard setup GET_STATUS command to check if the device is currently selfpowered or buspowered. This feature is only applicable on selfpowered devices which also works when only buspower is available.</p>
<p><br />
 <a class="el" href="group__USB__DEVICE.html#gaf94f2cac2cddd3cc081888cc0d98a3e5" title="USB setup request callback function. ">USBD_SetupCmdCb_TypeDef()</a> is called each time a setup command is received from host. Use this callback to override or extend the default handling of standard setup commands, and to implement class or vendor specific setup commands. The USB HID keyboard example project has a good example on how to use this callback.</p>
<p><br />
 <b>Utility functions:</b> <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#gac49ccf1d69a08567d1a5911b0312e735" title="Transmit a single char on the debug serial port. ">USB_PUTCHAR()</a> Transmit a single char on the debug serial port. <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#ga7276e056a2f6aeb99240f72529f41f8f" title="Transmit a zero terminated string on the debug serial port. ">USB_PUTS()</a> Transmit a zero terminated string on the debug serial port. <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb" title="Transmit &quot;printf&quot; formated data on the debug serial port. ">USB_PRINTF()</a> Transmit "printf" formated data on the debug serial port. <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#gaedc267ca571518980b7f7f4392386844" title="Return an error message string for a given error code. ">USB_GetErrorMsgString()</a> Return an error message string for a given error code. <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#ga543c505ec86acb344f7f0c00c55fc266" title="Format and print a text string given an error code, prepends an optional user supplied leader string...">USB_PrintErrorMsgString()</a> Format and print a text string given an error code, prepends an optional user supplied leader string. <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#gabb1c11cad365c7c3b99a3e7826035951" title="Active wait millisecond delay function. Can also be used inside interrupt handlers. ">USBTIMER_DelayMs()</a> Active wait millisecond delay function. Can also be used inside interrupt handlers. <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#gafef1ec052374683fb7f26c5d27645e2c" title="Active wait microsecond delay function. Can also be used inside interrupt handlers. ">USBTIMER_DelayUs()</a> Active wait microsecond delay function. Can also be used inside interrupt handlers. <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#ga21c87b800d87fd731173dd4f48f23c28" title="Activate the hardware timer used to pace the 1 millisecond timer system. ">USBTIMER_Init()</a> Initialize the timer system. Called by 
          USBD_Init(),  but your application must call it again to reinitialize whenever you change the HFPERCLK frequency. <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#gac2a406f16d989b04c4fc5b37d5c10b45" title="Start a timer. ">USBTIMER_Start()</a> Start a timer. You can configure the USB device stack to provide any number of timers. The timers have 1 ms resolution, your application is notified of timeout by means of a callback. <br />
 <br />
 <a class="el" href="group__USB__COMMON.html#gab73c922427cf0d509788a8063451703f" title="Stop a timer. ">USBTIMER_Stop()</a> Stop a timer.</p>
<p><br />
 </p>
<h1><a class="anchor" id="usb_device_conf"></a>
Configuring the device stack</h1>
<p>Your application must provide a header file named <em>usbconfig.h</em>. This file must contain the following #define's:<br />
 <br />
</p><pre class="fragment">#define USB_DEVICE       // Compile the stack for device mode.
#define NUM_EP_USED n    // Your application use 'n' endpoints in
                         // addition to endpoint 0. </pre><p><br />
 <em>usbconfig.h</em> may define the following items: <br />
 <br />
</p><pre class="fragment">#define NUM_APP_TIMERS n // Your application needs 'n' timers

#define DEBUG_USB_API    // Turn on API debug diagnostics.

// Some utility functions in the API needs printf. These
// functions have "print" in their name. This macro enables
// these functions.
#define USB_USE_PRINTF   // Enable utility print functions.

// Define a function for transmitting a single char on the serial port.
extern int RETARGET_WriteChar(char c);
#define USER_PUTCHAR  RETARGET_WriteChar

#define USB_TIMER USB_TIMERn  // Select which hardware timer the USB stack
                              // is allowed to use. Valid values are n=0,1,2...
                              // corresponding to TIMER0, TIMER1, ...
                              // If not specified, TIMER0 is used

#define USB_VBUS_SWITCH_NOT_PRESENT  // Hardware does not have a VBUS switch

#define USB_CORECLK_HFRCO   // Devices supporting crystal-less USB can use
                            // HFRCO as core clock, default is HFXO
</pre><p><br />
 You are strongly encouraged to start application development with DEBUG_USB_API turned on. When DEBUG_USB_API is turned on and USER_PUTCHAR is defined, useful debugging information will be output on the development kit serial port. Compiling with the DEBUG_EFM_USER flag will also enable all asserts in both <em>emlib</em> and in the USB stack. If asserts are enabled and USER_PUTCHAR defined, assert texts will be output on the serial port.</p>
<p>You application must include <em><a class="el" href="retargetserial_8c.html" title="Provide stdio retargeting to USART/UART or LEUART. ">retargetserial.c</a></em> if DEBUG_USB_API is defined and <em><a class="el" href="retargetio_8c.html" title="Provide stdio retargeting for all supported toolchains. ">retargetio.c</a></em> if USB_USE_PRINTF is defined. These files reside in the <em>drivers</em> directory in the software package for your development board. Refer to <a class="el" href="group__USB.html#usb_device_powersave">Energy-saving modes</a> for energy-saving mode configurations.</p>
<p><br />
 </p>
<h1><a class="anchor" id="usb_device_powersave"></a>
Energy-saving modes</h1>
<p>The device stack provides two energy saving levels. The first level is to set the USB peripheral in energy saving mode, the next level is to enter Energy Mode 2 (EM2). These energy saving modes can be applied when the device is suspended by the USB host, or when when the device is not connected to a USB host. In addition to this an application can use energy modes EM1 and EM2. There are no restrictions on when EM1 can be entered, EM2 can only be entered when the USB device is suspended or detached from host.</p>
<p>Energy-saving modes are selected with a #define in <em>usbconfig.h</em>, default selection is to not use any energy saving modes.<br />
 <br />
</p><pre class="fragment">#define USB_PWRSAVE_MODE (USB_PWRSAVE_MODE_ONSUSPEND | USB_PWRSAVE_MODE_ENTEREM2)</pre><p>There are three flags available, the flags can be or'ed together as shown above.</p>
<p><b>#define USB_PWRSAVE_MODE_ONSUSPEND</b><br />
 Set USB peripheral in low power mode on suspend.</p>
<p><b>#define USB_PWRSAVE_MODE_ONVBUSOFF</b><br />
 Set USB peripheral in low power mode when not attached to a host. This mode assumes that the internal voltage regulator is used and that the VREGI pin of the chip is connected to VBUS. This option can not be used with bus-powered devices.</p>
<p><b>#define USB_PWRSAVE_MODE_ENTEREM2</b><br />
 Enter EM2 when USB peripheral is in low power mode.</p>
<p>When the USB peripheral is set in low power mode, it must be clocked by a 32kHz clock. Both LFXO and LFRCO can be used, but only LFXO guarantee USB specification compliance. Selection is done with a #define in <em>usbconfig.h</em>.<br />
 <br />
</p><pre class="fragment">#define USB_USBC_32kHz_CLK   USB_USBC_32kHz_CLK_LFXO </pre><p> Two flags are available, <b>USB_USBC_32kHz_CLK_LFXO</b> and <b>USB_USBC_32kHz_CLK_LFRCO</b>. <b>USB_USBC_32kHz_CLK_LFXO</b> is selected by default.</p>
<p>The USB HID keyboard and Mass Storage device example projects demonstrate different energy-saving modes.</p>
<p><b>Example 1:</b> Leave all energy saving to the stack, the device enters EM2 on suspend and when detached from host. <br />
</p><pre class="fragment">In usbconfig.h:

#define USB_PWRSAVE_MODE (USB_PWRSAVE_MODE_ONSUSPEND | USB_PWRSAVE_MODE_ONVBUSOFF | USB_PWRSAVE_MODE_ENTEREM2)</pre><p><br />
 <b>Example 2:</b> Let the stack control energy saving in the USB periheral but let your application control energy modes EM1 and EM2. <br />
</p><pre class="fragment">In usbconfig.h:

#define USB_PWRSAVE_MODE (USB_PWRSAVE_MODE_ONSUSPEND | USB_PWRSAVE_MODE_ONVBUSOFF)

In application code:

if ( USBD_SafeToEnterEM2() )
  EMU_EnterEM2(true);
else
  EMU_EnterEM1(); </pre><p><br />
 </p>
<h1><a class="anchor" id="usb_device_example1"></a>
Vendor unique device example application</h1>
<p>This example represents the most simple USB device imaginable. It's purpose is to turn user LED's on or off under control of vendor unique setup commands. The device will rely on <em>libusb</em> device driver on the host, a host application <em>EFM32-LedApp.exe</em> is bundled with the example.</p>
<p>The main() is really simple ! <br />
 <br />
</p><pre class="fragment">#include "em_usb.h"

#include "descriptors.h"

int main( void )
{
  BSP_Init(BSP_INIT_DEFAULT); // Initialize DK board register access
  CMU_ClockSelectSet( cmuClock_HF, cmuSelect_HFXO );
  BSP_LedsSet(0);             // Turn off all LED's

  ConsoleDebugInit();         // Initialize UART for debug diagnostics

  USB_PUTS( "\nEFM32 USB LED Vendor Unique Device example\n" );

  USBD_Init( &amp;initstruct );   // GO !

  //When using a debugger it is pratical to uncomment the following three
  //lines to force host to re-enumerate the device.

  //USBD_Disconnect();
  //USBTIMER_DelayMs( 1000 );
  //USBD_Connect();

  for (;;) {}
} </pre><p><br />
 Configure the device stack in <em>usbconfig.h</em>: <br />
 <br />
</p><pre class="fragment">#define USB_DEVICE                        // Compile stack for device mode.

// **************************************************************************
**                                                                         **
** Specify number of endpoints used (in addition to EP0).                  **
**                                                                         **
*****************************************************************************
#define NUM_EP_USED 0                     // EP0 is the only endpoint used.

// **************************************************************************
**                                                                         **
** Configure serial port debug output.                                     **
**                                                                         **
*****************************************************************************
// Prototype a function for transmitting a single char on the serial port.
extern int RETARGET_WriteChar(char c);
#define USER_PUTCHAR RETARGET_WriteChar

// Enable debug diagnostics from API functions (illegal input params etc.)
#define DEBUG_USB_API </pre><p><br />
 Define device properties and fill in USB initstruct in <em>descriptors.h</em>: <br />
 <br />
</p><pre class="fragment">SL_ALIGN(4)
static const USB_DeviceDescriptor_TypeDef deviceDesc SL_ATTRIBUTE_ALIGN(4)=
{
  .bLength            = USB_DEVICE_DESCSIZE,
  .bDescriptorType    = USB_DEVICE_DESCRIPTOR,
  .bcdUSB             = 0x0200,
  .bDeviceClass       = 0xFF,
  .bDeviceSubClass    = 0,
  .bDeviceProtocol    = 0,
  .bMaxPacketSize0    = USB_FS_CTRL_EP_MAXSIZE,
  .idVendor           = 0x10C4,
  .idProduct          = 0x0001,
  .bcdDevice          = 0x0000,
  .iManufacturer      = 1,
  .iProduct           = 2,
  .iSerialNumber      = 3,
  .bNumConfigurations = 1
};

SL_ALIGN(4)
static const uint8_t configDesc[] SL_ATTRIBUTE_ALIGN(4)=
{
  // *** Configuration descriptor ***
  USB_CONFIG_DESCSIZE,            // bLength
  USB_CONFIG_DESCRIPTOR,          // bDescriptorType
  USB_CONFIG_DESCSIZE +           // wTotalLength (LSB)
  USB_INTERFACE_DESCSIZE,
  (USB_CONFIG_DESCSIZE +          // wTotalLength (MSB)
  USB_INTERFACE_DESCSIZE)&gt;&gt;8,
  1,                              // bNumInterfaces
  1,                              // bConfigurationValue
  0,                              // iConfiguration
  CONFIG_DESC_BM_RESERVED_D7 |    // bmAttrib: Self powered
  CONFIG_DESC_BM_SELFPOWERED,
  CONFIG_DESC_MAXPOWER_mA( 100 ), // bMaxPower: 100 mA

  // *** Interface descriptor ***
  USB_INTERFACE_DESCSIZE,         // bLength
  USB_INTERFACE_DESCRIPTOR,       // bDescriptorType
  0,                              // bInterfaceNumber
  0,                              // bAlternateSetting
  NUM_EP_USED,                    // bNumEndpoints
  0xFF,                           // bInterfaceClass
  0,                              // bInterfaceSubClass
  0,                              // bInterfaceProtocol
  0,                              // iInterface
};

STATIC_CONST_STRING_DESC_LANGID( langID, 0x04, 0x09 );
STATIC_CONST_STRING_DESC( iManufacturer, 'E','n','e','r','g','y',' ',       \
                                         'M','i','c','r','o',' ','A','S' );
STATIC_CONST_STRING_DESC( iProduct     , 'V','e','n','d','o','r',' ',       \
                                         'U','n','i','q','u','e',' ',       \
                                         'L','E','D',' ',                   \
                                         'D','e','v','i','c','e' );
STATIC_CONST_STRING_DESC( iSerialNumber, '0','0','0','0','0','0',           \
                                         '0','0','1','2','3','4' );

static const void * const strings[] =
{
  &amp;langID,
  &amp;iManufacturer,
  &amp;iProduct,
  &amp;iSerialNumber
};

// Endpoint buffer sizes
// 1 = single buffer, 2 = double buffering, 3 = tripple buffering ...
static const uint8_t bufferingMultiplier[ NUM_EP_USED + 1 ] = { 1 };

static const USBD_Callbacks_TypeDef callbacks =
{
  .usbReset        = NULL,
  .usbStateChange  = NULL,
  .setupCmd        = SetupCmd,
  .isSelfPowered   = NULL,
  .sofInt          = NULL
};

static const USBD_Init_TypeDef initstruct =
{
  .deviceDescriptor    = &amp;deviceDesc,
  .configDescriptor    = configDesc,
  .stringDescriptors   = strings,
  .numberOfStrings     = sizeof(strings)/sizeof(void*),
  .callbacks           = &amp;callbacks,
  .bufferingMultiplier = bufferingMultiplier
};  </pre><p><br />
 Now we have to implement vendor unique USB setup commands to control the LED's (see callbacks variable above). Notice that the buffer variable below is statically allocated because USBD_Write()  only initiates the transfer. When the host actually performs the transfer, the SetupCmd() function will have returned ! <br />
 <br />
 </p><pre class="fragment">#define VND_GET_LEDS 0x10
#define VND_SET_LED  0x11

static int SetupCmd( const USB_Setup_TypeDef *setup )
{
  int retVal;
  uint16_t leds;
  static uint32_t buffer;
  uint8_t *pBuffer = (uint8_t*)&amp;buffer;

  retVal = USB_STATUS_REQ_UNHANDLED;

  if ( setup-&gt;Type == USB_SETUP_TYPE_VENDOR )
  {
    switch ( setup-&gt;bRequest )
    {
      case VND_GET_LEDS:
      // ********************
        *pBuffer = BSP_LedsGet() &amp; 0x1F;
        retVal = USBD_Write( 0, pBuffer, setup-&gt;wLength, NULL );
        break;

      case VND_SET_LED:
      // ********************
        leds = DVK_getLEDs() &amp; 0x1F;
        if ( setup-&gt;wValue )
        {
          leds |= LED0 &lt;&lt; setup-&gt;wIndex;
        }
        else
        {
          leds &amp;= ~( LED0 &lt;&lt; setup-&gt;wIndex );
        }
        BSP_LedsSet( leds );
        retVal = USB_STATUS_OK;
        break;
    }
  }

  return retVal;
}</pre> </div>

<h3><a class="anchor" id="usb_host"></a>USB host stack library</h3><div class="textblock">The source files for the USB host stack resides in the usb directory and follows the naming convention: em_usbh<em>nnn</em>.c/h.<ul>
<li><a class="el" href="group__USB.html#usb_host_intro">Introduction</a> </li>
<li><a class="el" href="group__USB.html#usb_host_getting_started">Getting started</a> </li>
<li><a class="el" href="group__USB.html#usb_host_api">The host stack API</a> </li>
<li><a class="el" href="group__USB.html#usb_host_conf">Configuring the host stack</a></li>
</ul>
<p><br />
 <h1><a class="anchor" id="usb_host_intro"></a>
Introduction</h1>
<p>The USB host protocol stack provides an API which makes it possible to create USB hosts with a minimum of effort. The host stack supports control, bulk and interrupt transfers.</p>
<p>The stack is highly configurable to suit various needs, it does also contain useful debugging features together with several demonstration projects to get you started fast.</p>
<p>We recommend that you read through this documentation, then proceed to build and test a few example projects before you start designing your own USB host applications.</p>
<p><br />
 </p>
<h1><a class="anchor" id="usb_host_getting_started"></a>
Getting started</h1>
<p>To use an USB device, its pratical to divide the initial steps needed into : </p><ul>
<li><a class="el" href="group__USB.html#usb_device_connection">Device connection</a> </li>
<li><a class="el" href="group__USB.html#usb_device_enumeration">Device enumeration and configuration</a></li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="usb_device_connection"></a>
Device connection</h2>
<p>This framework can be used to establish a device connection. </p><pre class="fragment">// Initialize USB host stack
USBH_Init( &amp;is );

for (;;)
{
  // Wait for ever on device attachment

  // The second parameter is timeout in seconds, 0 means for ever
  if ( USBH_WaitForDeviceConnectionB( tmpBuf, 0 ) == USB_STATUS_OK )
  {

    // Device is now connected and ready for enumeration !

  }

  // Wait for disconnection
  while ( USBH_DeviceConnected() ){}

  // Disable USB peripheral, power down USB port.
  USBH_Stop();
}</pre><p><br />
 </p>
<h2><a class="anchor" id="usb_device_enumeration"></a>
Device enumeration and configuration</h2>
<p>This framework can be used to enumerate and activate the device. </p><pre class="fragment">  // Enumerate device, retrieve device and configuration descriptors from device
  USBH_QueryDeviceB( tmpBuf, sizeof( tmpBuf ), USBH_GetPortSpeed() );

  // Qualify the device
  if ( ( USBH_QGetDeviceDescriptor( tmpBuf )-&gt;idVendor  == 0x10C4               ) &amp;&amp;
       ( USBH_QGetDeviceDescriptor( tmpBuf )-&gt;idProduct == 0x0001               ) &amp;&amp;
       ( USBH_QGetDeviceDescriptor( tmpBuf )-&gt;bNumConfigurations == 1           ) &amp;&amp;
       ( USBH_QGetConfigurationDescriptor( tmpBuf, 0 )-&gt;bNumInterfaces  == 1    ) &amp;&amp;
       ( USBH_QGetInterfaceDescriptor(  tmpBuf, 0, 0 )-&gt;bInterfaceClass == 0xFF ) &amp;&amp;
       ( USBH_QGetInterfaceDescriptor(  tmpBuf, 0, 0 )-&gt;bNumEndpoints   == 2    )    )
  {
    // After having determined that the device is "our" device, it's time to
    // give it an USB address and activate the configuration.

    // Populate device and endpoint data structures with
    // data retrieved during enumeration.
    USBH_InitDeviceData( &amp;device, tmpBuf, ep, 2, USBH_GetPortSpeed() );

    USBH_SetAddressB( &amp;device, DEV_ADDR );
    USBH_SetConfigurationB( &amp;device, device.confDesc.bConfigurationValue );

    // Assign host channels to device endpoints
    USBH_AssignHostChannel( &amp;ep[ 0 ], 2 );
    USBH_AssignHostChannel( &amp;ep[ 1 ], 3 );

    // We are now ready to use the device !

  }</pre><p><br />
 </p>
<h1><a class="anchor" id="usb_host_api"></a>
The host stack API</h1>
<ul>
<li><a class="el" href="group__USB.html#usb_host_apiintro">Introduction</a> </li>
<li><a class="el" href="group__USB.html#usb_host_init">Top level control functions</a> </li>
<li><a class="el" href="group__USB.html#usb_host_transfer">USB transfer functions</a> </li>
<li><a class="el" href="group__USB.html#usb_host_ch9">USB Chapter 9 support functions</a> </li>
<li><a class="el" href="group__USB.html#usb_host_port">Host port control functions</a> </li>
<li><a class="el" href="group__USB.html#usb_host_enum">Enumeration and query functions</a> </li>
<li><a class="el" href="group__USB.html#usb_host_print">Utility functions</a></li>
</ul>
<p><br />
 </p>
<h2><a class="anchor" id="usb_host_apiintro"></a>
Introduction</h2>
<p>This section contains brief descriptions of all functions in the API. You will find detailed information on input and output parameters and return values by clicking on the hyperlinked function names. It is also a good idea to study the code in the USB demonstration projects.</p>
<p>Your application code must include one header file: <em><a class="el" href="em__usb_8h.html" title="USB protocol stack library API for EFM32/EZR32. ">em_usb.h</a></em>.</p>
<p>The functions in the API come in two flavours, they are either blocking or non-blocking. The blocking functions have an uppercase letter B at the end of the function name. Blocking functions can not be called when interrupts are disabled. Note that all API callback functions are called from within the USB peripheral interrupt handler with interrupts disabled.</p>
<p>The USB stack use a hardware timer to keep track of time. TIMER0 is the default choice, refer to <a class="el" href="group__USB.html#usb_host_conf">Configuring the host stack</a> for other possibilities. Your application must not use the selected timer.</p>
<p><b>Pitfalls:</b><br />
 An USB peripheral will fill host receive buffers in quantities of WORD's (4 bytes). When allocating storage for receive buffers, round size up to next WORD boundary. If it is possible that a device will send more data than host expects, round buffer size up to the next multiple of maxpacket size for the relevant endpoint to avoid buffer overflow. <br />
 Transmit and receive buffers must also be WORD aligned. Macros are available for allocating buffers, see <a class="el" href="group__USB__COMMON.html#ga6ebfcb1d36f8b5b124f2e3ec032a410c">UBUF</a> and <a class="el" href="group__USB__COMMON.html#gaa057d31fe63604d11d6cec2b2b75e30c">STATIC_UBUF</a>.</p>
<p>Transmit buffers passed to non-blocking transfer functions must be statically allocated because these functions do not have their own buffers. The data in the transmit buffers must be valid until the transfer completes, times out or fails.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usb_host_init"></a>
Top level control functions</h2>
<p><a class="el" href="group__USB__HOST.html#gaedb37814762148d4977bd0dbc1a9b46e">USBH_Init()</a> <br />
 Initial host stack initialization, call once in start of main().</p>
<p><a class="el" href="group__USB__HOST.html#ga154c6b268f2d39d4e1577f917e0da239">USBH_Stop()</a> <br />
 Terminates host operation, turns off VBUS.</p>
<p><a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB()</a> <br />
 Wait for device connection with optional timeout.</p>
<p><a class="el" href="group__USB__HOST.html#ga06f1146ad72c09a1ed1d9a9c4b98edb2">USBH_AssignHostChannel()</a> <br />
 Associate a device endpoint with a host channel.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usb_host_transfer"></a>
USB transfer functions</h2>
<p><a class="el" href="group__USB__HOST.html#ga0b43c59fc9d3c91d0039f761ef4d6333">USBH_ControlMsg()</a>, <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a> <br />
 Perform a non-blocking or blocking USB control message transfer.</p>
<p><a class="el" href="group__USB__HOST.html#ga3514adea6bc6da41b8a083153e3f9365">USBH_Read()</a>, <a class="el" href="group__USB__HOST.html#gab5829c1ebeed8cfd36317dd57c6584c9">USBH_ReadB()</a> <br />
 Perform a non-blocking or blocking USB IN data transfer. Data direction is <em>from</em> device <em>to</em> host.</p>
<p><a class="el" href="group__USB__HOST.html#ga0c9fcc6a9f2db01206c010330b6e41f6">USBH_Write()</a>, <a class="el" href="group__USB__HOST.html#ga27c7b3b7944f7f1b8e4327dd66fa7ff8">USBH_WriteB()</a> <br />
 Perform a non-blocking or blocking USB OUT data transfer. Data direction is <em>from</em> host <em>to</em> device.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usb_host_ch9"></a>
USB Chapter 9 support functions</h2>
<p>All Chapter 9 support functions are blocking with a timeout of 1 second.</p>
<p><a class="el" href="group__USB__HOST.html#gad09af4f14c4b205a9e159cb4c5fa7b8f">USBH_GetConfigurationDescriptorB()</a> <br />
 Read a configuration descriptor from a device.</p>
<p><a class="el" href="group__USB__HOST.html#ga2656404a391e6894b03dde7d42d11f4f">USBH_GetDeviceDescriptorB()</a> <br />
 Read a device descriptor from a device.</p>
<p><a class="el" href="group__USB__HOST.html#ga4e40f21d20e36116da7a45f4a8b7ee3c">USBH_GetStringB()</a> <br />
 Read a string descriptor from a device.</p>
<p><a class="el" href="group__USB__HOST.html#gac93ecf15f240abf7093506c8e8ef9e61">USBH_SetAddressB()</a> <br />
 Set new USB device address on device currently on USB address 0.</p>
<p><a class="el" href="group__USB__HOST.html#ga0f156ce4b8660203cf4957c019064d9f">USBH_SetAltInterfaceB()</a> <br />
 Set alternate interface on a device.</p>
<p><a class="el" href="group__USB__HOST.html#ga6938e5856e9d28116922070621be36a5">USBH_SetConfigurationB()</a> <br />
 Set device configuration.</p>
<p><a class="el" href="group__USB__HOST.html#ga547d9df531d791c90fd6f44d28e7089a">USBH_StallEpB()</a>, <a class="el" href="group__USB__HOST.html#gabf8fcc4a69080f3d1005d1bc21d44218">USBH_UnStallEpB()</a> <br />
 These functions stalls or un-stalls an endpoint. Uses USB standard requests SET_FEATURE and CLEAR_FEATURE.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usb_host_port"></a>
Host port control functions</h2>
<p><a class="el" href="group__USB__HOST.html#gaf791f134a36bb5376abaf59c45b84e84">USBH_DeviceConnected()</a> <br />
 Check if a device is connected on the USB host port.</p>
<p><a class="el" href="group__USB__HOST.html#gad011363a4aa7f78c702a361bcebe67fb">USBH_GetPortSpeed()</a> <br />
 Get the bus speed (low speed or full speed) of the device currently connected to the USB host port.</p>
<p><a class="el" href="group__USB__HOST.html#gac57479eb6271bc262a6652b50fd122ce">USBH_PortReset()</a> <br />
 Drive reset signalling on the USB host port.</p>
<p><a class="el" href="group__USB__HOST.html#gaa2cb3b486c0d628c23cce6a26984580b">USBH_PortResume()</a> <br />
 Drive resume signalling on the USB host port.</p>
<p><a class="el" href="group__USB__HOST.html#ga3b518bcdfa5c19f42a362736767f273c">USBH_PortSuspend()</a> <br />
 Set the USB host port in suspend mode.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usb_host_enum"></a>
Enumeration and query functions</h2>
<p><a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a> <br />
 This function will read the device and configuration descriptors from a device at USB address 0. The application must allocate a buffer of sufficent size to hold the data. This data buffer can later be used by all USBH_Q<em>xxx</em> functions to retrieve pointers to any descriptor within any configuration descriptor. Data retrieved by this function must also be passed to USBH_InitDeviceData()
         before normal device communication can start. Ref. section <a class="el" href="group__USB.html#usb_device_enumeration">Device enumeration and configuration</a>.</p>
<p><a class="el" href="group__USB__HOST.html#ga2ac91d938f8553e31913afdb8d8d80dc">USBH_QGetConfigurationDescriptor()</a> <br />
 Get a pointer to a given configuration descriptor. Parses through a data buffer which must have been previously populated by a call to  USBH_QueryDeviceB() . </p><pre class="fragment">  @ref USBH_QGetDeviceDescriptor() @n
    Get a pointer to the device descriptor. Parses through a data buffer
    which must have been previously populated by a call to@htmlonly 
    USBH_QueryDeviceB() @endhtmlonly.

  @ref USBH_QGetEndpointDescriptor() @n
    Get a pointer to a given endpoint descriptor within a given interface
    within a given configuration. Parses through a data buffer which must
    have been previously populated by a call to@htmlonly USBH_QueryDeviceB().
    @endhtmlonly

  @ref USBH_QGetInterfaceDescriptor() @n
    Get a pointer to an interface descriptor within a given configuration.
    Parses through a data buffer which must have been previously populated
    by a call to@htmlonly USBH_QueryDeviceB() @endhtmlonly.

  @ref USBH_InitDeviceData() @n
    Populates device and endpoint data structures with data which must
    have been retrieved from a device by a call to
</pre><p>  USBH_QueryDeviceB() . The application must allocate and provide device and endpoint data structures to the host stack. After this function is called the device and endpoint data structures can be used as parameters (<em>handles</em>) to other API functions as needed.</p>
<p><br />
 </p>
<h2><a class="anchor" id="usb_host_print"></a>
Utility functions</h2>
<pre class="fragment">@ref USBH_PrintString() @n
  Print an USB string descriptor on the debug serial port with optional leader
  and trailer strings.

@ref USBH_PrintConfigurationDescriptor(),
@ref USBH_PrintDeviceDescriptor(),
@ref USBH_PrintEndpointDescriptor(),
@ref USBH_PrintInterfaceDescriptor() @n
  Pretty print descriptors on the debug serial port.

USB_PUTCHAR() @n Transmit a single char on the debug serial port.

USB_PUTS() @n Transmit a zero terminated string on the debug serial port.

USB_PRINTF() @n Transmit "printf" formated data on the debug serial port.

USB_GetErrorMsgString() @n Return an error message string for a given
error code.

USB_PrintErrorMsgString() @n Format and print a text string given an
error code, prepends an optional user supplied leader string.

USBTIMER_DelayMs() @n Active wait millisecond delay function. Can also be
used inside interrupt handlers.

USBTIMER_DelayUs() @n Active wait microsecond delay function. Can also be
used inside interrupt handlers.

USBTIMER_Init() @n Initialize the timer system. Called by@htmlonly 
USBH_Init(), @endhtmlonly but your application must call it again to
reinitialize whenever you change the HFPERCLK frequency.

USBTIMER_Start() @n Start a timer. You can configure the USB device stack
to provide any number of timers. The timers have 1 ms resolution, your
application is notified of timeout by means of a callback.

USBTIMER_Stop() @n Stop a timer.
</pre><p><br />
 </p>
<h1><a class="anchor" id="usb_host_conf"></a>
Configuring the host stack</h1>
<p>Your application must provide a header file named <em>usbconfig.h</em>. This file must contain the following #define's:<br />
 <br />
</p><pre class="fragment">#define USB_HOST         // Compile the stack for host mode.
#define NUM_HC_USED n    // Your application use 'n' host channels in addition
                         // to channels 0 and 1 which are assigned by the
                         // host stack for device endpoint 0 communication. </pre><p><br />
 <em>usbconfig.h</em> may define the following items: <br />
 <br />
</p><pre class="fragment">#define NUM_APP_TIMERS n // Your application needs 'n' timers

#define DEBUG_USB_API    // Turn on API debug diagnostics.

// Some utility functions in the API needs printf. These
// functions have "print" in their name. This macro enables
// these functions.
#define USB_USE_PRINTF   // Enable utility print functions.

// Define a function for transmitting a single char on the serial port.
extern int RETARGET_WriteChar(char c);
#define USER_PUTCHAR  RETARGET_WriteChar

#define USB_TIMER USB_TIMERn  // Select which hardware timer the USB stack
                              // is allowed to use. Valid values are n=0,1,2...
                              // corresponding to TIMER0, TIMER1, ...
                              // If not specified, TIMER0 is used </pre><p><br />
 You are strongly encouraged to start application development with DEBUG_USB_API turned on. When DEBUG_USB_API is turned on and USER_PUTCHAR is defined, useful debugging information will be output on the development kit serial port. Compiling with the DEBUG_EFM_USER flag will also enable all asserts in both <em>emlib</em> and in the USB stack. If asserts are enabled and USER_PUTCHAR defined, assert texts will be output on the serial port.</p>
<p>You application must include <em><a class="el" href="retargetserial_8c.html" title="Provide stdio retargeting to USART/UART or LEUART. ">retargetserial.c</a></em> if DEBUG_USB_API is defined and <em><a class="el" href="retargetio_8c.html" title="Provide stdio retargeting for all supported toolchains. ">retargetio.c</a></em> if USB_USE_PRINTF is defined. These files reside in the <em>drivers</em> directory in the software package for your development board.</p>
<p><br />
 The host stack can be configured to monitor a GPIO input pin for detection of VBUS overcurrent or short circuit conditions. The stack will by default use pin 2 on PortE and low polarity for this purpose. Override by using the following three #define's: <br />
 <br />
 </p><pre class="fragment">#define USB_VBUSOVRCUR_PORT       gpioPortB       // The port
#define USB_VBUSOVRCUR_PIN        7               // The pin number within the port
#define USB_VBUSOVRCUR_POLARITY   USB_VBUSOVRCUR_POLARITY_LOW </pre><p>Select any GPIO port for <b>USB_VBUSOVRCUR_PORT</b> or <b>USB_VBUSOVRCUR_PORT_NONE</b> if no overcurrent circuitry in the hw design. For <b>USB_VBUSOVRCUR_POLARITY</b> use <b>USB_VBUSOVRCUR_POLARITY_LOW</b> or <b>USB_VBUSOVRCUR_POLARITY_HIGH</b>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 10 2016 14:27:20 for EFM32 Giant Gecko Software Documentation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
