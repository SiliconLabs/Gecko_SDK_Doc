<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>EFM32 Gecko Software Documentation: I2C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EFM32 Gecko Software Documentation
   &#160;<span id="projectnumber">efm32g-doc-4.3.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="../../index.html"><span>Documentation&#160;Home</span></a></li>
      <li><a href="http://www.silabs.com"><span>silabs.com</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__I2C.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C<div class="ingroups"><a class="el" href="group__emlib.html">EMLIB</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Inter-integrated Circuit (I2C) Peripheral API. </p>
<p>This module contains functions to control the I2C peripheral of Silicon Labs 32-bit MCUs and SoCs. The I2C interface allows communication on I2C buses with the lowest energy consumption possible. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structI2C__Init__TypeDef.html">I2C_Init_TypeDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structI2C__TransferSeq__TypeDef.html">I2C_TransferSeq_TypeDef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master mode transfer message structure used to define a complete I2C transfer sequence (from start to stop).  <a href="structI2C__TransferSeq__TypeDef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6fd13e29a6b6315de051549037ac176f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6fd13e29a6b6315de051549037ac176f">I2C_FLAG_10BIT_ADDR</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="separator:ga6fd13e29a6b6315de051549037ac176f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c1779663a5ebf44e956ea3f591b4e61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0c1779663a5ebf44e956ea3f591b4e61">I2C_FLAG_READ</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:ga0c1779663a5ebf44e956ea3f591b4e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate plain read sequence: S+ADDR(R)+DATA0+P.  <a href="#ga0c1779663a5ebf44e956ea3f591b4e61">More...</a><br /></td></tr>
<tr class="separator:ga0c1779663a5ebf44e956ea3f591b4e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga091476f45133e8a6deb9dbd7a3ea6229"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga091476f45133e8a6deb9dbd7a3ea6229">I2C_FLAG_WRITE</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:ga091476f45133e8a6deb9dbd7a3ea6229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate plain write sequence: S+ADDR(W)+DATA0+P.  <a href="#ga091476f45133e8a6deb9dbd7a3ea6229">More...</a><br /></td></tr>
<tr class="separator:ga091476f45133e8a6deb9dbd7a3ea6229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9fc47d6ee1c66405dc491f7a4c3b8fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf9fc47d6ee1c66405dc491f7a4c3b8fc">I2C_FLAG_WRITE_READ</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:gaf9fc47d6ee1c66405dc491f7a4c3b8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate combined write/read sequence: S+ADDR(W)+DATA0+Sr+ADDR(R)+DATA1+P.  <a href="#gaf9fc47d6ee1c66405dc491f7a4c3b8fc">More...</a><br /></td></tr>
<tr class="separator:gaf9fc47d6ee1c66405dc491f7a4c3b8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28bb5f9d0559f3af24c0554e497ba2b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga28bb5f9d0559f3af24c0554e497ba2b3">I2C_FLAG_WRITE_WRITE</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:ga28bb5f9d0559f3af24c0554e497ba2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate write sequence using two buffers: S+ADDR(W)+DATA0+DATA1+P.  <a href="#ga28bb5f9d0559f3af24c0554e497ba2b3">More...</a><br /></td></tr>
<tr class="separator:ga28bb5f9d0559f3af24c0554e497ba2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29a3fbc14b30b68601118a9866e7440d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga29a3fbc14b30b68601118a9866e7440d">I2C_FREQ_FAST_MAX</a>&#160;&#160;&#160;392157</td></tr>
<tr class="memdesc:ga29a3fbc14b30b68601118a9866e7440d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast mode max frequency assuming using 6:3 ratio for Nlow:Nhigh.  <a href="#ga29a3fbc14b30b68601118a9866e7440d">More...</a><br /></td></tr>
<tr class="separator:ga29a3fbc14b30b68601118a9866e7440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6961334be5d2f1d6e98d8f48de3b040e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6961334be5d2f1d6e98d8f48de3b040e">I2C_FREQ_FASTPLUS_MAX</a>&#160;&#160;&#160;987167</td></tr>
<tr class="memdesc:ga6961334be5d2f1d6e98d8f48de3b040e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast mode+ max frequency assuming using 11:6 ratio for Nlow:Nhigh.  <a href="#ga6961334be5d2f1d6e98d8f48de3b040e">More...</a><br /></td></tr>
<tr class="separator:ga6961334be5d2f1d6e98d8f48de3b040e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a2167eb1e00a8da86bf0826f712f0f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0a2167eb1e00a8da86bf0826f712f0f8">I2C_FREQ_STANDARD_MAX</a>&#160;&#160;&#160;93000</td></tr>
<tr class="memdesc:ga0a2167eb1e00a8da86bf0826f712f0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard mode max frequency assuming using 4:4 ratio for Nlow:Nhigh.  <a href="#ga0a2167eb1e00a8da86bf0826f712f0f8">More...</a><br /></td></tr>
<tr class="separator:ga0a2167eb1e00a8da86bf0826f712f0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c7fbd27ef311914288d8e7ce02f1528"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga5c7fbd27ef311914288d8e7ce02f1528">I2C_INIT_DEFAULT</a></td></tr>
<tr class="separator:ga5c7fbd27ef311914288d8e7ce02f1528"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gabb1516548b4528328682d6be09a3e3a5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gabb1516548b4528328682d6be09a3e3a5">I2C_ClockHLR_TypeDef</a> { <br />
&#160;&#160;<a class="el" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a72c81018da3424addf47b44341acd111">i2cClockHLRStandard</a> = _I2C_CTRL_CLHR_STANDARD, 
<br />
&#160;&#160;<a class="el" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a7bfc41c09113d46c1247b598c80a3b2e">i2cClockHLRAsymetric</a> = _I2C_CTRL_CLHR_ASYMMETRIC, 
<br />
&#160;&#160;<a class="el" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a177d1faa325c634cbf56d2a4b4de9425">i2cClockHLRFast</a> = _I2C_CTRL_CLHR_FAST
<br />
 }<tr class="separator:gabb1516548b4528328682d6be09a3e3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga7c781ec28ae11e3e28892de7aa07a00f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a> { <br />
&#160;&#160;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c">i2cTransferInProgress</a> = 1, 
<br />
&#160;&#160;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66">i2cTransferDone</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa54895c4189c89f4410a3ce1a15822725">i2cTransferNack</a> = -1, 
<br />
&#160;&#160;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa75da099dd69e053ee12d38fdd76a22e6">i2cTransferBusErr</a> = -2, 
<br />
&#160;&#160;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fac15d6d57e2c8b0fca04fc6fbd80b824e">i2cTransferArbLost</a> = -3, 
<br />
&#160;&#160;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa49fe8ab19b9167d78c4b2abec7a511fc">i2cTransferUsageFault</a> = -4, 
<br />
&#160;&#160;<a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00faa5de823251279b281dcabbd1ec4f693d">i2cTransferSwFault</a> = -5
<br />
 }<tr class="separator:ga7c781ec28ae11e3e28892de7aa07a00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf2563ff04d4b24825a6c67f9ec4dcb80"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaf2563ff04d4b24825a6c67f9ec4dcb80">I2C_BusFreqGet</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c)</td></tr>
<tr class="memdesc:gaf2563ff04d4b24825a6c67f9ec4dcb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current configured I2C bus frequency.  <a href="#gaf2563ff04d4b24825a6c67f9ec4dcb80">More...</a><br /></td></tr>
<tr class="separator:gaf2563ff04d4b24825a6c67f9ec4dcb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02fbf32736b2e6c756399ceeba9563a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga02fbf32736b2e6c756399ceeba9563a1">I2C_BusFreqSet</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, uint32_t freqRef, uint32_t freqScl, <a class="el" href="group__I2C.html#gabb1516548b4528328682d6be09a3e3a5">I2C_ClockHLR_TypeDef</a> i2cMode)</td></tr>
<tr class="memdesc:ga02fbf32736b2e6c756399ceeba9563a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set I2C bus frequency.  <a href="#ga02fbf32736b2e6c756399ceeba9563a1">More...</a><br /></td></tr>
<tr class="separator:ga02fbf32736b2e6c756399ceeba9563a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1c9ca46d6945a4696f8a34ab8c2ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaca1c9ca46d6945a4696f8a34ab8c2ddf">I2C_Enable</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, bool enable)</td></tr>
<tr class="memdesc:gaca1c9ca46d6945a4696f8a34ab8c2ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable I2C.  <a href="#gaca1c9ca46d6945a4696f8a34ab8c2ddf">More...</a><br /></td></tr>
<tr class="separator:gaca1c9ca46d6945a4696f8a34ab8c2ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab52e0fc0d3690e40f80a193d5b6fdd51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gab52e0fc0d3690e40f80a193d5b6fdd51">I2C_Init</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, const <a class="el" href="structI2C__Init__TypeDef.html">I2C_Init_TypeDef</a> *init)</td></tr>
<tr class="memdesc:gab52e0fc0d3690e40f80a193d5b6fdd51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize I2C.  <a href="#gab52e0fc0d3690e40f80a193d5b6fdd51">More...</a><br /></td></tr>
<tr class="separator:gab52e0fc0d3690e40f80a193d5b6fdd51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga928527f7065f6b8d4a2bb282bbf8b7cd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga928527f7065f6b8d4a2bb282bbf8b7cd">I2C_IntClear</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, uint32_t flags)</td></tr>
<tr class="memdesc:ga928527f7065f6b8d4a2bb282bbf8b7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear one or more pending I2C interrupts.  <a href="#ga928527f7065f6b8d4a2bb282bbf8b7cd">More...</a><br /></td></tr>
<tr class="separator:ga928527f7065f6b8d4a2bb282bbf8b7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa11c438128e5fa1d5860d0b7ad88fbfe"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gaa11c438128e5fa1d5860d0b7ad88fbfe">I2C_IntDisable</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, uint32_t flags)</td></tr>
<tr class="memdesc:gaa11c438128e5fa1d5860d0b7ad88fbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable one or more I2C interrupts.  <a href="#gaa11c438128e5fa1d5860d0b7ad88fbfe">More...</a><br /></td></tr>
<tr class="separator:gaa11c438128e5fa1d5860d0b7ad88fbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b472a05a39a4e1a94d6b1d6270b7aa1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0b472a05a39a4e1a94d6b1d6270b7aa1">I2C_IntEnable</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, uint32_t flags)</td></tr>
<tr class="memdesc:ga0b472a05a39a4e1a94d6b1d6270b7aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable one or more I2C interrupts.  <a href="#ga0b472a05a39a4e1a94d6b1d6270b7aa1">More...</a><br /></td></tr>
<tr class="separator:ga0b472a05a39a4e1a94d6b1d6270b7aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6339175b1242ccf52567f43b969153c1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6339175b1242ccf52567f43b969153c1">I2C_IntGet</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c)</td></tr>
<tr class="memdesc:ga6339175b1242ccf52567f43b969153c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pending I2C interrupt flags.  <a href="#ga6339175b1242ccf52567f43b969153c1">More...</a><br /></td></tr>
<tr class="separator:ga6339175b1242ccf52567f43b969153c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07fb903ff92be25133d287c967e87424"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga07fb903ff92be25133d287c967e87424">I2C_IntGetEnabled</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c)</td></tr>
<tr class="memdesc:ga07fb903ff92be25133d287c967e87424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get enabled and pending I2C interrupt flags. Useful for handling more interrupt sources in the same interrupt handler.  <a href="#ga07fb903ff92be25133d287c967e87424">More...</a><br /></td></tr>
<tr class="separator:ga07fb903ff92be25133d287c967e87424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d23302ba9e55d10ee19f20d91f170d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gab6d23302ba9e55d10ee19f20d91f170d">I2C_IntSet</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, uint32_t flags)</td></tr>
<tr class="memdesc:gab6d23302ba9e55d10ee19f20d91f170d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set one or more pending I2C interrupts from SW.  <a href="#gab6d23302ba9e55d10ee19f20d91f170d">More...</a><br /></td></tr>
<tr class="separator:gab6d23302ba9e55d10ee19f20d91f170d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602a1d2c64c05453bf9c1b1d52194678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga602a1d2c64c05453bf9c1b1d52194678">I2C_Reset</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c)</td></tr>
<tr class="memdesc:ga602a1d2c64c05453bf9c1b1d52194678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset I2C to same state as after a HW reset.  <a href="#ga602a1d2c64c05453bf9c1b1d52194678">More...</a><br /></td></tr>
<tr class="separator:ga602a1d2c64c05453bf9c1b1d52194678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18042cf363fe66fb94fcd724d07efad2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga18042cf363fe66fb94fcd724d07efad2">I2C_SlaveAddressGet</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c)</td></tr>
<tr class="memdesc:ga18042cf363fe66fb94fcd724d07efad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get slave address used for I2C peripheral (when operating in slave mode).  <a href="#ga18042cf363fe66fb94fcd724d07efad2">More...</a><br /></td></tr>
<tr class="separator:ga18042cf363fe66fb94fcd724d07efad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0296ee95a311687feea28bac21d1ff"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga0a0296ee95a311687feea28bac21d1ff">I2C_SlaveAddressMaskGet</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c)</td></tr>
<tr class="memdesc:ga0a0296ee95a311687feea28bac21d1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get slave address mask used for I2C peripheral (when operating in slave mode).  <a href="#ga0a0296ee95a311687feea28bac21d1ff">More...</a><br /></td></tr>
<tr class="separator:ga0a0296ee95a311687feea28bac21d1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ac1d9e8ab3c9303cfabaafe407b5b1e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga9ac1d9e8ab3c9303cfabaafe407b5b1e">I2C_SlaveAddressMaskSet</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, uint8_t mask)</td></tr>
<tr class="memdesc:ga9ac1d9e8ab3c9303cfabaafe407b5b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slave address mask used for I2C peripheral (when operating in slave mode).  <a href="#ga9ac1d9e8ab3c9303cfabaafe407b5b1e">More...</a><br /></td></tr>
<tr class="separator:ga9ac1d9e8ab3c9303cfabaafe407b5b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7459b4e89456387a9ea5576612b01d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga6d7459b4e89456387a9ea5576612b01d">I2C_SlaveAddressSet</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, uint8_t addr)</td></tr>
<tr class="memdesc:ga6d7459b4e89456387a9ea5576612b01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slave address to use for I2C peripheral (when operating in slave mode).  <a href="#ga6d7459b4e89456387a9ea5576612b01d">More...</a><br /></td></tr>
<tr class="separator:ga6d7459b4e89456387a9ea5576612b01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67983b3dbe7f028a97f765e421b3df56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56">I2C_Transfer</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c)</td></tr>
<tr class="memdesc:ga67983b3dbe7f028a97f765e421b3df56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continue an initiated I2C transfer (single master mode only).  <a href="#ga67983b3dbe7f028a97f765e421b3df56">More...</a><br /></td></tr>
<tr class="separator:ga67983b3dbe7f028a97f765e421b3df56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2bf2ecc3d0c4f55e3511d4871b64b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__I2C.html#gae2bf2ecc3d0c4f55e3511d4871b64b16">I2C_TransferInit</a> (<a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *i2c, <a class="el" href="structI2C__TransferSeq__TypeDef.html">I2C_TransferSeq_TypeDef</a> *seq)</td></tr>
<tr class="memdesc:gae2bf2ecc3d0c4f55e3511d4871b64b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare and start an I2C transfer (single master mode only).  <a href="#gae2bf2ecc3d0c4f55e3511d4871b64b16">More...</a><br /></td></tr>
<tr class="separator:gae2bf2ecc3d0c4f55e3511d4871b64b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga6fd13e29a6b6315de051549037ac176f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_10BIT_ADDR&#160;&#160;&#160;0x0010</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use 10 bit address. </p>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00157">157</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56">I2C_Transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c1779663a5ebf44e956ea3f591b4e61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_READ&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate plain read sequence: S+ADDR(R)+DATA0+P. </p>
<ul>
<li>S - Start </li>
<li>ADDR(R) - address with W/R bit set </li>
<li>DATA0 - Data read into buffer with index 0 </li>
<li>P - Stop </li>
</ul>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00130">130</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56">I2C_Transfer()</a>, <a class="el" href="group__I2C.html#gae2bf2ecc3d0c4f55e3511d4871b64b16">I2C_TransferInit()</a>, and <a class="el" href="cpt112s__i2c_8c.html#a0be56a687b1624b76fec1289ef075017">performI2CTransfer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga091476f45133e8a6deb9dbd7a3ea6229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_WRITE&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate plain write sequence: S+ADDR(W)+DATA0+P. </p>
<ul>
<li>S - Start </li>
<li>ADDR(W) - address with W/R bit cleared </li>
<li>DATA0 - Data taken from buffer with index 0 </li>
<li>P - Stop </li>
</ul>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00119">119</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="eeprom_8c.html#aef96dc2e7cad63b532565057c7f0467c">EEPROM_AckPoll()</a>, <a class="el" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56">I2C_Transfer()</a>, <a class="el" href="group__Si114x.html#gaec6f34819894c8d7b2f86fb574da203e">Si1147_Write_Block_Register()</a>, <a class="el" href="group__Si114x.html#gad2464ccbbf4938c5550702011d6dd5a4">Si1147_Write_Register()</a>, and <a class="el" href="group__TempSensor.html#gafeb45237c0a6989bc2e3bdbc564d90bd">TEMPSENS_RegisterSet()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf9fc47d6ee1c66405dc491f7a4c3b8fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_WRITE_READ&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate combined write/read sequence: S+ADDR(W)+DATA0+Sr+ADDR(R)+DATA1+P. </p>
<ul>
<li>S - Start </li>
<li>Sr - Repeated start </li>
<li>ADDR(W) - address with W/R bit cleared </li>
<li>ADDR(R) - address with W/R bit set </li>
<li>DATAn - Data written from/read into buffer with index n </li>
<li>P - Stop </li>
</ul>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00143">143</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="group__Eeprom.html#gafffd2286594ec8e01dc16f8725626c04">EEPROM_Read()</a>, <a class="el" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56">I2C_Transfer()</a>, <a class="el" href="group__I2C.html#gae2bf2ecc3d0c4f55e3511d4871b64b16">I2C_TransferInit()</a>, <a class="el" href="group__Si114x.html#ga1ba38d5d8eefcaf2c7b1e5fcb0bec0f7">Si1147_Read_Block_Register()</a>, <a class="el" href="group__Si114x.html#ga8066eedd4bbac304e733a89e09cd6786">Si1147_Read_Register()</a>, <a class="el" href="group__Si7013.html#ga93b1a4e0a94737abd16ec547004c270f">Si7013_Detect()</a>, <a class="el" href="group__Si7013.html#gac595b86107a208280179a6f07c08bfa3">Si7013_GetFirmwareRevision()</a>, and <a class="el" href="group__TempSensor.html#gae77973607cb0dc33faaed18274885717">TEMPSENS_RegisterGet()</a>.</p>

</div>
</div>
<a class="anchor" id="ga28bb5f9d0559f3af24c0554e497ba2b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FLAG_WRITE_WRITE&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate write sequence using two buffers: S+ADDR(W)+DATA0+DATA1+P. </p>
<ul>
<li>S - Start </li>
<li>ADDR(W) - address with W/R bit cleared </li>
<li>DATAn - Data written from buffer with index n </li>
<li>P - Stop </li>
</ul>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00154">154</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="group__Eeprom.html#ga1b92635b3e255f10731494e833654895">EEPROM_Write()</a>.</p>

</div>
</div>
<a class="anchor" id="ga29a3fbc14b30b68601118a9866e7440d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FREQ_FAST_MAX&#160;&#160;&#160;392157</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast mode max frequency assuming using 6:3 ratio for Nlow:Nhigh. </p>
<p>From I2C specification: Min Tlow = 1.3us, min Thigh = 0.6us, max Trise=0.3us, max Tfall=0.3us. Since ratio is 6:3, have to use worst case value of Tlow or 2xThigh as base.</p>
<p>1/(Tlow + Thigh + 0.3us + 0.3us) = 1/(1.3 + 0.65 + 0.6)us = 392157Hz </p>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00094">94</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6961334be5d2f1d6e98d8f48de3b040e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FREQ_FASTPLUS_MAX&#160;&#160;&#160;987167</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast mode+ max frequency assuming using 11:6 ratio for Nlow:Nhigh. </p>
<p>From I2C specification: Min Tlow = 0.5us, min Thigh = 0.26us, max Trise=0.12us, max Tfall=0.12us. Since ratio is 11:6, have to use worst case value of Tlow or (11/6)xThigh as base.</p>
<p>1/(Tlow + Thigh + 0.12us + 0.12us) = 1/(0.5 + 0.273 + 0.24)us = 987167Hz </p>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00107">107</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a2167eb1e00a8da86bf0826f712f0f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_FREQ_STANDARD_MAX&#160;&#160;&#160;93000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard mode max frequency assuming using 4:4 ratio for Nlow:Nhigh. </p>
<p>From I2C specification: Min Tlow = 4.7us, min Thigh = 4.0us, max Trise=1.0us, max Tfall=0.3us. Since ratio is 4:4, have to use worst case value of Tlow or Thigh as base.</p>
<p>1/(Tlow + Thigh + 1us + 0.3us) = 1/(4.7 + 4.7 + 1.3)us = 93458Hz </p><dl class="section note"><dt>Note</dt><dd>Due to chip characteristics, the max value is somewhat reduced. </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00073">73</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga5c7fbd27ef311914288d8e7ce02f1528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_INIT_DEFAULT</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                         \</div>
<div class="line">  true,                    <span class="comment">/* Enable when init done */</span>                    \</div>
<div class="line">  true,                    <span class="comment">/* Set to master mode */</span>                       \</div>
<div class="line">  0,                       <span class="comment">/* Use currently configured reference clock */</span> <a class="code" href="group__I2C.html#ga0a2167eb1e00a8da86bf0826f712f0f8">\</a></div>
<div class="line"><a class="code" href="group__I2C.html#ga0a2167eb1e00a8da86bf0826f712f0f8">  I2C_FREQ_STANDARD_MAX</a>,   <span class="comment">/* Set to standard rate assuring being */</span>      \</div>
<div class="line">                           <span class="comment">/* within I2C spec */</span>                          \</div>
<div class="line">  i2cClockHLRStandard      <span class="comment">/* Set to use 4:4 low/high duty cycle */</span>       \</div>
<div class="line">}</div>
<div class="ttc" id="group__I2C_html_ga0a2167eb1e00a8da86bf0826f712f0f8"><div class="ttname"><a href="group__I2C.html#ga0a2167eb1e00a8da86bf0826f712f0f8">I2C_FREQ_STANDARD_MAX</a></div><div class="ttdeci">#define I2C_FREQ_STANDARD_MAX</div><div class="ttdoc">Standard mode max frequency assuming using 4:4 ratio for Nlow:Nhigh. </div><div class="ttdef"><b>Definition:</b> <a href="em__i2c_8h_source.html#l00073">em_i2c.h:73</a></div></div>
</div><!-- fragment --><p>Suggested default config for I2C init structure. </p>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00222">222</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>Referenced by <a class="el" href="cpt112s__i2c_8c.html#a3245984004b050943aa774dbb41fdc6c">setupI2C()</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gabb1516548b4528328682d6be09a3e3a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#gabb1516548b4528328682d6be09a3e3a5">I2C_ClockHLR_TypeDef</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clock low to high ratio settings. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggabb1516548b4528328682d6be09a3e3a5a72c81018da3424addf47b44341acd111"></a>i2cClockHLRStandard&#160;</td><td class="fielddoc">
<p>Ratio is 4:4 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabb1516548b4528328682d6be09a3e3a5a7bfc41c09113d46c1247b598c80a3b2e"></a>i2cClockHLRAsymetric&#160;</td><td class="fielddoc">
<p>Ratio is 6:3 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabb1516548b4528328682d6be09a3e3a5a177d1faa325c634cbf56d2a4b4de9425"></a>i2cClockHLRFast&#160;</td><td class="fielddoc">
<p>Ratio is 11:3 </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00165">165</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c781ec28ae11e3e28892de7aa07a00f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return codes for single master mode transfer function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c"></a>i2cTransferInProgress&#160;</td><td class="fielddoc">
<p>Transfer in progress. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66"></a>i2cTransferDone&#160;</td><td class="fielddoc">
<p>Transfer completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa54895c4189c89f4410a3ce1a15822725"></a>i2cTransferNack&#160;</td><td class="fielddoc">
<p>NACK received during transfer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa75da099dd69e053ee12d38fdd76a22e6"></a>i2cTransferBusErr&#160;</td><td class="fielddoc">
<p>Bus error during transfer (misplaced START/STOP). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fac15d6d57e2c8b0fca04fc6fbd80b824e"></a>i2cTransferArbLost&#160;</td><td class="fielddoc">
<p>Arbitration lost during transfer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00fa49fe8ab19b9167d78c4b2abec7a511fc"></a>i2cTransferUsageFault&#160;</td><td class="fielddoc">
<p>Usage fault. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7c781ec28ae11e3e28892de7aa07a00faa5de823251279b281dcabbd1ec4f693d"></a>i2cTransferSwFault&#160;</td><td class="fielddoc">
<p>SW fault. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00174">174</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf2563ff04d4b24825a6c67f9ec4dcb80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_BusFreqGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current configured I2C bus frequency. </p>
<p>This frequency is only of relevance when acting as master.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current I2C frequency in Hz. </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00174">174</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="group__EFM32G__I2C__BitFields.html#ga30cad95c42b60b1b18429daec91be302">_I2C_CTRL_CLHR_MASK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga24036bb323c309a99203401e85618a8c">_I2C_CTRL_CLHR_SHIFT</a>, <a class="el" href="structI2C__TypeDef.html#ae375d4cfa09463199ad43b1ba42ada31">I2C_TypeDef::CLKDIV</a>, <a class="el" href="group__CMU.html#gac9aa0ed17f83bd48abcf7b430843374a">CMU_ClockFreqGet()</a>, <a class="el" href="group__CMU.html#gga519ea66a1a21e07f2d1cccc9aa55799eafdbf6d011629cb273654aa780dc3d00f">cmuClock_HFPER</a>, and <a class="el" href="structI2C__TypeDef.html#a7d42b810eada368f1af5695fbbbc52f5">I2C_TypeDef::CTRL</a>.</p>

</div>
</div>
<a class="anchor" id="ga02fbf32736b2e6c756399ceeba9563a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_BusFreqSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>freqRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>freqScl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__I2C.html#gabb1516548b4528328682d6be09a3e3a5">I2C_ClockHLR_TypeDef</a>&#160;</td>
          <td class="paramname"><em>i2cMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set I2C bus frequency. </p>
<p>The bus frequency is only of relevance when acting as a master. The bus frequency should not be set higher than the max frequency accepted by the slowest device on the bus.</p>
<p>Notice that due to asymmetric requirements on low and high I2C clock cycles by the I2C specification, the actual max frequency allowed in order to comply with the specification may be somewhat lower than expected.</p>
<p>Please refer to the reference manual, details on I2C clock generation, for max allowed theoretical frequencies for different modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freqRef</td><td>I2C reference clock frequency in Hz that will be used. If set to 0, then HFPER clock is used. Setting it to a higher than actual configured value only has the consequence of reducing the real I2C frequency.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freqScl</td><td>Bus frequency to set (actual bus speed may be lower due to integer prescaling). Safe (according to I2C specification) max frequencies for standard, fast and fast+ modes are available using I2C_FREQ_ defines. (Using I2C_FREQ_ defines requires corresponding setting of <code>type</code>.) Slowest slave device on bus must always be considered.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2cMode</td><td>Clock low to high ratio type to use. If not using i2cClockHLRStandard, make sure all devices on the bus support the specified mode. Using a non-standard ratio is useful to achieve higher bus clock in fast and fast+ modes. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00227">227</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="group__EFM32G__I2C__BitFields.html#ga76323850d2dd35f3359d56912dfa1497">_I2C_CLKDIV_DIV_MASK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga30cad95c42b60b1b18429daec91be302">_I2C_CTRL_CLHR_MASK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga24036bb323c309a99203401e85618a8c">_I2C_CTRL_CLHR_SHIFT</a>, <a class="el" href="group__BUS.html#ga9e878ccba24fcbf97b5bcb8b53356e76">BUS_RegMaskedWrite()</a>, <a class="el" href="structI2C__TypeDef.html#ae375d4cfa09463199ad43b1ba42ada31">I2C_TypeDef::CLKDIV</a>, <a class="el" href="group__CMU.html#gac9aa0ed17f83bd48abcf7b430843374a">CMU_ClockFreqGet()</a>, <a class="el" href="group__CMU.html#gga519ea66a1a21e07f2d1cccc9aa55799eafdbf6d011629cb273654aa780dc3d00f">cmuClock_HFPER</a>, <a class="el" href="structI2C__TypeDef.html#a7d42b810eada368f1af5695fbbbc52f5">I2C_TypeDef::CTRL</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga9cf1123d9dad281bf0bde6a5582e0915">I2C_CTRL_SLAVE</a>, <a class="el" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a7bfc41c09113d46c1247b598c80a3b2e">i2cClockHLRAsymetric</a>, <a class="el" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a177d1faa325c634cbf56d2a4b4de9425">i2cClockHLRFast</a>, and <a class="el" href="group__I2C.html#ggabb1516548b4528328682d6be09a3e3a5a72c81018da3424addf47b44341acd111">i2cClockHLRStandard</a>.</p>

<p>Referenced by <a class="el" href="group__I2C.html#gab52e0fc0d3690e40f80a193d5b6fdd51">I2C_Init()</a>.</p>

</div>
</div>
<a class="anchor" id="gaca1c9ca46d6945a4696f8a34ab8c2ddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable I2C. </p>
<dl class="section note"><dt>Note</dt><dd>After enabling the I2C (from being disabled), the I2C is in BUSY state.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>true to enable counting, false to disable. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00335">335</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="group__EFM32G__I2C__BitFields.html#ga8ccea6fc637968903961b6c25d42862e">_I2C_CTRL_EN_SHIFT</a>, <a class="el" href="group__BUS.html#gaf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite()</a>, and <a class="el" href="structI2C__TypeDef.html#a7d42b810eada368f1af5695fbbbc52f5">I2C_TypeDef::CTRL</a>.</p>

</div>
</div>
<a class="anchor" id="gab52e0fc0d3690e40f80a193d5b6fdd51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structI2C__Init__TypeDef.html">I2C_Init_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize I2C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>Pointer to I2C initialization structure. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00353">353</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="group__EFM32G__I2C__BitFields.html#ga8ccea6fc637968903961b6c25d42862e">_I2C_CTRL_EN_SHIFT</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gad1aed8755131b83bcbbdd1d3d2749cd3">_I2C_CTRL_SLAVE_SHIFT</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga4c7d4b074406d855fea4880e58519c53">_I2C_IFC_MASK</a>, <a class="el" href="group__BUS.html#gaf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite()</a>, <a class="el" href="structI2C__Init__TypeDef.html#acc90993308843c20b377bbee7d636123">I2C_Init_TypeDef::clhr</a>, <a class="el" href="structI2C__TypeDef.html#a7d42b810eada368f1af5695fbbbc52f5">I2C_TypeDef::CTRL</a>, <a class="el" href="structI2C__Init__TypeDef.html#a1fd77eeee85d3038268a8a7e16314df9">I2C_Init_TypeDef::enable</a>, <a class="el" href="structI2C__Init__TypeDef.html#a21000158b359b35d2dd6e732cd774b20">I2C_Init_TypeDef::freq</a>, <a class="el" href="group__I2C.html#ga02fbf32736b2e6c756399ceeba9563a1">I2C_BusFreqSet()</a>, <a class="el" href="structI2C__TypeDef.html#a647fddc5196ae97150039621c847948f">I2C_TypeDef::IEN</a>, <a class="el" href="structI2C__TypeDef.html#a25521276d00ff1fcbf298da7a4d90909">I2C_TypeDef::IFC</a>, <a class="el" href="structI2C__Init__TypeDef.html#a14b8b0fe9a200168abb347ce1773a7d4">I2C_Init_TypeDef::master</a>, and <a class="el" href="structI2C__Init__TypeDef.html#aa95bd4e4c981f7324e964ed375c9ed4a">I2C_Init_TypeDef::refFreq</a>.</p>

<p>Referenced by <a class="el" href="group__I2CSPM.html#ga65556785bb5d714b23e1149d8ed742e5">I2CSPM_Init()</a>, and <a class="el" href="cpt112s__i2c_8c.html#a3245984004b050943aa774dbb41fdc6c">setupI2C()</a>.</p>

</div>
</div>
<a class="anchor" id="ga928527f7065f6b8d4a2bb282bbf8b7cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_IntClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear one or more pending I2C interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Pending I2C interrupt source to clear. Use a bitwse logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00306">306</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#a25521276d00ff1fcbf298da7a4d90909">I2C_TypeDef::IFC</a>.</p>

</div>
</div>
<a class="anchor" id="gaa11c438128e5fa1d5860d0b7ad88fbfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_IntDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable one or more I2C interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>I2C interrupt sources to disable. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00323">323</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#a647fddc5196ae97150039621c847948f">I2C_TypeDef::IEN</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b472a05a39a4e1a94d6b1d6270b7aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_IntEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable one or more I2C interrupts. </p>
<dl class="section note"><dt>Note</dt><dd>Depending on the use, a pending interrupt may already be set prior to enabling the interrupt. Consider using <a class="el" href="group__I2C.html#ga928527f7065f6b8d4a2bb282bbf8b7cd" title="Clear one or more pending I2C interrupts. ">I2C_IntClear()</a> prior to enabling if such a pending interrupt should be ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>I2C interrupt sources to enable. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00345">345</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#a647fddc5196ae97150039621c847948f">I2C_TypeDef::IEN</a>.</p>

</div>
</div>
<a class="anchor" id="ga6339175b1242ccf52567f43b969153c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t I2C_IntGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pending I2C interrupt flags. </p>
<dl class="section note"><dt>Note</dt><dd>The event bits are not cleared by the use of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I2C interrupt sources pending. A bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00365">365</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#aaf632fc96f518c0dedcfaf90c1b53df8">I2C_TypeDef::IF</a>.</p>

</div>
</div>
<a class="anchor" id="ga07fb903ff92be25133d287c967e87424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t I2C_IntGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get enabled and pending I2C interrupt flags. Useful for handling more interrupt sources in the same interrupt handler. </p>
<dl class="section note"><dt>Note</dt><dd>Interrupt flags are not cleared by the use of this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pending and enabled I2C interrupt sources The return value is the bitwise AND of<ul>
<li>the enabled interrupt sources in I2Cn_IEN and</li>
<li>the pending interrupt flags I2Cn_IF </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00388">388</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#a647fddc5196ae97150039621c847948f">I2C_TypeDef::IEN</a>, and <a class="el" href="structI2C__TypeDef.html#aaf632fc96f518c0dedcfaf90c1b53df8">I2C_TypeDef::IF</a>.</p>

</div>
</div>
<a class="anchor" id="gab6d23302ba9e55d10ee19f20d91f170d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_IntSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set one or more pending I2C interrupts from SW. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>I2C interrupt sources to set to pending. Use a bitwise logic OR combination of valid interrupt flags for the I2C module (I2C_IF_nnn). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00408">408</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#a345e0bd10da7f9dfe42b596a011bcc31">I2C_TypeDef::IFS</a>.</p>

</div>
</div>
<a class="anchor" id="ga602a1d2c64c05453bf9c1b1d52194678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset I2C to same state as after a HW reset. </p>
<dl class="section note"><dt>Note</dt><dd>The ROUTE register is NOT reset by this function, in order to allow for centralized setup of this feature.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00380">380</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="group__EFM32G__I2C__BitFields.html#ga0ba373dbb82e037122c24b77512802a5">_I2C_CLKDIV_RESETVALUE</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gac88a0e3fe5c255c0e78d0d3cce6c0e2c">_I2C_CTRL_RESETVALUE</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gafa802098570a6226e86e64813efd8fd7">_I2C_IEN_RESETVALUE</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga4c7d4b074406d855fea4880e58519c53">_I2C_IFC_MASK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga5020ef3be0423f122654f5c05205b84c">_I2C_SADDR_RESETVALUE</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gadf3df98f4e68946a667308b326d9e410">_I2C_SADDRMASK_RESETVALUE</a>, <a class="el" href="structI2C__TypeDef.html#ae375d4cfa09463199ad43b1ba42ada31">I2C_TypeDef::CLKDIV</a>, <a class="el" href="structI2C__TypeDef.html#a7d42b810eada368f1af5695fbbbc52f5">I2C_TypeDef::CTRL</a>, <a class="el" href="structI2C__TypeDef.html#a647fddc5196ae97150039621c847948f">I2C_TypeDef::IEN</a>, <a class="el" href="structI2C__TypeDef.html#a25521276d00ff1fcbf298da7a4d90909">I2C_TypeDef::IFC</a>, <a class="el" href="structI2C__TypeDef.html#a1cc0ae179222b627bb56ac66b5a3f122">I2C_TypeDef::SADDR</a>, and <a class="el" href="structI2C__TypeDef.html#a2c0790bec317b97c36d69e0365d27621">I2C_TypeDef::SADDRMASK</a>.</p>

</div>
</div>
<a class="anchor" id="ga18042cf363fe66fb94fcd724d07efad2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t I2C_SlaveAddressGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get slave address used for I2C peripheral (when operating in slave mode). </p>
<p>For 10 bit addressing mode, the address is split in two bytes, and only the first byte setting is fetched, effectively only controlling the 2 most significant bits of the 10 bit address. Full handling of 10 bit addressing in slave mode requires additional SW handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I2C slave address in use. The 7 most significant bits define the actual address, the least significant bit is reserved and always returned as 0. </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00432">432</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#a1cc0ae179222b627bb56ac66b5a3f122">I2C_TypeDef::SADDR</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a0296ee95a311687feea28bac21d1ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t I2C_SlaveAddressMaskGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get slave address mask used for I2C peripheral (when operating in slave mode). </p>
<p>The address mask defines how the comparator works. A bit position with value 0 means that the corresponding slave address bit is ignored during comparison (don't care). A bit position with value 1 means that the corresponding slave address bit must match.</p>
<p>For 10 bit addressing mode, the address is split in two bytes, and only the mask for the first address byte is fetched, effectively only controlling the 2 most significant bits of the 10 bit address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I2C slave address mask in use. The 7 most significant bits define the actual address mask, the least significant bit is reserved and always returned as 0. </dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00484">484</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#a2c0790bec317b97c36d69e0365d27621">I2C_TypeDef::SADDRMASK</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ac1d9e8ab3c9303cfabaafe407b5b1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_SlaveAddressMaskSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set slave address mask used for I2C peripheral (when operating in slave mode). </p>
<p>The address mask defines how the comparator works. A bit position with value 0 means that the corresponding slave address bit is ignored during comparison (don't care). A bit position with value 1 means that the corresponding slave address bit must match.</p>
<p>For 10 bit addressing mode, the address is split in two bytes, and only the mask for the first address byte is set, effectively only controlling the 2 most significant bits of the 10 bit address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mask</td><td>I2C slave address mask to use. The 7 most significant bits define the actual address mask, the least significant bit is reserved and should be 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00513">513</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#a2c0790bec317b97c36d69e0365d27621">I2C_TypeDef::SADDRMASK</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d7459b4e89456387a9ea5576612b01d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void I2C_SlaveAddressSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set slave address to use for I2C peripheral (when operating in slave mode). </p>
<p>For 10 bit addressing mode, the address is split in two bytes, and only the first byte is set, effectively only controlling the 2 most significant bits of the 10 bit address. Full handling of 10 bit addressing in slave mode requires additional SW handling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>I2C slave address to use. The 7 most significant bits define the actual address, the least significant bit is reserved and always set to 0. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__i2c_8h_source.html#l00455">455</a> of file <a class="el" href="em__i2c_8h_source.html">em_i2c.h</a>.</p>

<p>References <a class="el" href="structI2C__TypeDef.html#a1cc0ae179222b627bb56ac66b5a3f122">I2C_TypeDef::SADDR</a>.</p>

</div>
</div>
<a class="anchor" id="ga67983b3dbe7f028a97f765e421b3df56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a> I2C_Transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Continue an initiated I2C transfer (single master mode only). </p>
<p>This function is used repeatedly after a <a class="el" href="group__I2C.html#gae2bf2ecc3d0c4f55e3511d4871b64b16" title="Prepare and start an I2C transfer (single master mode only). ">I2C_TransferInit()</a> in order to complete a transfer. It may be used in polled mode as the below example shows: </p><pre class="fragment">* I2C_TransferReturn_TypeDef ret;
*
* // Do a polled transfer
* ret = I2C_TransferInit(I2C0, seq);
* while (ret == i2cTransferInProgress)
* {
*   ret = I2C_Transfer(I2C0);
* }
* </pre><p> It may also be used in interrupt driven mode, where this function is invoked from the interrupt handler. Notice that if used in interrupt mode, NVIC interrupts must be configured and enabled for the I2C bus used. I2C peripheral specific interrupts are managed by this SW.</p>
<dl class="section note"><dt>Note</dt><dd>Only single master mode is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns status for ongoing transfer. <ul>
<li><a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c">i2cTransferInProgress</a> - indicates that transfer not finished. </li>
<li><a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66">i2cTransferDone</a> - transfer completed successfully. </li>
<li>otherwise some sort of error has occurred. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00428">428</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="structI2C__TransferSeq__TypeDef.html#a864fcee4abd27c2dab5723c2d2493ed0">I2C_TransferSeq_TypeDef::addr</a>, <a class="el" href="structI2C__TransferSeq__TypeDef.html#a8768a91a4d0d3c66e72e8fdb981b5c63">I2C_TransferSeq_TypeDef::buf</a>, <a class="el" href="structI2C__TypeDef.html#a16d77fc238ce699a694fb4a431d46853">I2C_TypeDef::CMD</a>, <a class="el" href="structI2C__TransferSeq__TypeDef.html#ac50f3e038b429e01fd5b2bdfede2f674">I2C_TransferSeq_TypeDef::data</a>, <a class="el" href="structI2C__TransferSeq__TypeDef.html#aa9eb709e67fbaa4acb9a4964ca5174cb">I2C_TransferSeq_TypeDef::flags</a>, <a class="el" href="group__EFM32G890F128__Peripheral__Declaration.html#ga86abb2e8858d177c04e60c41e9242045">I2C0</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga984bfbaf552cbbcd3968e5e43497ef9a">I2C_CMD_ACK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga0ca785703eb12d53e1bb80154006dce7">I2C_CMD_NACK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga9811b4c973a2c4a8a5c0ef6c1070d2c8">I2C_CMD_START</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gab268e894a5a9e6c0fd58c3e77f827462">I2C_CMD_STOP</a>, <a class="el" href="group__I2C.html#ga6fd13e29a6b6315de051549037ac176f">I2C_FLAG_10BIT_ADDR</a>, <a class="el" href="group__I2C.html#ga0c1779663a5ebf44e956ea3f591b4e61">I2C_FLAG_READ</a>, <a class="el" href="group__I2C.html#ga091476f45133e8a6deb9dbd7a3ea6229">I2C_FLAG_WRITE</a>, <a class="el" href="group__I2C.html#gaf9fc47d6ee1c66405dc491f7a4c3b8fc">I2C_FLAG_WRITE_READ</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gab345bfd7135a3d796e9167e14ad7ed2e">I2C_IF_ACK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga82129e78d14aee2d80d749d450995e91">I2C_IF_ARBLOST</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gaac0e7c392ff0af3e91e88785b8e5b08d">I2C_IF_BUSERR</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga56d250d829264822613f469e643d15ed">I2C_IF_MSTOP</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga680542dbba8b23cf70e5c414e8af6545">I2C_IF_NACK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga178ce96f3ba88c84d538a4377aaca7a0">I2C_IF_RXDATAV</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gad4a6a4658a62daecc783b9728fbabbb3">I2C_IFC_ACK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gaa7069f5b8ebd908dfce60953b9683960">I2C_IFC_MSTOP</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga2ad160f5962b5c3e31df21a3f98fb4f5">I2C_IFC_NACK</a>, <a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fac15d6d57e2c8b0fca04fc6fbd80b824e">i2cTransferArbLost</a>, <a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa75da099dd69e053ee12d38fdd76a22e6">i2cTransferBusErr</a>, <a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa01149f9a11ada8a9b05e7104f873de66">i2cTransferDone</a>, <a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c">i2cTransferInProgress</a>, <a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa54895c4189c89f4410a3ce1a15822725">i2cTransferNack</a>, <a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00faa5de823251279b281dcabbd1ec4f693d">i2cTransferSwFault</a>, <a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa49fe8ab19b9167d78c4b2abec7a511fc">i2cTransferUsageFault</a>, <a class="el" href="structI2C__TypeDef.html#a647fddc5196ae97150039621c847948f">I2C_TypeDef::IEN</a>, <a class="el" href="structI2C__TypeDef.html#aaf632fc96f518c0dedcfaf90c1b53df8">I2C_TypeDef::IF</a>, <a class="el" href="structI2C__TypeDef.html#a25521276d00ff1fcbf298da7a4d90909">I2C_TypeDef::IFC</a>, <a class="el" href="structI2C__TransferSeq__TypeDef.html#a92b6d16d6d3b3e4d5650740fa306a285">I2C_TransferSeq_TypeDef::len</a>, <a class="el" href="structI2C__TypeDef.html#a2fe785eb93cd3d262aa7a9d751075d7f">I2C_TypeDef::RXDATA</a>, and <a class="el" href="structI2C__TypeDef.html#af3548b16a4f277ed0166e12245fa781e">I2C_TypeDef::TXDATA</a>.</p>

<p>Referenced by <a class="el" href="group__I2C.html#gae2bf2ecc3d0c4f55e3511d4871b64b16">I2C_TransferInit()</a>, <a class="el" href="group__I2CSPM.html#ga076766b20012fb6a0cdaaf0f2c760795">I2CSPM_Transfer()</a>, and <a class="el" href="cpt112s__i2c_8c.html#a0be56a687b1624b76fec1289ef075017">performI2CTransfer()</a>.</p>

</div>
</div>
<a class="anchor" id="gae2bf2ecc3d0c4f55e3511d4871b64b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__I2C.html#ga7c781ec28ae11e3e28892de7aa07a00f">I2C_TransferReturn_TypeDef</a> I2C_TransferInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structI2C__TypeDef.html">I2C_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structI2C__TransferSeq__TypeDef.html">I2C_TransferSeq_TypeDef</a> *&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare and start an I2C transfer (single master mode only). </p>
<p>This function must be invoked in order to start an I2C transfer sequence. In order to actually complete the transfer, <a class="el" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56" title="Continue an initiated I2C transfer (single master mode only). ">I2C_Transfer()</a> must be used either in polled mode or by adding a small driver wrapper utilizing interrupts.</p>
<dl class="section note"><dt>Note</dt><dd>Only single master mode is supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to I2C peripheral register block.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>Pointer to sequence structure defining the I2C transfer to take place. The referenced structure must exist until the transfer has fully completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns status for ongoing transfer: <ul>
<li><a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c">i2cTransferInProgress</a> - indicates that transfer not finished. </li>
<li>otherwise some sort of error has occurred. </li>
</ul>
</dd></dl>

<p>Definition at line <a class="el" href="em__i2c_8c_source.html#l00807">807</a> of file <a class="el" href="em__i2c_8c_source.html">em_i2c.c</a>.</p>

<p>References <a class="el" href="group__EFM32G__I2C__BitFields.html#ga4c7d4b074406d855fea4880e58519c53">_I2C_IFC_MASK</a>, <a class="el" href="structI2C__TransferSeq__TypeDef.html#a8768a91a4d0d3c66e72e8fdb981b5c63">I2C_TransferSeq_TypeDef::buf</a>, <a class="el" href="structI2C__TypeDef.html#a16d77fc238ce699a694fb4a431d46853">I2C_TypeDef::CMD</a>, <a class="el" href="structI2C__TransferSeq__TypeDef.html#aa9eb709e67fbaa4acb9a4964ca5174cb">I2C_TransferSeq_TypeDef::flags</a>, <a class="el" href="group__EFM32G890F128__Peripheral__Declaration.html#ga86abb2e8858d177c04e60c41e9242045">I2C0</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gaa5d8a7b4cf747e7c876e3c221ce33f6f">I2C_CMD_ABORT</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga666be3339c1aa6aa2cac11bf6e6f7b06">I2C_CMD_CLEARPC</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga04c82f0d85f5da0d94685cd85666e29e">I2C_CMD_CLEARTX</a>, <a class="el" href="group__I2C.html#ga0c1779663a5ebf44e956ea3f591b4e61">I2C_FLAG_READ</a>, <a class="el" href="group__I2C.html#gaf9fc47d6ee1c66405dc491f7a4c3b8fc">I2C_FLAG_WRITE_READ</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#gab345bfd7135a3d796e9167e14ad7ed2e">I2C_IF_ACK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga56d250d829264822613f469e643d15ed">I2C_IF_MSTOP</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga680542dbba8b23cf70e5c414e8af6545">I2C_IF_NACK</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga178ce96f3ba88c84d538a4377aaca7a0">I2C_IF_RXDATAV</a>, <a class="el" href="group__EFM32G__I2C__BitFields.html#ga41ac92fca39a95d125e4190b5853f73d">I2C_STATE_BUSY</a>, <a class="el" href="group__I2C.html#ga67983b3dbe7f028a97f765e421b3df56">I2C_Transfer()</a>, <a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa1f1df5a76a71b423083d6a327d38ca1c">i2cTransferInProgress</a>, <a class="el" href="group__I2C.html#gga7c781ec28ae11e3e28892de7aa07a00fa49fe8ab19b9167d78c4b2abec7a511fc">i2cTransferUsageFault</a>, <a class="el" href="structI2C__TypeDef.html#a647fddc5196ae97150039621c847948f">I2C_TypeDef::IEN</a>, <a class="el" href="structI2C__TypeDef.html#aaf632fc96f518c0dedcfaf90c1b53df8">I2C_TypeDef::IF</a>, <a class="el" href="structI2C__TypeDef.html#a25521276d00ff1fcbf298da7a4d90909">I2C_TypeDef::IFC</a>, <a class="el" href="structI2C__TransferSeq__TypeDef.html#a92b6d16d6d3b3e4d5650740fa306a285">I2C_TransferSeq_TypeDef::len</a>, <a class="el" href="structI2C__TypeDef.html#a2fe785eb93cd3d262aa7a9d751075d7f">I2C_TypeDef::RXDATA</a>, and <a class="el" href="structI2C__TypeDef.html#a223344ccee65c5b365a69f09489c8652">I2C_TypeDef::STATE</a>.</p>

<p>Referenced by <a class="el" href="group__I2CSPM.html#ga076766b20012fb6a0cdaaf0f2c760795">I2CSPM_Transfer()</a>, and <a class="el" href="cpt112s__i2c_8c.html#a0be56a687b1624b76fec1289ef075017">performI2CTransfer()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Mar 10 2016 14:22:27 for EFM32 Gecko Software Documentation by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
