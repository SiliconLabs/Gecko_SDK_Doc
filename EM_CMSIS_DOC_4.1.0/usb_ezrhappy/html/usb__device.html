<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs EZR32 USB Stack: USB device stack library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="usb_device">USB device stack library </a></h1><p>The source files for the USB device stack resides in the usb directory and follows the naming convention: em_usbd<em>nnn</em>.c/h.</p>
<ul>
<li><a class="el" href="usb__device.html#usb_device_intro">Introduction</a> </li>
<li><a class="el" href="usb__device.html#usb_device_api">The device stack API</a> </li>
<li><a class="el" href="usb__device.html#usb_device_conf">Configuring the device stack</a> </li>
<li><a class="el" href="usb__device.html#usb_device_powersave">Energy-saving modes</a> </li>
<li><a class="el" href="usb__device.html#usb_device_example1">Vendor unique device example application</a></li>
</ul>
<p><br/>
 </p>
<h2><a class="anchor" id="usb_device_intro">
Introduction</a></h2>
<p>The USB device protocol stack provides an API which makes it possible to create USB devices with a minimum of effort. The device stack supports control, bulk, interrupt and isochronous transfers.</p>
<p>The stack is highly configurable to suit various needs, it does also contain useful debugging features together with several demonstration projects to get you started fast.</p>
<p>We recommend that you read through this documentation, then proceed to build and test a few example projects before you start designing your own device.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="usb_device_api">
The device stack API</a></h2>
<p>This section contains brief descriptions of the functions in the API. You will find detailed information on input and output parameters and return values by clicking on the hyperlinked function names. It is also a good idea to study the code in the USB demonstration projects.</p>
<p>Your application code must include one header file: <em><a class="el" href="em__usb_8h.html" title="USB protocol stack library API for EFM32/EZR32.">em_usb.h</a></em>.</p>
<p>All functions defined in the API can be called from within interrupt handlers.</p>
<p>The USB stack use a hardware timer to keep track of time. TIMER0 is the default choice, refer to <a class="el" href="usb__device.html#usb_device_conf">Configuring the device stack</a> for other possibilities. Your application must not use the selected timer.</p>
<p><b>Pitfalls:</b><br/>
 The USB peripheral will fill your receive buffers in quantities of WORD's (4 bytes). Transmit and receive buffers must be WORD aligned, in addition when allocating storage for receive buffers, round size up to next WORD boundary. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size for the relevant endpoint to avoid data corruption.</p>
<p>Transmit buffers passed to  USBD_Write()  must be statically allocated because  USBD_Write()  only initiates the transfer. When the host decide to actually perform the transfer, your data must be available.</p>
<p><br/>
 <a class="el" href="group__USB__DEVICE.html#ga0e5f5bd847e7cc1c4c384bb6b7f0ce77">USBD_Init()</a> <br/>
 This function is called to register your device and all its properties with the device stack. The application must fill in a <a class="el" href="structUSBD__Init__TypeDef.html">USBD_Init_TypeDef</a> structure prior to calling. Refer to <a class="el" href="usb__device.html#DeviceInitCallbacks">DeviceInitCallbacks</a> for the optional callback functions defined within this structure. When this function has been called your device is ready to be enumerated by the USB host.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga9e0a1cf705301d9e035feff27ea41cda">USBD_Read()</a>, <a class="el" href="group__USB__DEVICE.html#ga656c8d2935af97156bc0babdc43c32ee">USBD_Write()</a> <br/>
 These functions initiate data transfers. <br/>
  USBD_Read()  initiate a transfer of data <em>from</em> host <em>to</em> device (an <em>OUT</em> transfer in USB terminology). <br/>
  USBD_Write()  initiate a transfer of data <em>from</em> device <em>to</em> host (an <em>IN</em> transfer).</p>
<p>When the USB host actually performs the transfer, your application will be notified by means of a callback function which you provide (optionally). Refer to <a class="el" href="usb__device.html#TransferCallback">TransferCallback</a> for details of the callback functionality.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga83f32dfa4f6a5d010e413967850c52b2">USBD_AbortTransfer()</a>, <a class="el" href="group__USB__DEVICE.html#ga325117af9b3a9ad1df068cf3b19dc1ba">USBD_AbortAllTransfers()</a> <br/>
 These functions terminate transfers that are initiated, but has not yet taken place. If a transfer is initiated with  USBD_Read()
    or USBD_Write(),  but the USB host never actually peform the transfers, these functions will deactivate the transfer setup to make the USB device endpoint hardware ready for new (and potentially) different transfers.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga71b9264662d74666e4b058984e3346e5">USBD_Connect()</a>, <a class="el" href="group__USB__DEVICE.html#ga2d952f8cf9bde552cfd5559ae47e70fc">USBD_Disconnect()</a> <br/>
 These functions turns the data-line (D+ or D-) pullup on or off. They can be used to force reenumeration. It's good practice to delay at least one second between  USBD_Disconnect() and USBD_Connect()  to allow the USB host to unload the currently active device driver.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga9eb41fa7508126bea30d672b777e250f">USBD_EpIsBusy()</a> <br/>
 Check if an endpoint is busy.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga9bf435e62169bfb3ee0a43ef0e9d009d">USBD_StallEp()</a>, <a class="el" href="group__USB__DEVICE.html#gacb0ed1c21fd4aecfe96060ea87a617a8">USBD_UnStallEp()</a> <br/>
 These functions stalls or un-stalls an endpoint. This functionality may not be needed by your application, but the USB device stack use them in response to standard setup commands SET_FEATURE and CLEAR_FEATURE. They may be useful when implementing some USB classes, e.g. a mass storage device use them extensively.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga9fb12718f509c578656e4fc08bc40f69">USBD_RemoteWakeup()</a> <br/>
 Used in SUSPENDED state (see <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>) to signal resume to host. It's the applications responsibility to adhere to the USB standard which states that a device can not signal resume before it has been SUSPENDED for at least 5 ms. The function will also check the configuration descriptor defined by the application to see if it is legal for the device to signal resume.</p>
<p><a class="el" href="group__USB__DEVICE.html#gab4e55bb0aacaa90aab28a79e9b131b0f">USBD_GetUsbState()</a> <br/>
 Returns the device USB state (see <a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a>). Refer to Figure 9-1. "Device State Diagram" in the USB revision 2.0 specification.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga7c151fd9cf5ab159d8a74cf65a27975f">USBD_GetUsbStateName()</a> <br/>
 Returns a text string naming a given USB device state.</p>
<p><a class="el" href="group__USB__DEVICE.html#ga958a83c23eaa9fd51672808ac7c3fa65">USBD_SafeToEnterEM2()</a> <br/>
 Check if it is ok to enter energy mode EM2. Refer to the <a class="el" href="usb__device.html#usb_device_powersave">Energy-saving modes</a> section for more information.</p>
<p><br/>
 <a class="anchor" id="TransferCallback"></a> <b>The transfer complete callback function:</b> <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#ga521fe3060be2a8de6fdd5ee01193958b" title="USB transfer callback function.">USB_XferCompleteCb_TypeDef()</a> is called when a transfer completes. It is called with three parameters, the status of the transfer, the number of bytes transferred and the number of bytes remaining. It may not always be needed to have a callback on transfer completion, but you should keep in mind that a transfer may be aborted when you least expect it. A transfer will be aborted if host stalls the endpoint, if host resets your device, if host unconfigures your device or if you unplug your device cable and the device is selfpowered.  USB_XferCompleteCb_TypeDef()  is also called if your application use  USBD_AbortTransfer() or USBD_AbortAllTransfers()
     calls. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This callback is called from within an interrupt handler with interrupts disabled.</dd></dl>
<p><br/>
 <a class="anchor" id="DeviceInitCallbacks"></a> <b>Optional callbacks passed to the stack via the <a class="el" href="group__USB__DEVICE.html#ga0e5f5bd847e7cc1c4c384bb6b7f0ce77">USBD_Init()</a> function:</b> <br/>
 <br/>
 These callbacks are all optional, and it is up to the application programmer to decide if the application needs the functionality they provide. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>These callbacks are all called from within an interrupt handler with interrupts disabled.</dd></dl>
<p><a class="el" href="group__USB__DEVICE.html#gafad47dbaf3af2786eec106d0594b9d4b" title="USB Reset callback function.">USBD_UsbResetCb_TypeDef()</a> is called each time reset signalling is sensed on the USB wire.</p>
<p><br/>
 <a class="el" href="group__USB__DEVICE.html#ga0dc83723a1a28a1b6bea080d36125567" title="USB Start Of Frame (SOF) interrupt callback function.">USBD_SofIntCb_TypeDef()</a> is called with framenumber as a parameter on each SOF interrupt.</p>
<p><br/>
 <a class="el" href="group__USB__DEVICE.html#ga6f06aa8508bb655941774d7f688ffb85" title="USB State change callback function.">USBD_DeviceStateChangeCb_TypeDef()</a> is called whenever the device state change. Useful for detecting e.g. SUSPENDED state change in order to reduce current consumption of buspowered devices. The USB HID keyboard example project has a good example on how to use this callback.</p>
<p><br/>
 <a class="el" href="group__USB__DEVICE.html#gaba846e8094973b242a43be1edcfc8451" title="USB power mode callback function.">USBD_IsSelfPoweredCb_TypeDef()</a> is called by the device stack when host queries the device with a standard setup GET_STATUS command to check if the device is currently selfpowered or buspowered. This feature is only applicable on selfpowered devices which also works when only buspower is available.</p>
<p><br/>
 <a class="el" href="group__USB__DEVICE.html#gaeab2bf0232b86efd7afb6ad54ae950a6" title="USB setup request callback function.">USBD_SetupCmdCb_TypeDef()</a> is called each time a setup command is received from host. Use this callback to override or extend the default handling of standard setup commands, and to implement class or vendor specific setup commands. The USB HID keyboard example project has a good example on how to use this callback.</p>
<p><br/>
 <b>Utility functions:</b> <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#gac49ccf1d69a08567d1a5911b0312e735" title="Transmit a single char on the debug serial port.">USB_PUTCHAR()</a> Transmit a single char on the debug serial port. <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#ga7276e056a2f6aeb99240f72529f41f8f" title="Transmit a zero terminated string on the debug serial port.">USB_PUTS()</a> Transmit a zero terminated string on the debug serial port. <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb" title="Transmit &quot;printf&quot; formated data on the debug serial port.">USB_PRINTF()</a> Transmit "printf" formated data on the debug serial port. <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#gaedc267ca571518980b7f7f4392386844" title="Return an error message string for a given error code.">USB_GetErrorMsgString()</a> Return an error message string for a given error code. <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#ga543c505ec86acb344f7f0c00c55fc266" title="Format and print a text string given an error code, prepends an optional user supplied...">USB_PrintErrorMsgString()</a> Format and print a text string given an error code, prepends an optional user supplied leader string. <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#gabb1c11cad365c7c3b99a3e7826035951" title="Active wait millisecond delay function.">USBTIMER_DelayMs()</a> Active wait millisecond delay function. Can also be used inside interrupt handlers. <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#gafef1ec052374683fb7f26c5d27645e2c" title="Active wait microsecond delay function.">USBTIMER_DelayUs()</a> Active wait microsecond delay function. Can also be used inside interrupt handlers. <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#ga21c87b800d87fd731173dd4f48f23c28" title="Activate the hardware timer used to pace the 1 millisecond timer system.">USBTIMER_Init()</a> Initialize the timer system. Called by  
          USBD_Init(),  but your application must call it again to reinitialize whenever you change the HFPERCLK frequency. <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#gac2a406f16d989b04c4fc5b37d5c10b45" title="Start a timer.">USBTIMER_Start()</a> Start a timer. You can configure the USB device stack to provide any number of timers. The timers have 1 ms resolution, your application is notified of timeout by means of a callback. <br/>
 <br/>
 <a class="el" href="group__USB__COMMON.html#gab73c922427cf0d509788a8063451703f" title="Stop a timer.">USBTIMER_Stop()</a> Stop a timer.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="usb_device_conf">
Configuring the device stack</a></h2>
<p>Your application must provide a header file named <em>usbconfig.h</em>. This file must contain the following #define's:<br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
#define USB_DEVICE       // Compile the stack for device mode.
#define NUM_EP_USED n    // Your application use 'n' endpoints in
                         // addition to endpoint 0. </pre></div><p><br/>
 <em>usbconfig.h</em> may define the following items: <br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
#define NUM_APP_TIMERS n // Your application needs 'n' timers

#define DEBUG_USB_API    // Turn on API debug diagnostics.

// Some utility functions in the API needs printf. These
// functions have "print" in their name. This macro enables
// these functions.
#define USB_USE_PRINTF   // Enable utility print functions.

// Define a function for transmitting a single char on the serial port.
extern int RETARGET_WriteChar(char c);
#define USER_PUTCHAR  RETARGET_WriteChar

#define USB_TIMER USB_TIMERn  // Select which hardware timer the USB stack
                              // is allowed to use. Valid values are n=0,1,2...
                              // corresponding to TIMER0, TIMER1, ...
                              // If not specified, TIMER0 is used

#define USB_VBUS_SWITCH_NOT_PRESENT  // Hardware does not have a VBUS switch

#define USB_CORECLK_HFRCO   // Devices supporting crystal-less USB can use
                            // HFRCO as core clock, default is HFXO
</pre></div><p><br/>
 You are strongly encouraged to start application development with DEBUG_USB_API turned on. When DEBUG_USB_API is turned on and USER_PUTCHAR is defined, useful debugging information will be output on the development kit serial port. Compiling with the DEBUG_EFM_USER flag will also enable all asserts in both <em>emlib</em> and in the USB stack. If asserts are enabled and USER_PUTCHAR defined, assert texts will be output on the serial port.</p>
<p>You application must include <em>retargetserial.c</em> if DEBUG_USB_API is defined and <em>retargetio.c</em> if USB_USE_PRINTF is defined. These files reside in the <em>drivers</em> directory in the software package for your development board. Refer to <a class="el" href="usb__device.html#usb_device_powersave">Energy-saving modes</a> for energy-saving mode configurations.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="usb_device_powersave">
Energy-saving modes</a></h2>
<p>The device stack provides two energy saving levels. The first level is to set the USB peripheral in energy saving mode, the next level is to enter Energy Mode 2 (EM2). These energy saving modes can be applied when the device is suspended by the USB host, or when when the device is not connected to a USB host. In addition to this an application can use energy modes EM1 and EM2. There are no restrictions on when EM1 can be entered, EM2 can only be entered when the USB device is suspended or detached from host.</p>
<p>Energy-saving modes are selected with a #define in <em>usbconfig.h</em>, default selection is to not use any energy saving modes.<br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
#define USB_PWRSAVE_MODE (USB_PWRSAVE_MODE_ONSUSPEND | USB_PWRSAVE_MODE_ENTEREM2)</pre></div><p>There are three flags available, the flags can be or'ed together as shown above.</p>
<p><b>#define USB_PWRSAVE_MODE_ONSUSPEND</b><br/>
 Set USB peripheral in low power mode on suspend.</p>
<p><b>#define USB_PWRSAVE_MODE_ONVBUSOFF</b><br/>
 Set USB peripheral in low power mode when not attached to a host. This mode assumes that the internal voltage regulator is used and that the VREGI pin of the chip is connected to VBUS. This option can not be used with bus-powered devices.</p>
<p><b>#define USB_PWRSAVE_MODE_ENTEREM2</b><br/>
 Enter EM2 when USB peripheral is in low power mode.</p>
<p>When the USB peripheral is set in low power mode, it must be clocked by a 32kHz clock. Both LFXO and LFRCO can be used, but only LFXO guarantee USB specification compliance. Selection is done with a #define in <em>usbconfig.h</em>.<br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
#define USB_USBC_32kHz_CLK   USB_USBC_32kHz_CLK_LFXO </pre></div><p> Two flags are available, <b>USB_USBC_32kHz_CLK_LFXO</b> and <b>USB_USBC_32kHz_CLK_LFRCO</b>. <b>USB_USBC_32kHz_CLK_LFXO</b> is selected by default.</p>
<p>The USB HID keyboard and Mass Storage device example projects demonstrate different energy-saving modes.</p>
<p><b>Example 1:</b> Leave all energy saving to the stack, the device enters EM2 on suspend and when detached from host. <br/>
 </p>
<div class="fragment"><pre class="fragment">
In usbconfig.h:

#define USB_PWRSAVE_MODE (USB_PWRSAVE_MODE_ONSUSPEND | USB_PWRSAVE_MODE_ONVBUSOFF | USB_PWRSAVE_MODE_ENTEREM2)
  </pre></div><p><br/>
 <b>Example 2:</b> Let the stack control energy saving in the USB periheral but let your application control energy modes EM1 and EM2. <br/>
 </p>
<div class="fragment"><pre class="fragment">
In usbconfig.h:

#define USB_PWRSAVE_MODE (USB_PWRSAVE_MODE_ONSUSPEND | USB_PWRSAVE_MODE_ONVBUSOFF)

In application code:

if ( USBD_SafeToEnterEM2() )
  EMU_EnterEM2(true);
else
  EMU_EnterEM1(); </pre></div><p><br/>
 </p>
<h2><a class="anchor" id="usb_device_example1">
Vendor unique device example application</a></h2>
<p>This example represents the most simple USB device imaginable. It's purpose is to turn user LED's on or off under control of vendor unique setup commands. The device will rely on <em>libusb</em> device driver on the host, a host application <em>EFM32-LedApp.exe</em> is bundled with the example.</p>
<p>The main() is really simple ! <br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
#include "em_usb.h"

#include "descriptors.h"

int main( void )
{
  BSP_Init(BSP_INIT_DEFAULT); // Initialize DK board register access
  CMU_ClockSelectSet( cmuClock_HF, cmuSelect_HFXO );
  BSP_LedsSet(0);             // Turn off all LED's

  ConsoleDebugInit();         // Initialize UART for debug diagnostics

  USB_PUTS( "\nEFM32 USB LED Vendor Unique Device example\n" );

  USBD_Init( &amp;initstruct );   // GO !

  //When using a debugger it is pratical to uncomment the following three
  //lines to force host to re-enumerate the device.

  //USBD_Disconnect();
  //USBTIMER_DelayMs( 1000 );
  //USBD_Connect();

  for (;;) {}
} </pre></div><p><br/>
 Configure the device stack in <em>usbconfig.h</em>: <br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
#define USB_DEVICE                        // Compile stack for device mode.

// **************************************************************************
**                                                                         **
** Specify number of endpoints used (in addition to EP0).                  **
**                                                                         **
*****************************************************************************
#define NUM_EP_USED 0                     // EP0 is the only endpoint used.

// **************************************************************************
**                                                                         **
** Configure serial port debug output.                                     **
**                                                                         **
*****************************************************************************
// Prototype a function for transmitting a single char on the serial port.
extern int RETARGET_WriteChar(char c);
#define USER_PUTCHAR RETARGET_WriteChar

// Enable debug diagnostics from API functions (illegal input params etc.)
#define DEBUG_USB_API </pre></div><p><br/>
 Define device properties and fill in USB initstruct in <em>descriptors.h</em>: <br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
EFM32_ALIGN(4)
static const USB_DeviceDescriptor_TypeDef deviceDesc __attribute__ ((aligned(4))) =
{
  .bLength            = USB_DEVICE_DESCSIZE,
  .bDescriptorType    = USB_DEVICE_DESCRIPTOR,
  .bcdUSB             = 0x0200,
  .bDeviceClass       = 0xFF,
  .bDeviceSubClass    = 0,
  .bDeviceProtocol    = 0,
  .bMaxPacketSize0    = USB_FS_CTRL_EP_MAXSIZE,
  .idVendor           = 0x10C4,
  .idProduct          = 0x0001,
  .bcdDevice          = 0x0000,
  .iManufacturer      = 1,
  .iProduct           = 2,
  .iSerialNumber      = 3,
  .bNumConfigurations = 1
};

EFM32_ALIGN(4)
static const uint8_t configDesc[] __attribute__ ((aligned(4)))=
{
  // *** Configuration descriptor ***
  USB_CONFIG_DESCSIZE,            // bLength
  USB_CONFIG_DESCRIPTOR,          // bDescriptorType
  USB_CONFIG_DESCSIZE +           // wTotalLength (LSB)
  USB_INTERFACE_DESCSIZE,
  (USB_CONFIG_DESCSIZE +          // wTotalLength (MSB)
  USB_INTERFACE_DESCSIZE)&gt;&gt;8,
  1,                              // bNumInterfaces
  1,                              // bConfigurationValue
  0,                              // iConfiguration
  CONFIG_DESC_BM_RESERVED_D7 |    // bmAttrib: Self powered
  CONFIG_DESC_BM_SELFPOWERED,
  CONFIG_DESC_MAXPOWER_mA( 100 ), // bMaxPower: 100 mA

  // *** Interface descriptor ***
  USB_INTERFACE_DESCSIZE,         // bLength
  USB_INTERFACE_DESCRIPTOR,       // bDescriptorType
  0,                              // bInterfaceNumber
  0,                              // bAlternateSetting
  NUM_EP_USED,                    // bNumEndpoints
  0xFF,                           // bInterfaceClass
  0,                              // bInterfaceSubClass
  0,                              // bInterfaceProtocol
  0,                              // iInterface
};

STATIC_CONST_STRING_DESC_LANGID( langID, 0x04, 0x09 );
STATIC_CONST_STRING_DESC( iManufacturer, 'E','n','e','r','g','y',' ',       \
                                         'M','i','c','r','o',' ','A','S' );
STATIC_CONST_STRING_DESC( iProduct     , 'V','e','n','d','o','r',' ',       \
                                         'U','n','i','q','u','e',' ',       \
                                         'L','E','D',' ',                   \
                                         'D','e','v','i','c','e' );
STATIC_CONST_STRING_DESC( iSerialNumber, '0','0','0','0','0','0',           \
                                         '0','0','1','2','3','4' );

static const void * const strings[] =
{
  &amp;langID,
  &amp;iManufacturer,
  &amp;iProduct,
  &amp;iSerialNumber
};

// Endpoint buffer sizes
// 1 = single buffer, 2 = double buffering, 3 = tripple buffering ...
static const uint8_t bufferingMultiplier[ NUM_EP_USED + 1 ] = { 1 };

static const USBD_Callbacks_TypeDef callbacks =
{
  .usbReset        = NULL,
  .usbStateChange  = NULL,
  .setupCmd        = SetupCmd,
  .isSelfPowered   = NULL,
  .sofInt          = NULL
};

static const USBD_Init_TypeDef initstruct =
{
  .deviceDescriptor    = &amp;deviceDesc,
  .configDescriptor    = configDesc,
  .stringDescriptors   = strings,
  .numberOfStrings     = sizeof(strings)/sizeof(void*),
  .callbacks           = &amp;callbacks,
  .bufferingMultiplier = bufferingMultiplier
};  </pre></div><p><br/>
 Now we have to implement vendor unique USB setup commands to control the LED's (see callbacks variable above). Notice that the buffer variable below is statically allocated because  USBD_Write()  only initiates the transfer. When the host actually performs the transfer, the SetupCmd() function will have returned ! <br/>
 <br/>
</p>
<div class="fragment"><pre class="fragment">
#define VND_GET_LEDS 0x10
#define VND_SET_LED  0x11

static int SetupCmd( const USB_Setup_TypeDef *setup )
{
  int retVal;
  uint16_t leds;
  static uint32_t buffer;
  uint8_t *pBuffer = (uint8_t*)&amp;buffer;

  retVal = USB_STATUS_REQ_UNHANDLED;

  if ( setup-&gt;Type == USB_SETUP_TYPE_VENDOR )
  {
    switch ( setup-&gt;bRequest )
    {
      case VND_GET_LEDS:
      // ********************
        *pBuffer = BSP_LedsGet() &amp; 0x1F;
        retVal = USBD_Write( 0, pBuffer, setup-&gt;wLength, NULL );
        break;

      case VND_SET_LED:
      // ********************
        leds = DVK_getLEDs() &amp; 0x1F;
        if ( setup-&gt;wValue )
        {
          leds |= LED0 &lt;&lt; setup-&gt;wIndex;
        }
        else
        {
          leds &amp;= ~( LED0 &lt;&lt; setup-&gt;wIndex );
        }
        BSP_LedsSet( leds );
        retVal = USB_STATUS_OK;
        break;
    }
  }

  return retVal;
}</pre></div> </div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Thu Sep 10 08:17:26 2015</small> for Silicon Labs EZR32 USB Stack by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
