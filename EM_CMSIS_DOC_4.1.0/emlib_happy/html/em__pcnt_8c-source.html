<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs EFM32 emlib Peripheral Library: release/EM_CMSIS_P1_4.1.0/emlib/src/em_pcnt.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_99634199317e4752b1934502e0d836c4.html">release</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_382a31a6d951115af2a1e7624d96c391.html">EM_CMSIS_P1_4.1.0</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_2bb29a122c859e975fa16e4cc28d11d7.html">emlib</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_f09ea23800c86a7e4fd7d642f3adf232.html">src</a></div>
<h1>em_pcnt.c</h1><a href="em__pcnt_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************/</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include "<a class="code" href="em__pcnt_8h.html">em_pcnt.h</a>"</span>
<a name="l00034"></a>00034 <span class="preprocessor">#if defined(PCNT_COUNT) &amp;&amp; (PCNT_COUNT &gt; 0)</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="preprocessor">#include "<a class="code" href="em__cmu_8h.html">em_cmu.h</a>"</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include "<a class="code" href="em__assert_8h.html">em_assert.h</a>"</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include "<a class="code" href="em__bus_8h.html">em_bus.h</a>"</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">/***************************************************************************/</span>
<a name="l00045"></a>00045 <span class="comment">/***************************************************************************/</span>
<a name="l00051"></a>00051 <span class="comment">/*******************************************************************************</span>
<a name="l00052"></a>00052 <span class="comment"> *******************************   DEFINES   ***********************************</span>
<a name="l00053"></a>00053 <span class="comment"> ******************************************************************************/</span>
<a name="l00054"></a>00054 
<a name="l00059"></a>00059 <span class="preprocessor">#if (PCNT_COUNT == 1)</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#define PCNT_REF_VALID(ref)    ((ref) == PCNT0)</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#elif (PCNT_COUNT == 2)</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#define PCNT_REF_VALID(ref)    (((ref) == PCNT0) || ((ref) == PCNT1))</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#elif (PCNT_COUNT == 3)</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#define PCNT_REF_VALID(ref)    (((ref) == PCNT0) || ((ref) == PCNT1) || \</span>
<a name="l00065"></a>00065 <span class="preprocessor">                                ((ref) == PCNT2))</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#error "Undefined number of pulse counters (PCNT)."</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>
<a name="l00073"></a>00073 <span class="comment">/*******************************************************************************</span>
<a name="l00074"></a>00074 <span class="comment"> **************************   LOCAL FUNCTIONS   ********************************</span>
<a name="l00075"></a>00075 <span class="comment"> ******************************************************************************/</span>
<a name="l00076"></a>00076 
<a name="l00079"></a>00079 <span class="comment">/***************************************************************************/</span>
<a name="l00089"></a>00089 __STATIC_INLINE <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PCNT_Map(PCNT_TypeDef *pcnt)
<a name="l00090"></a>00090 {
<a name="l00091"></a>00091   <span class="keywordflow">return</span> ((uint32_t)pcnt - PCNT0_BASE) / 0x400;
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="comment">/***************************************************************************/</span>
<a name="l00106"></a>00106 __STATIC_INLINE <span class="keywordtype">void</span> PCNT_Sync(PCNT_TypeDef *pcnt, uint32_t mask)
<a name="l00107"></a>00107 {
<a name="l00108"></a>00108   <span class="comment">/* Avoid deadlock if modifying the same register twice when freeze mode is</span>
<a name="l00109"></a>00109 <span class="comment">   * activated. */</span>
<a name="l00110"></a>00110   <span class="keywordflow">if</span> (pcnt-&gt;FREEZE &amp; PCNT_FREEZE_REGFREEZE)
<a name="l00111"></a>00111   {
<a name="l00112"></a>00112     <span class="keywordflow">return</span>;
<a name="l00113"></a>00113   }
<a name="l00114"></a>00114 
<a name="l00115"></a>00115   <span class="comment">/* Wait for any pending previous write operation to have been completed in low</span>
<a name="l00116"></a>00116 <span class="comment">   * frequency domain. */</span>
<a name="l00117"></a>00117   <span class="keywordflow">while</span> (pcnt-&gt;SYNCBUSY &amp; mask)
<a name="l00118"></a>00118     ;
<a name="l00119"></a>00119 }
<a name="l00120"></a>00120 
<a name="l00123"></a>00123 <span class="comment">/*******************************************************************************</span>
<a name="l00124"></a>00124 <span class="comment"> **************************   GLOBAL FUNCTIONS   *******************************</span>
<a name="l00125"></a>00125 <span class="comment"> ******************************************************************************/</span>
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="comment">/***************************************************************************/</span>
<a name="l00141"></a><a class="code" href="group__PCNT.html#gcb21126956add214b4af318f61fd17cd">00141</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#gcb21126956add214b4af318f61fd17cd">PCNT_CounterReset</a>(PCNT_TypeDef *pcnt)
<a name="l00142"></a>00142 {
<a name="l00143"></a>00143   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="comment">/* Enable reset of CNT and TOP register */</span>
<a name="l00146"></a>00146   <a class="code" href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite</a>(&amp;(pcnt-&gt;CTRL), _PCNT_CTRL_RSTEN_SHIFT, 1);
<a name="l00147"></a>00147 
<a name="l00148"></a>00148   <span class="comment">/* Disable reset of CNT and TOP register */</span>
<a name="l00149"></a>00149   <a class="code" href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite</a>(&amp;(pcnt-&gt;CTRL), _PCNT_CTRL_RSTEN_SHIFT, 0);
<a name="l00150"></a>00150 }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="comment">/***************************************************************************/</span>
<a name="l00177"></a><a class="code" href="group__PCNT.html#g4f29435f61c53e4a6e86947fe1980be9">00177</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#g4f29435f61c53e4a6e86947fe1980be9">PCNT_CounterTopSet</a>(PCNT_TypeDef *pcnt, uint32_t count, uint32_t top)
<a name="l00178"></a>00178 {
<a name="l00179"></a>00179   uint32_t ctrl;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="preprocessor">#ifdef PCNT0</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (PCNT0 == pcnt)
<a name="l00185"></a>00185   {
<a name="l00186"></a>00186     EFM_ASSERT((1&lt;&lt;<a class="code" href="group__PCNT.html#gf9147680cf4def78a0d85a8056ac305d">PCNT0_CNT_SIZE</a>) &gt; count);
<a name="l00187"></a>00187     EFM_ASSERT((1&lt;&lt;<a class="code" href="group__PCNT.html#gf9147680cf4def78a0d85a8056ac305d">PCNT0_CNT_SIZE</a>) &gt; top);
<a name="l00188"></a>00188   }
<a name="l00189"></a>00189 <span class="preprocessor">#endif</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span>
<a name="l00191"></a>00191 <span class="preprocessor">#ifdef PCNT1</span>
<a name="l00192"></a>00192 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (PCNT1 == pcnt)
<a name="l00193"></a>00193   {
<a name="l00194"></a>00194     EFM_ASSERT((1&lt;&lt;PCNT1_CNT_SIZE) &gt; count);
<a name="l00195"></a>00195     EFM_ASSERT((1&lt;&lt;PCNT1_CNT_SIZE) &gt; top);
<a name="l00196"></a>00196   }
<a name="l00197"></a>00197 <span class="preprocessor">#endif</span>
<a name="l00198"></a>00198 <span class="preprocessor"></span>
<a name="l00199"></a>00199 <span class="preprocessor">#ifdef PCNT2</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (PCNT2 == pcnt)
<a name="l00201"></a>00201   {
<a name="l00202"></a>00202     EFM_ASSERT((1&lt;&lt;PCNT2_CNT_SIZE) &gt; count);
<a name="l00203"></a>00203     EFM_ASSERT((1&lt;&lt;PCNT2_CNT_SIZE) &gt; top);
<a name="l00204"></a>00204   }
<a name="l00205"></a>00205 <span class="preprocessor">#endif</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>
<a name="l00207"></a>00207   <span class="comment">/* Keep current control setting, must be restored */</span>
<a name="l00208"></a>00208   ctrl = pcnt-&gt;CTRL;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210   <span class="comment">/* If enabled, disable pulse counter before changing values */</span>
<a name="l00211"></a>00211   <span class="keywordflow">if</span> ((ctrl &amp; _PCNT_CTRL_MODE_MASK) != PCNT_CTRL_MODE_DISABLE)
<a name="l00212"></a>00212   {
<a name="l00213"></a>00213     PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL);
<a name="l00214"></a>00214     pcnt-&gt;CTRL = (ctrl &amp; ~_PCNT_CTRL_MODE_MASK) | PCNT_CTRL_MODE_DISABLE;
<a name="l00215"></a>00215   }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217   <span class="comment">/* Load into TOPB */</span>
<a name="l00218"></a>00218   PCNT_Sync(pcnt, PCNT_SYNCBUSY_TOPB);
<a name="l00219"></a>00219   pcnt-&gt;TOPB = count;
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="comment">/* Load TOPB value into TOP */</span>
<a name="l00222"></a>00222   PCNT_Sync(pcnt, PCNT_SYNCBUSY_TOPB | PCNT_SYNCBUSY_CMD);
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="comment">/* This bit has no effect on rev. C and onwards parts - for compatibility */</span>
<a name="l00225"></a>00225   pcnt-&gt;CMD = PCNT_CMD_LTOPBIM;
<a name="l00226"></a>00226   PCNT_Sync(pcnt, PCNT_SYNCBUSY_CMD);
<a name="l00227"></a>00227 
<a name="l00228"></a>00228   <span class="comment">/* Load TOP into CNT */</span>
<a name="l00229"></a>00229   pcnt-&gt;CMD = PCNT_CMD_LCNTIM;
<a name="l00230"></a>00230 
<a name="l00231"></a>00231   <span class="comment">/* Restore TOP? ('count' setting has been loaded into pcnt-&gt;TOP, better</span>
<a name="l00232"></a>00232 <span class="comment">   * to use 'top' than pcnt-&gt;TOP in compare, since latter may in theory not</span>
<a name="l00233"></a>00233 <span class="comment">   * be visible yet.) */</span>
<a name="l00234"></a>00234   <span class="keywordflow">if</span> (top != count)
<a name="l00235"></a>00235   {
<a name="l00236"></a>00236     <span class="comment">/* Wait for command to sync LCNTIM before setting TOPB */</span>
<a name="l00237"></a>00237     PCNT_Sync(pcnt, PCNT_SYNCBUSY_CMD);
<a name="l00238"></a>00238 
<a name="l00239"></a>00239     <span class="comment">/* Load into TOPB, we don't need to check for TOPB sync complete here,</span>
<a name="l00240"></a>00240 <span class="comment">     * it has been ensured above. */</span>
<a name="l00241"></a>00241     pcnt-&gt;TOPB = top;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     <span class="comment">/* Load TOPB value into TOP */</span>
<a name="l00244"></a>00244     PCNT_Sync(pcnt, PCNT_SYNCBUSY_TOPB | PCNT_SYNCBUSY_CMD);
<a name="l00245"></a>00245     pcnt-&gt;CMD = PCNT_CMD_LTOPBIM;
<a name="l00246"></a>00246   }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   <span class="comment">/* Reenable if it was enabled */</span>
<a name="l00249"></a>00249   <span class="keywordflow">if</span> ((ctrl &amp; _PCNT_CTRL_MODE_MASK) != PCNT_CTRL_MODE_DISABLE)
<a name="l00250"></a>00250   {
<a name="l00251"></a>00251     PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL | PCNT_SYNCBUSY_CMD);
<a name="l00252"></a>00252     pcnt-&gt;CTRL = ctrl;
<a name="l00253"></a>00253   }
<a name="l00254"></a>00254 }
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="comment">/***************************************************************************/</span>
<a name="l00279"></a><a class="code" href="group__PCNT.html#ga8820c09f38c0237a58300bdfa53cb0e">00279</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#ga8820c09f38c0237a58300bdfa53cb0e">PCNT_Enable</a>(PCNT_TypeDef *pcnt, <a class="code" href="group__PCNT.html#g2fb0fc7f68c902b71b271ba5687643a4">PCNT_Mode_TypeDef</a> mode)
<a name="l00280"></a>00280 {
<a name="l00281"></a>00281   uint32_t tmp;
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00284"></a>00284 
<a name="l00285"></a>00285   <span class="comment">/* Set as specified */</span>
<a name="l00286"></a>00286   tmp  = pcnt-&gt;CTRL &amp; ~_PCNT_CTRL_MODE_MASK;
<a name="l00287"></a>00287   tmp |= (uint32_t)mode &lt;&lt; _PCNT_CTRL_MODE_SHIFT;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289   <span class="comment">/* LF register about to be modified require sync. busy check */</span>
<a name="l00290"></a>00290   PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL);
<a name="l00291"></a>00291   pcnt-&gt;CTRL = tmp;
<a name="l00292"></a>00292 }
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="preprocessor">#if defined(_PCNT_INPUT_MASK)</span>
<a name="l00295"></a>00295 <span class="preprocessor"></span><span class="comment">/***************************************************************************/</span>
<a name="l00311"></a><a class="code" href="group__PCNT.html#g3398bc56f58cfc86afeedcd4febc5753">00311</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#g3398bc56f58cfc86afeedcd4febc5753">PCNT_PRSInputEnable</a>(PCNT_TypeDef *pcnt,
<a name="l00312"></a>00312                          <a class="code" href="group__PCNT.html#ge186a75007f832e0de80ccae92528104">PCNT_PRSInput_TypeDef</a> prsInput,
<a name="l00313"></a>00313                          <span class="keywordtype">bool</span> enable)
<a name="l00314"></a>00314 {
<a name="l00315"></a>00315   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00316"></a>00316 
<a name="l00317"></a>00317   <span class="comment">/* Enable/disable the selected PRS input on the selected PCNT module. */</span>
<a name="l00318"></a>00318   <span class="keywordflow">switch</span> (prsInput)
<a name="l00319"></a>00319   {
<a name="l00320"></a>00320     <span class="comment">/* Enable/disable PRS input S0. */</span>
<a name="l00321"></a>00321     <span class="keywordflow">case</span> pcntPRSInputS0:
<a name="l00322"></a>00322       <a class="code" href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite</a>(&amp;(pcnt-&gt;INPUT), _PCNT_INPUT_S0PRSEN_SHIFT, enable);
<a name="l00323"></a>00323       <span class="keywordflow">break</span>;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     <span class="comment">/* Enable/disable PRS input S1. */</span>
<a name="l00326"></a>00326     <span class="keywordflow">case</span> <a class="code" href="group__PCNT.html#gge186a75007f832e0de80ccae925281047fba9e27fcf61b1938cf81109a06bb5e">pcntPRSInputS1</a>:
<a name="l00327"></a>00327       <a class="code" href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite</a>(&amp;(pcnt-&gt;INPUT), _PCNT_INPUT_S1PRSEN_SHIFT, enable);
<a name="l00328"></a>00328       <span class="keywordflow">break</span>;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     <span class="comment">/* Invalid parameter, asserted. */</span>
<a name="l00331"></a>00331     <span class="keywordflow">default</span>:
<a name="l00332"></a>00332       EFM_ASSERT(0);
<a name="l00333"></a>00333     <span class="keywordflow">break</span>;
<a name="l00334"></a>00334   }
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 <span class="preprocessor">#endif</span>
<a name="l00337"></a>00337 <span class="preprocessor"></span>
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="comment">/***************************************************************************/</span>
<a name="l00366"></a><a class="code" href="group__PCNT.html#g0a3a18c64e545011e4b4eaef0bdc2b3d">00366</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#g0a3a18c64e545011e4b4eaef0bdc2b3d">PCNT_FreezeEnable</a>(PCNT_TypeDef *pcnt, <span class="keywordtype">bool</span> enable)
<a name="l00367"></a>00367 {
<a name="l00368"></a>00368   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00369"></a>00369 
<a name="l00370"></a>00370   <span class="keywordflow">if</span> (enable)
<a name="l00371"></a>00371   {
<a name="l00372"></a>00372     <span class="comment">/* Wait for any ongoing LF synchronization to complete. This is just to</span>
<a name="l00373"></a>00373 <span class="comment">     * protect against the rare case when a user:</span>
<a name="l00374"></a>00374 <span class="comment">     * - modifies a register requiring LF sync</span>
<a name="l00375"></a>00375 <span class="comment">     * - then enables freeze before LF sync completed</span>
<a name="l00376"></a>00376 <span class="comment">     * - then modifies the same register again</span>
<a name="l00377"></a>00377 <span class="comment">     * since modifying a register while it is in sync progress should be</span>
<a name="l00378"></a>00378 <span class="comment">     * avoided. */</span>
<a name="l00379"></a>00379     <span class="keywordflow">while</span> (pcnt-&gt;SYNCBUSY)
<a name="l00380"></a>00380       ;
<a name="l00381"></a>00381 
<a name="l00382"></a>00382     pcnt-&gt;FREEZE = PCNT_FREEZE_REGFREEZE;
<a name="l00383"></a>00383   }
<a name="l00384"></a>00384   <span class="keywordflow">else</span>
<a name="l00385"></a>00385   {
<a name="l00386"></a>00386     pcnt-&gt;FREEZE = 0;
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388 }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="comment">/***************************************************************************/</span>
<a name="l00430"></a><a class="code" href="group__PCNT.html#g726934d28be99230a6025503fdbaf86d">00430</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#g726934d28be99230a6025503fdbaf86d">PCNT_Init</a>(PCNT_TypeDef *pcnt, <span class="keyword">const</span> <a class="code" href="structPCNT__Init__TypeDef.html">PCNT_Init_TypeDef</a> *init)
<a name="l00431"></a>00431 {
<a name="l00432"></a>00432   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inst;
<a name="l00433"></a>00433   uint32_t     tmp;
<a name="l00434"></a>00434 
<a name="l00435"></a>00435   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00436"></a>00436 
<a name="l00437"></a>00437 <span class="preprocessor">#ifdef PCNT0</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (PCNT0 == pcnt)
<a name="l00439"></a>00439   {
<a name="l00440"></a>00440     EFM_ASSERT((1&lt;&lt;<a class="code" href="group__PCNT.html#gf9147680cf4def78a0d85a8056ac305d">PCNT0_CNT_SIZE</a>) &gt; init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#5d96030a51af815ee5ecb429edddadf1">counter</a>);
<a name="l00441"></a>00441     EFM_ASSERT((1&lt;&lt;<a class="code" href="group__PCNT.html#gf9147680cf4def78a0d85a8056ac305d">PCNT0_CNT_SIZE</a>) &gt; init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#ed74c73c9af92c58c89902b0a98556a2">top</a>);
<a name="l00442"></a>00442   }
<a name="l00443"></a>00443 <span class="preprocessor">#endif</span>
<a name="l00444"></a>00444 <span class="preprocessor"></span>
<a name="l00445"></a>00445 <span class="preprocessor">#ifdef PCNT1</span>
<a name="l00446"></a>00446 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (PCNT1 == pcnt)
<a name="l00447"></a>00447   {
<a name="l00448"></a>00448     EFM_ASSERT((1&lt;&lt;PCNT1_CNT_SIZE) &gt; init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#5d96030a51af815ee5ecb429edddadf1">counter</a>);
<a name="l00449"></a>00449     EFM_ASSERT((1&lt;&lt;PCNT1_CNT_SIZE) &gt; init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#ed74c73c9af92c58c89902b0a98556a2">top</a>);
<a name="l00450"></a>00450   }
<a name="l00451"></a>00451 <span class="preprocessor">#endif</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span>
<a name="l00453"></a>00453 <span class="preprocessor">#ifdef PCNT2</span>
<a name="l00454"></a>00454 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (PCNT2 == pcnt)
<a name="l00455"></a>00455   {
<a name="l00456"></a>00456     EFM_ASSERT((1&lt;&lt;PCNT2_CNT_SIZE) &gt; init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#5d96030a51af815ee5ecb429edddadf1">counter</a>);
<a name="l00457"></a>00457     EFM_ASSERT((1&lt;&lt;PCNT2_CNT_SIZE) &gt; init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#ed74c73c9af92c58c89902b0a98556a2">top</a>);
<a name="l00458"></a>00458   }
<a name="l00459"></a>00459 <span class="preprocessor">#endif</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>
<a name="l00461"></a>00461   <span class="comment">/* Map pointer to instance */</span>
<a name="l00462"></a>00462   inst = PCNT_Map(pcnt);
<a name="l00463"></a>00463 
<a name="l00464"></a>00464 <span class="preprocessor">#if defined(_PCNT_INPUT_MASK)</span>
<a name="l00465"></a>00465 <span class="preprocessor"></span>  <span class="comment">/* Selecting the PRS channels for the PRS input sources of the PCNT. These are</span>
<a name="l00466"></a>00466 <span class="comment">   * written with a Read-Modify-Write sequence in order to keep the value of the</span>
<a name="l00467"></a>00467 <span class="comment">   * input enable bits which can be modified using PCNT_PRSInputEnable(). */</span>
<a name="l00468"></a>00468   tmp = pcnt-&gt;INPUT &amp; ~(_PCNT_INPUT_S0PRSSEL_MASK | _PCNT_INPUT_S1PRSSEL_MASK);
<a name="l00469"></a>00469   tmp |= ((uint32_t)init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#4b9c9cf1957ffe17a5360fefe7c8e67e">s0PRS</a> &lt;&lt; _PCNT_INPUT_S0PRSSEL_SHIFT) |
<a name="l00470"></a>00470          ((uint32_t)init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#66a6f9762c717eea1a81312a5a9b19a0">s1PRS</a> &lt;&lt; _PCNT_INPUT_S1PRSSEL_SHIFT);
<a name="l00471"></a>00471   pcnt-&gt;INPUT = tmp;
<a name="l00472"></a>00472 <span class="preprocessor">#endif</span>
<a name="l00473"></a>00473 <span class="preprocessor"></span>
<a name="l00474"></a>00474   <span class="comment">/* Build CTRL setting, except for mode */</span>
<a name="l00475"></a>00475   tmp = 0;
<a name="l00476"></a>00476   <span class="keywordflow">if</span> (init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#fde2d462e1190d18030bf844d7b213e2">negEdge</a>)
<a name="l00477"></a>00477   {
<a name="l00478"></a>00478     tmp |= PCNT_CTRL_EDGE_NEG;
<a name="l00479"></a>00479   }
<a name="l00480"></a>00480 
<a name="l00481"></a>00481   <span class="keywordflow">if</span> (init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#37e1864793e7dfc671b70e6dd945f7c0">countDown</a>)
<a name="l00482"></a>00482   {
<a name="l00483"></a>00483     tmp |= PCNT_CTRL_CNTDIR_DOWN;
<a name="l00484"></a>00484   }
<a name="l00485"></a>00485 
<a name="l00486"></a>00486   <span class="keywordflow">if</span> (init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#28bbdd19f0ae5755381b04e63d41d1fb">filter</a>)
<a name="l00487"></a>00487   {
<a name="l00488"></a>00488     tmp |= PCNT_CTRL_FILT;
<a name="l00489"></a>00489   }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="preprocessor">#if defined(PCNT_CTRL_HYST)</span>
<a name="l00492"></a>00492 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#0b5c589f5083a032275acb525753c114">hyst</a>)
<a name="l00493"></a>00493   {
<a name="l00494"></a>00494     tmp |= PCNT_CTRL_HYST;
<a name="l00495"></a>00495   }
<a name="l00496"></a>00496 <span class="preprocessor">#endif</span>
<a name="l00497"></a>00497 <span class="preprocessor"></span>
<a name="l00498"></a>00498 <span class="preprocessor">#if defined(PCNT_CTRL_S1CDIR)</span>
<a name="l00499"></a>00499 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#ecf46917eed2cf6dd89325093f90c773">s1CntDir</a>)
<a name="l00500"></a>00500   {
<a name="l00501"></a>00501     tmp |= PCNT_CTRL_S1CDIR;
<a name="l00502"></a>00502   }
<a name="l00503"></a>00503 <span class="preprocessor">#endif</span>
<a name="l00504"></a>00504 <span class="preprocessor"></span>
<a name="l00505"></a>00505   <span class="comment">/* Configure counter events for regular and auxiliary counter. */</span>
<a name="l00506"></a>00506 <span class="preprocessor">#if defined(_PCNT_CTRL_CNTEV_SHIFT)</span>
<a name="l00507"></a>00507 <span class="preprocessor"></span>  tmp |= init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#ae2e800065bff0098917128650cae65a">cntEvent</a> &lt;&lt; _PCNT_CTRL_CNTEV_SHIFT;
<a name="l00508"></a>00508 <span class="preprocessor">#endif</span>
<a name="l00509"></a>00509 <span class="preprocessor"></span>
<a name="l00510"></a>00510 <span class="preprocessor">#if defined(_PCNT_CTRL_AUXCNTEV_SHIFT)</span>
<a name="l00511"></a>00511 <span class="preprocessor"></span>  {
<a name="l00512"></a>00512     <span class="comment">/* Modify the auxCntEvent value before writing to the AUXCNTEV field in</span>
<a name="l00513"></a>00513 <span class="comment">       the CTRL register because the AUXCNTEV field values are different from</span>
<a name="l00514"></a>00514 <span class="comment">       the CNTEV field values, and cntEvent and auxCntEvent are of the same type</span>
<a name="l00515"></a>00515 <span class="comment">       PCNT_CntEvent_TypeDef.</span>
<a name="l00516"></a>00516 <span class="comment">    */</span>
<a name="l00517"></a>00517     uint32_t auxCntEventField = 0; <span class="comment">/* Get rid of compiler warning. */</span>
<a name="l00518"></a>00518     <span class="keywordflow">switch</span> (init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#df99d7a0767808c10fd9e33fec206b1d">auxCntEvent</a>)
<a name="l00519"></a>00519     {
<a name="l00520"></a>00520       <span class="keywordflow">case</span> <a class="code" href="group__PCNT.html#ggf5d5d7081a8e56ad0571addc1028ac5c508f29ad6c8a01a1b745d27e3df4fb51">pcntCntEventBoth</a>:
<a name="l00521"></a>00521         auxCntEventField = <a class="code" href="group__PCNT.html#ggf5d5d7081a8e56ad0571addc1028ac5c1efe55164c74d78b7a36d55fbfcbd9b7">pcntCntEventNone</a>;
<a name="l00522"></a>00522         <span class="keywordflow">break</span>;
<a name="l00523"></a>00523       <span class="keywordflow">case</span> <a class="code" href="group__PCNT.html#ggf5d5d7081a8e56ad0571addc1028ac5c1efe55164c74d78b7a36d55fbfcbd9b7">pcntCntEventNone</a>:
<a name="l00524"></a>00524         auxCntEventField = <a class="code" href="group__PCNT.html#ggf5d5d7081a8e56ad0571addc1028ac5c508f29ad6c8a01a1b745d27e3df4fb51">pcntCntEventBoth</a>;
<a name="l00525"></a>00525         <span class="keywordflow">break</span>;
<a name="l00526"></a>00526       <span class="keywordflow">case</span> <a class="code" href="group__PCNT.html#ggf5d5d7081a8e56ad0571addc1028ac5cf3a92af89029e25e067ddfab3154f865">pcntCntEventUp</a>:
<a name="l00527"></a>00527       <span class="keywordflow">case</span> <a class="code" href="group__PCNT.html#ggf5d5d7081a8e56ad0571addc1028ac5cebf6f54275c360dba940960e82f641d3">pcntCntEventDown</a>:
<a name="l00528"></a>00528         auxCntEventField = init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#df99d7a0767808c10fd9e33fec206b1d">auxCntEvent</a>;
<a name="l00529"></a>00529         <span class="keywordflow">break</span>;
<a name="l00530"></a>00530       <span class="keywordflow">default</span>:
<a name="l00531"></a>00531         <span class="comment">/* Invalid parameter, asserted. */</span>
<a name="l00532"></a>00532         EFM_ASSERT(0);
<a name="l00533"></a>00533         <span class="keywordflow">break</span>;
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535     tmp |= auxCntEventField &lt;&lt; _PCNT_CTRL_AUXCNTEV_SHIFT;
<a name="l00536"></a>00536   }
<a name="l00537"></a>00537 <span class="preprocessor">#endif</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span>
<a name="l00539"></a>00539   <span class="comment">/* Reset pulse counter while changing clock source. The reset bit */</span>
<a name="l00540"></a>00540   <span class="comment">/* is asynchronous, we don't have to check for SYNCBUSY. */</span>
<a name="l00541"></a>00541   <a class="code" href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite</a>(&amp;(pcnt-&gt;CTRL), _PCNT_CTRL_RSTEN_SHIFT, 1);
<a name="l00542"></a>00542 
<a name="l00543"></a>00543   <span class="comment">/* Select LFACLK to clock in control setting */</span>
<a name="l00544"></a>00544   <a class="code" href="group__CMU.html#gc0fede38cfa32965cc8ace2b51a14d5b">CMU_PCNTClockExternalSet</a>(inst, <span class="keyword">false</span>);
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   <span class="comment">/* Handling depends on whether using external clock or not. */</span>
<a name="l00547"></a>00547   <span class="keywordflow">switch</span> (init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#a0844eb86c0f7524d1b9d6e681686f1d">mode</a>)
<a name="l00548"></a>00548   {
<a name="l00549"></a>00549     <span class="keywordflow">case</span> <a class="code" href="group__PCNT.html#gg2fb0fc7f68c902b71b271ba5687643a4036410c15ce30d5b1b0e419f96dc62fe">pcntModeExtSingle</a>:
<a name="l00550"></a>00550     <span class="keywordflow">case</span> <a class="code" href="group__PCNT.html#gg2fb0fc7f68c902b71b271ba5687643a4369c3b5ed067a8ac8e9acde0d977662f">pcntModeExtQuad</a>:
<a name="l00551"></a>00551       tmp |= init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#a0844eb86c0f7524d1b9d6e681686f1d">mode</a> &lt;&lt; _PCNT_CTRL_MODE_SHIFT;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553       <span class="comment">/* In most cases, the SYNCBUSY bit is set due to reset bit set, and waiting</span>
<a name="l00554"></a>00554 <span class="comment">       * for asynchronous reset bit is strictly not necessary.</span>
<a name="l00555"></a>00555 <span class="comment">       * But in theory, other operations on CTRL register may have been done</span>
<a name="l00556"></a>00556 <span class="comment">       * outside this function, so wait. */</span>
<a name="l00557"></a>00557       PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559       <span class="comment">/* Enable PCNT Clock Domain Reset. The PCNT must be in reset before changing</span>
<a name="l00560"></a>00560 <span class="comment">       * the clock source to an external clock */</span>
<a name="l00561"></a>00561       pcnt-&gt;CTRL = PCNT_CTRL_RSTEN;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563       <span class="comment">/* Wait until CTRL write synchronized into LF domain. */</span>
<a name="l00564"></a>00564       PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL);
<a name="l00565"></a>00565 
<a name="l00566"></a>00566       <span class="comment">/* Change to external clock BEFORE disabling reset */</span>
<a name="l00567"></a>00567       <a class="code" href="group__CMU.html#gc0fede38cfa32965cc8ace2b51a14d5b">CMU_PCNTClockExternalSet</a>(inst, <span class="keyword">true</span>);
<a name="l00568"></a>00568 
<a name="l00569"></a>00569       <span class="comment">/* Write to TOPB. If using external clock TOPB will sync to TOP at the same</span>
<a name="l00570"></a>00570 <span class="comment">       * time as the mode. This will insure that if the user chooses to count</span>
<a name="l00571"></a>00571 <span class="comment">       * down, the first "countable" pulse will make CNT go to TOP and not 0xFF</span>
<a name="l00572"></a>00572 <span class="comment">       * (default TOP value). */</span>
<a name="l00573"></a>00573       pcnt-&gt;TOPB = init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#ed74c73c9af92c58c89902b0a98556a2">top</a>;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575       <span class="comment">/* This bit has no effect on rev. C and onwards parts - for compatibility */</span>
<a name="l00576"></a>00576       pcnt-&gt;CMD = PCNT_CMD_LTOPBIM;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578       <span class="comment">/* Write the CTRL register with the configurations.</span>
<a name="l00579"></a>00579 <span class="comment">       * This should be written after TOPB in the eventuality of a pulse between</span>
<a name="l00580"></a>00580 <span class="comment">       * these two writes that would cause the CTRL register to be synced one</span>
<a name="l00581"></a>00581 <span class="comment">       * clock cycle earlier than the TOPB. */</span>
<a name="l00582"></a>00582       pcnt-&gt;CTRL = tmp;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584       <span class="comment">/* There are no syncs for TOP, CMD or CTRL because the clock rate is unknown</span>
<a name="l00585"></a>00585 <span class="comment">       * and the program could stall</span>
<a name="l00586"></a>00586 <span class="comment">       * These will be synced within 3 clock cycles of the external clock  /</span>
<a name="l00587"></a>00587 <span class="comment">       * For the same reason CNT cannot be written here. */</span>
<a name="l00588"></a>00588       <span class="keywordflow">break</span>;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590     <span class="comment">/* pcntModeDisable */</span>
<a name="l00591"></a>00591     <span class="comment">/* pcntModeOvsSingle */</span>
<a name="l00592"></a>00592     <span class="keywordflow">default</span>:
<a name="l00593"></a>00593       <span class="comment">/* No need to set disabled mode if already disabled. */</span>
<a name="l00594"></a>00594       <span class="keywordflow">if</span> ((pcnt-&gt;CTRL &amp; _PCNT_CTRL_MODE_MASK) != PCNT_CTRL_MODE_DISABLE)
<a name="l00595"></a>00595       {
<a name="l00596"></a>00596         <span class="comment">/* Set control to disabled mode, leave reset on until ensured disabled.</span>
<a name="l00597"></a>00597 <span class="comment">         * We don't need to wait for CTRL SYNCBUSY completion here, it was</span>
<a name="l00598"></a>00598 <span class="comment">         * triggered by reset bit above, which is asynchronous. */</span>
<a name="l00599"></a>00599         pcnt-&gt;CTRL = tmp | PCNT_CTRL_MODE_DISABLE | PCNT_CTRL_RSTEN;
<a name="l00600"></a>00600 
<a name="l00601"></a>00601         <span class="comment">/* Wait until CTRL write synchronized into LF domain before proceeding</span>
<a name="l00602"></a>00602 <span class="comment">         * to disable reset. */</span>
<a name="l00603"></a>00603         PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL);
<a name="l00604"></a>00604       }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606       <span class="comment">/* Disable reset bit, counter should now be in disabled mode. */</span>
<a name="l00607"></a>00607       <a class="code" href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite</a>(&amp;(pcnt-&gt;CTRL), _PCNT_CTRL_RSTEN_SHIFT, 0);
<a name="l00608"></a>00608 
<a name="l00609"></a>00609       <span class="comment">/* Set counter and top values as specified. */</span>
<a name="l00610"></a>00610       <a class="code" href="group__PCNT.html#g4f29435f61c53e4a6e86947fe1980be9">PCNT_CounterTopSet</a>(pcnt, init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#5d96030a51af815ee5ecb429edddadf1">counter</a>, init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#ed74c73c9af92c58c89902b0a98556a2">top</a>);
<a name="l00611"></a>00611 
<a name="l00612"></a>00612       <span class="comment">/* Enter oversampling mode if selected. */</span>
<a name="l00613"></a>00613       <span class="keywordflow">if</span> (init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#a0844eb86c0f7524d1b9d6e681686f1d">mode</a> == <a class="code" href="group__PCNT.html#gg2fb0fc7f68c902b71b271ba5687643a46631b7a7ec35e0ea2f60307f76f15a11">pcntModeOvsSingle</a>)
<a name="l00614"></a>00614       {
<a name="l00615"></a>00615         PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL);
<a name="l00616"></a>00616         pcnt-&gt;CTRL = tmp | (init-&gt;<a class="code" href="structPCNT__Init__TypeDef.html#a0844eb86c0f7524d1b9d6e681686f1d">mode</a> &lt;&lt; _PCNT_CTRL_MODE_SHIFT);
<a name="l00617"></a>00617       }
<a name="l00618"></a>00618       <span class="keywordflow">break</span>;
<a name="l00619"></a>00619   }
<a name="l00620"></a>00620 }
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 
<a name="l00623"></a>00623 <span class="comment">/***************************************************************************/</span>
<a name="l00639"></a><a class="code" href="group__PCNT.html#gdf14f80981badc92e7a30a43caae130b">00639</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#gdf14f80981badc92e7a30a43caae130b">PCNT_Reset</a>(PCNT_TypeDef *pcnt)
<a name="l00640"></a>00640 {
<a name="l00641"></a>00641   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inst;
<a name="l00642"></a>00642 
<a name="l00643"></a>00643   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00644"></a>00644 
<a name="l00645"></a>00645   <span class="comment">/* Map pointer to instance and clock info */</span>
<a name="l00646"></a>00646   inst = PCNT_Map(pcnt);
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   pcnt-&gt;IEN = _PCNT_IEN_RESETVALUE;
<a name="l00649"></a>00649 
<a name="l00650"></a>00650   <span class="comment">/* Notice that special SYNCBUSY handling is not applicable for the RSTEN</span>
<a name="l00651"></a>00651 <span class="comment">   * bit of the control register, so we don't need to wait for it when only</span>
<a name="l00652"></a>00652 <span class="comment">   * modifying RSTEN. The SYNCBUSY bit will be set, leading to a</span>
<a name="l00653"></a>00653 <span class="comment">   * synchronization in the LF domain, with in reality no changes to LF domain.</span>
<a name="l00654"></a>00654 <span class="comment">   * Enable reset of CNT and TOP register. */</span>
<a name="l00655"></a>00655   <a class="code" href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite</a>(&amp;(pcnt-&gt;CTRL), _PCNT_CTRL_RSTEN_SHIFT, 1);
<a name="l00656"></a>00656 
<a name="l00657"></a>00657   <span class="comment">/* Select LFACLK as default */</span>
<a name="l00658"></a>00658   <a class="code" href="group__CMU.html#gc0fede38cfa32965cc8ace2b51a14d5b">CMU_PCNTClockExternalSet</a>(inst, <span class="keyword">false</span>);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   <a class="code" href="group__PCNT.html#ga0a00b056f5f6404abd02de84c30d002">PCNT_TopBufferSet</a>(pcnt, _PCNT_TOPB_RESETVALUE);
<a name="l00661"></a>00661 
<a name="l00662"></a>00662   <span class="comment">/* Reset CTRL leaving RSTEN set */</span>
<a name="l00663"></a>00663   pcnt-&gt;CTRL = _PCNT_CTRL_RESETVALUE | PCNT_CTRL_RSTEN;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665   <span class="comment">/* Disable reset after CTRL reg has been synchronized */</span>
<a name="l00666"></a>00666   PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL);
<a name="l00667"></a>00667   <a class="code" href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164">BUS_RegBitWrite</a>(&amp;(pcnt-&gt;CTRL), _PCNT_CTRL_RSTEN_SHIFT, 0);
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   <span class="comment">/* Clear pending interrupts */</span>
<a name="l00670"></a>00670   pcnt-&gt;IFC = _PCNT_IFC_MASK;
<a name="l00671"></a>00671 
<a name="l00672"></a>00672   <span class="comment">/* Do not reset route register, setting should be done independently */</span>
<a name="l00673"></a>00673 }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675 <span class="preprocessor">#if defined(PCNT_OVSCFG_FILTLEN_DEFAULT)</span>
<a name="l00676"></a>00676 <span class="preprocessor"></span><span class="comment">/***************************************************************************/</span>
<a name="l00693"></a>00693 <span class="keywordtype">void</span> PCNT_FilterConfiguration(PCNT_TypeDef *pcnt, <span class="keyword">const</span> PCNT_Filter_TypeDef *config, <span class="keywordtype">bool</span> enable) {
<a name="l00694"></a>00694   uint32_t ovscfg = 0;
<a name="l00695"></a>00695   
<a name="l00696"></a>00696   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00697"></a>00697   
<a name="l00698"></a>00698   <span class="comment">/* Construct new filter setting value */</span>
<a name="l00699"></a>00699   ovscfg  = ((config-&gt;filtLen &amp; _PCNT_OVSCFG_FILTLEN_MASK) &lt;&lt; _PCNT_OVSCFG_FILTLEN_SHIFT)
<a name="l00700"></a>00700             | ((config-&gt;flutterrm &amp; 0x1) &lt;&lt; _PCNT_OVSCFG_FLUTTERRM_SHIFT);
<a name="l00701"></a>00701   
<a name="l00702"></a>00702   <span class="comment">/* Set new configuration. LF register requires sync check before writing. */</span>
<a name="l00703"></a>00703   PCNT_Sync(pcnt, PCNT_SYNCBUSY_OVSCFG);
<a name="l00704"></a>00704   pcnt-&gt;OVSCFG = ovscfg;
<a name="l00705"></a>00705 
<a name="l00706"></a>00706   
<a name="l00707"></a>00707   <span class="comment">/* Set new state of filter. LF register requires sync check before writing. */</span>
<a name="l00708"></a>00708   PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL);
<a name="l00709"></a>00709   <span class="keywordflow">if</span>(enable) 
<a name="l00710"></a>00710   {
<a name="l00711"></a>00711     pcnt-&gt;CTRL |= PCNT_CTRL_FILT;
<a name="l00712"></a>00712   } 
<a name="l00713"></a>00713   <span class="keywordflow">else</span> 
<a name="l00714"></a>00714   {
<a name="l00715"></a>00715     pcnt-&gt;CTRL &amp;= ~PCNT_CTRL_FILT;
<a name="l00716"></a>00716   }
<a name="l00717"></a>00717 }
<a name="l00718"></a>00718 <span class="preprocessor">#endif</span>
<a name="l00719"></a>00719 <span class="preprocessor"></span>
<a name="l00720"></a>00720 <span class="preprocessor">#if defined(PCNT_CTRL_TCCMODE_DEFAULT)</span>
<a name="l00721"></a>00721 <span class="preprocessor"></span><span class="comment">/***************************************************************************/</span>
<a name="l00742"></a><a class="code" href="group__PCNT.html#g7eab99c2f55d522ef2ea4927be2bbcb2">00742</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#g7eab99c2f55d522ef2ea4927be2bbcb2">PCNT_TCCConfiguration</a>(PCNT_TypeDef *pcnt, <span class="keyword">const</span> <a class="code" href="structPCNT__TCC__TypeDef.html">PCNT_TCC_TypeDef</a> *config){
<a name="l00743"></a>00743   uint32_t ctrl = 0;
<a name="l00744"></a>00744   uint32_t mask = _PCNT_CTRL_TCCMODE_MASK
<a name="l00745"></a>00745                   | _PCNT_CTRL_TCCPRESC_MASK
<a name="l00746"></a>00746                   | _PCNT_CTRL_TCCCOMP_MASK
<a name="l00747"></a>00747                   | _PCNT_CTRL_PRSGATEEN_MASK
<a name="l00748"></a>00748                   | _PCNT_CTRL_TCCPRSPOL_MASK
<a name="l00749"></a>00749                   | _PCNT_CTRL_TCCPRSSEL_MASK;
<a name="l00750"></a>00750   
<a name="l00751"></a>00751   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00752"></a>00752   
<a name="l00753"></a>00753   <span class="comment">/* construct TCC part of configuration register */</span>
<a name="l00754"></a>00754   ctrl |= (config-&gt;<a class="code" href="structPCNT__TCC__TypeDef.html#764de9da31f5276d5ba741f3605f726d">mode</a>          &lt;&lt; _PCNT_CTRL_TCCMODE_SHIFT   ) &amp; _PCNT_CTRL_TCCMODE_MASK;
<a name="l00755"></a>00755   ctrl |= (config-&gt;<a class="code" href="structPCNT__TCC__TypeDef.html#c77723a310d3dc72f04f32ebe6dea08d">prescaler</a>     &lt;&lt; _PCNT_CTRL_TCCPRESC_SHIFT  ) &amp; _PCNT_CTRL_TCCPRESC_MASK;
<a name="l00756"></a>00756   ctrl |= (config-&gt;<a class="code" href="structPCNT__TCC__TypeDef.html#7ca40098bd21963c4cfd7ccf3dd9d505">compare</a>       &lt;&lt; _PCNT_CTRL_TCCCOMP_SHIFT   ) &amp; _PCNT_CTRL_TCCCOMP_MASK;
<a name="l00757"></a>00757   ctrl |= (config-&gt;<a class="code" href="structPCNT__TCC__TypeDef.html#2ff7e86f179baeb916fe7a6a9d333cd5">tccPRS</a>        &lt;&lt; _PCNT_CTRL_TCCPRSSEL_SHIFT ) &amp; _PCNT_CTRL_TCCPRSSEL_MASK;
<a name="l00758"></a>00758   ctrl |= (config-&gt;<a class="code" href="structPCNT__TCC__TypeDef.html#7fe3f78bfc87dc1df10217aa4aadd679">prsPolarity</a>   &lt;&lt; _PCNT_CTRL_TCCPRSPOL_SHIFT ) &amp; _PCNT_CTRL_TCCPRSPOL_MASK;
<a name="l00759"></a>00759   ctrl |= (config-&gt;<a class="code" href="structPCNT__TCC__TypeDef.html#0dc7d04df1b88ab5450e5e0969d4aa37">prsGateEnable</a> &lt;&lt; _PCNT_CTRL_PRSGATEEN_SHIFT ) &amp; _PCNT_CTRL_PRSGATEEN_MASK;
<a name="l00760"></a>00760   
<a name="l00761"></a>00761   <span class="comment">/* Load new TCC config to PCNT. LF register requires sync check before write. */</span>
<a name="l00762"></a>00762   PCNT_Sync(pcnt, PCNT_SYNCBUSY_CTRL);
<a name="l00763"></a>00763   pcnt-&gt;CTRL = (pcnt-&gt;CTRL &amp; (~mask)) | ctrl;
<a name="l00764"></a>00764 }
<a name="l00765"></a>00765 <span class="preprocessor">#endif</span>
<a name="l00766"></a>00766 <span class="preprocessor"></span>
<a name="l00767"></a>00767 <span class="comment">/***************************************************************************/</span>
<a name="l00783"></a><a class="code" href="group__PCNT.html#ga0a00b056f5f6404abd02de84c30d002">00783</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#ga0a00b056f5f6404abd02de84c30d002">PCNT_TopBufferSet</a>(PCNT_TypeDef *pcnt, uint32_t val)
<a name="l00784"></a>00784 {
<a name="l00785"></a>00785   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   <span class="comment">/* LF register about to be modified require sync. busy check */</span>
<a name="l00788"></a>00788   PCNT_Sync(pcnt, PCNT_SYNCBUSY_TOPB);
<a name="l00789"></a>00789   pcnt-&gt;TOPB = val;
<a name="l00790"></a>00790 }
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 
<a name="l00793"></a>00793 <span class="comment">/***************************************************************************/</span>
<a name="l00809"></a><a class="code" href="group__PCNT.html#gc40297f0dcf3f1502b8cbca2aced1466">00809</a> <span class="keywordtype">void</span> <a class="code" href="group__PCNT.html#gc40297f0dcf3f1502b8cbca2aced1466">PCNT_TopSet</a>(PCNT_TypeDef *pcnt, uint32_t val)
<a name="l00810"></a>00810 {
<a name="l00811"></a>00811   EFM_ASSERT(PCNT_REF_VALID(pcnt));
<a name="l00812"></a>00812 
<a name="l00813"></a>00813 <span class="preprocessor">#ifdef PCNT0</span>
<a name="l00814"></a>00814 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (PCNT0 == pcnt)
<a name="l00815"></a>00815   {
<a name="l00816"></a>00816     EFM_ASSERT((1&lt;&lt;<a class="code" href="group__PCNT.html#gf9147680cf4def78a0d85a8056ac305d">PCNT0_CNT_SIZE</a>) &gt; val);
<a name="l00817"></a>00817   }
<a name="l00818"></a>00818 <span class="preprocessor">#endif</span>
<a name="l00819"></a>00819 <span class="preprocessor"></span>
<a name="l00820"></a>00820 <span class="preprocessor">#ifdef PCNT1</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (PCNT1 == pcnt)
<a name="l00822"></a>00822   {
<a name="l00823"></a>00823     EFM_ASSERT((1&lt;&lt;PCNT1_CNT_SIZE) &gt; val);
<a name="l00824"></a>00824   }
<a name="l00825"></a>00825 <span class="preprocessor">#endif</span>
<a name="l00826"></a>00826 <span class="preprocessor"></span>
<a name="l00827"></a>00827 <span class="preprocessor">#ifdef PCNT2</span>
<a name="l00828"></a>00828 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (PCNT2 == pcnt)
<a name="l00829"></a>00829   {
<a name="l00830"></a>00830     EFM_ASSERT((1&lt;&lt;PCNT2_CNT_SIZE) &gt; val);
<a name="l00831"></a>00831   }
<a name="l00832"></a>00832 <span class="preprocessor">#endif</span>
<a name="l00833"></a>00833 <span class="preprocessor"></span>
<a name="l00834"></a>00834   <span class="comment">/* LF register about to be modified require sync. busy check */</span>
<a name="l00835"></a>00835 
<a name="l00836"></a>00836   <span class="comment">/* Load into TOPB */</span>
<a name="l00837"></a>00837   PCNT_Sync(pcnt, PCNT_SYNCBUSY_TOPB);
<a name="l00838"></a>00838   pcnt-&gt;TOPB = val;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840   <span class="comment">/* Load TOPB value into TOP */</span>
<a name="l00841"></a>00841   PCNT_Sync(pcnt, PCNT_SYNCBUSY_TOPB | PCNT_SYNCBUSY_CMD);
<a name="l00842"></a>00842   pcnt-&gt;CMD = PCNT_CMD_LTOPBIM;
<a name="l00843"></a>00843 }
<a name="l00844"></a>00844 
<a name="l00847"></a>00847 <span class="preprocessor">#endif </span><span class="comment">/* defined(PCNT_COUNT) &amp;&amp; (PCNT_COUNT &gt; 0) */</span>
</pre></div><div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Thu Sep 10 08:17:59 2015</small> for Silicon Labs EFM32 emlib Peripheral Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.4.7 </small></address></div>
</body>
</html>
