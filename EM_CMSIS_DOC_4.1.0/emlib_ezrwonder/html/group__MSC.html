<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs EZR32 emlib Peripheral Library: MSC</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<h1>MSC<br>
<small>
[<a class="el" href="group__EM__Library.html">EM_Library</a>]</small>
</h1>
<p>
Collaboration diagram for MSC:<center><table><tr><td><img src="group__MSC.png" border="0" alt="" usemap="#group____MSC_map">
<map name="group____MSC_map">
<area href="group__EM__Library.html" shape="rect" coords="5,5,96,32" alt="">
</map></td></tr></table></center>
Flash controller (MSC) peripheral API.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMSC__ExecConfig__TypeDef.html">MSC_ExecConfig_TypeDef</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g1135aa8aedb12568145f653bc8abdc31">EM_MSC_RUN_FROM_FLASH</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">By compiling with the define EM_MSC_RUN_FROM_FLASH the Flash controller (MSC) peripheral will remain in and execute from flash. This is useful for targets that don't want to allocate RAM space to hold the flash functions. Without this define the MSC peripheral functions will be copied into and run out of RAM.  <a href="#g1135aa8aedb12568145f653bc8abdc31"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#ge0b31656af85df71ad9ec519d7b1c923">MSC_EXECCONFIG_DEFAULT</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5074d233c67e3195daf1afc3cb360a0f"></a><!-- doxytag: member="MSC::MSC_FUNC_POSTFIX" ref="g5074d233c67e3195daf1afc3cb360a0f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g5074d233c67e3195daf1afc3cb360a0f">MSC_FUNC_POSTFIX</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2dc4fc5ec22ce8e85ef6c6d92548f6cc"></a><!-- doxytag: member="MSC::MSC_FUNC_PREFIX" ref="g2dc4fc5ec22ce8e85ef6c6d92548f6cc" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g2dc4fc5ec22ce8e85ef6c6d92548f6cc">MSC_FUNC_PREFIX</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g2ccebeae7857abb74bd22341b7761583">MSC_PROGRAM_TIMEOUT</a>&nbsp;&nbsp;&nbsp;10000000ul</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The timeout used while waiting for the flash to become ready after a write. This number indicates the number of iterations to perform before issuing a timeout.  <a href="#g2ccebeae7857abb74bd22341b7761583"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g6850b8a5bb5ae189bb3e380d3137f103">MSC_BusStrategy_Typedef</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__MSC.html#gg6850b8a5bb5ae189bb3e380d3137f10393d7920b0b1256375377e3bd3da53b50">mscBusStrategyCPU</a> =  MSC_READCTRL_BUSSTRATEGY_CPU, 
<br>
&nbsp;&nbsp;<a class="el" href="group__MSC.html#gg6850b8a5bb5ae189bb3e380d3137f1037ed30ae1ac4f59e222b5cf7e8dc4dc81">mscBusStrategyDMA</a> =  MSC_READCTRL_BUSSTRATEGY_DMA, 
<br>
&nbsp;&nbsp;<a class="el" href="group__MSC.html#gg6850b8a5bb5ae189bb3e380d3137f103889e5587bdae2a9d42fbbdf4dd01a201">mscBusStrategyDMAEM1</a> =  MSC_READCTRL_BUSSTRATEGY_DMAEM1, 
<br>
&nbsp;&nbsp;<a class="el" href="group__MSC.html#gg6850b8a5bb5ae189bb3e380d3137f103f1a38880976b9b59a760834d34d52f54">mscBusStrategyNone</a> =  MSC_READCTRL_BUSSTRATEGY_NONE
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c01194171cf80ee1904596c838b67bf8dc">mscReturnOk</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c09e4a7b0e66a5e0ce269c24448ad53ce9">mscReturnInvalidAddr</a> =  -1, 
<br>
&nbsp;&nbsp;<a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c06665fd5d688be1ae3622da00e3c44e80">mscReturnLocked</a> =  -2, 
<br>
&nbsp;&nbsp;<a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c060b2f4d7977d34fde474915d77a86e82">mscReturnTimeOut</a> =  -3, 
<br>
&nbsp;&nbsp;<a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c02cd0f16db1ef497f581731cb74bc2bfc">mscReturnUnaligned</a> =  -4
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#ga73ee06d21d343104769724064ec5a99">MSC_BusStrategy</a> (mscBusStrategy_Typedef mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure which unit should get priority on system bus.  <a href="#ga73ee06d21d343104769724064ec5a99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#gdb2eab07fedfb79fba5a3abdd8b5c96a">MSC_Deinit</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables the flash controller for writing.  <a href="#gdb2eab07fedfb79fba5a3abdd8b5c96a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g5245d3b0940fea9a9c812e95476e9aa1">MSC_EnableAutoCacheFlush</a> (bool enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable instruction cache flushing when writing to flash.  <a href="#g5245d3b0940fea9a9c812e95476e9aa1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#ge1220a12c62b8709ae553b0a155c0d18">MSC_EnableCache</a> (bool enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable instruction cache functionality.  <a href="#ge1220a12c62b8709ae553b0a155c0d18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g474b3f23a041eea03a7f600727d2e41f">MSC_EnableCacheIRQs</a> (bool enable)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable or disable instruction cache functionality in IRQs.  <a href="#g474b3f23a041eea03a7f600727d2e41f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MSC_FUNC_PREFIX <a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g25bb7197232a0fa92f3fc22d3a128161">MSC_ErasePage</a> (uint32_t *startAddress)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a page in flash memory.  <a href="#g25bb7197232a0fa92f3fc22d3a128161"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#gbefc7774cd8e2ddf3c77895ca8198775">MSC_ExecConfigSet</a> (<a class="el" href="structMSC__ExecConfig__TypeDef.html">MSC_ExecConfig_TypeDef</a> *execConfig)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set MSC code execution configuration.  <a href="#gbefc7774cd8e2ddf3c77895ca8198775"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#gd19a98dedaa95d382183f8e126243d64">MSC_FlushCache</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush the contents of the instruction cache.  <a href="#gd19a98dedaa95d382183f8e126243d64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g0dc3182b945bc354c87b78eab586cfa7">MSC_GetCacheMeasurement</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops measuring the hit rate.  <a href="#g0dc3182b945bc354c87b78eab586cfa7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#ga02df815c14caedbc2fd0a8910d2e055">MSC_Init</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables the flash controller for writing.  <a href="#ga02df815c14caedbc2fd0a8910d2e055"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g3e99a1115d2fdec306e3ebd3a9c5e3b4">MSC_IntClear</a> (uint32_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear one or more pending MSC interrupts.  <a href="#g3e99a1115d2fdec306e3ebd3a9c5e3b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#ge93719c876be33cc035e8a4791c4c9fe">MSC_IntDisable</a> (uint32_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable one or more MSC interrupts.  <a href="#ge93719c876be33cc035e8a4791c4c9fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g4824f067a4895d743b9d369b2d261e1c">MSC_IntEnable</a> (uint32_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable one or more MSC interrupts.  <a href="#g4824f067a4895d743b9d369b2d261e1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#ge8463b277bec80606e0eb8fe71641f78">MSC_IntGet</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get pending MSC interrupt flags.  <a href="#ge8463b277bec80606e0eb8fe71641f78"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g30acc1e5a9cbe04debbc18e40f95ee65">MSC_IntGetEnabled</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get enabled and pending MSC interrupt flags. Useful for handling more interrupt sources in the same interrupt handler.  <a href="#g30acc1e5a9cbe04debbc18e40f95ee65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g0792aa6d5cef984923e3d10d44b5723f">MSC_IntSet</a> (uint32_t flags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set one or more pending MSC interrupts from SW.  <a href="#g0792aa6d5cef984923e3d10d44b5723f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MSC_FUNC_PREFIX <a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g9fad087d13139eb8e281ac49b52718a8">MSC_MassErase</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase entire flash in one operation.  <a href="#g9fad087d13139eb8e281ac49b52718a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">__STATIC_INLINE void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#gc7691792864bdeae85744036eac93f41">MSC_StartCacheMeasurement</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts measuring cache hit ratio.  <a href="#gc7691792864bdeae85744036eac93f41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MSC_FUNC_PREFIX <a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#g76309e04e090815bd80e7e5da3ee6ff6">MSC_WriteWord</a> (uint32_t *address, void const *data, uint32_t numBytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes data to flash memory. This function is interrupt safe, but slower than <a class="el" href="group__MSC.html#gb9b796ba26919fd0f434bbb7c339f1c4">MSC_WriteWordFast()</a>, which writes to flash with interrupts disabled. Write data must be aligned to words and contain a number of bytes that is divisable by four.  <a href="#g76309e04e090815bd80e7e5da3ee6ff6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MSC_FUNC_PREFIX <a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MSC.html#gb9b796ba26919fd0f434bbb7c339f1c4">MSC_WriteWordFast</a> (uint32_t *address, void const *data, uint32_t numBytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes data to flash memory. This function is faster than <a class="el" href="group__MSC.html#g76309e04e090815bd80e7e5da3ee6ff6">MSC_WriteWord()</a>, but it disables interrupts. Write data must be aligned to words and contain a number of bytes that is divisable by four.  <a href="#gb9b796ba26919fd0f434bbb7c339f1c4"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Flash controller (MSC) peripheral API. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="g1135aa8aedb12568145f653bc8abdc31"></a><!-- doxytag: member="em_msc.h::EM_MSC_RUN_FROM_FLASH" ref="g1135aa8aedb12568145f653bc8abdc31" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EM_MSC_RUN_FROM_FLASH          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
By compiling with the define EM_MSC_RUN_FROM_FLASH the Flash controller (MSC) peripheral will remain in and execute from flash. This is useful for targets that don't want to allocate RAM space to hold the flash functions. Without this define the MSC peripheral functions will be copied into and run out of RAM. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This define is commented out by default so the MSC controller API will run from RAM by default. </dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00087">87</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="ge0b31656af85df71ad9ec519d7b1c923"></a><!-- doxytag: member="em_msc.h::MSC_EXECCONFIG_DEFAULT" ref="ge0b31656af85df71ad9ec519d7b1c923" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSC_EXECCONFIG_DEFAULT          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">{                               \
  <span class="keyword">false</span>,                        \
  <span class="keyword">true</span>,                         \
  <span class="keyword">false</span>,                        \
  <span class="keyword">false</span>,                        \
  <span class="keyword">false</span>,                        \
  <span class="keyword">false</span>,                        \
}
</pre></div>
<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00129">129</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="g2ccebeae7857abb74bd22341b7761583"></a><!-- doxytag: member="em_msc.h::MSC_PROGRAM_TIMEOUT" ref="g2ccebeae7857abb74bd22341b7761583" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSC_PROGRAM_TIMEOUT&nbsp;&nbsp;&nbsp;10000000ul          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The timeout used while waiting for the flash to become ready after a write. This number indicates the number of iterations to perform before issuing a timeout. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This timeout is set very large (in the order of 100x longer than necessary). This is to avoid any corner cases. </dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00072">72</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
<p>
Referenced by <a class="el" href="em__msc_8c-source.html#l00637">MSC_ErasePage()</a>.
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g6850b8a5bb5ae189bb3e380d3137f103"></a><!-- doxytag: member="em_msc.h::MSC_BusStrategy_Typedef" ref="g6850b8a5bb5ae189bb3e380d3137f103" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MSC.html#g6850b8a5bb5ae189bb3e380d3137f103">MSC_BusStrategy_Typedef</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Strategy for prioritized bus access <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg6850b8a5bb5ae189bb3e380d3137f10393d7920b0b1256375377e3bd3da53b50"></a><!-- doxytag: member="mscBusStrategyCPU" ref="gg6850b8a5bb5ae189bb3e380d3137f10393d7920b0b1256375377e3bd3da53b50" args="" -->mscBusStrategyCPU</em>&nbsp;</td><td>
Prioritize CPU bus accesses </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg6850b8a5bb5ae189bb3e380d3137f1037ed30ae1ac4f59e222b5cf7e8dc4dc81"></a><!-- doxytag: member="mscBusStrategyDMA" ref="gg6850b8a5bb5ae189bb3e380d3137f1037ed30ae1ac4f59e222b5cf7e8dc4dc81" args="" -->mscBusStrategyDMA</em>&nbsp;</td><td>
Prioritize DMA bus accesses </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg6850b8a5bb5ae189bb3e380d3137f103889e5587bdae2a9d42fbbdf4dd01a201"></a><!-- doxytag: member="mscBusStrategyDMAEM1" ref="gg6850b8a5bb5ae189bb3e380d3137f103889e5587bdae2a9d42fbbdf4dd01a201" args="" -->mscBusStrategyDMAEM1</em>&nbsp;</td><td>
Prioritize DMAEM1 for bus accesses </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg6850b8a5bb5ae189bb3e380d3137f103f1a38880976b9b59a760834d34d52f54"></a><!-- doxytag: member="mscBusStrategyNone" ref="gg6850b8a5bb5ae189bb3e380d3137f103f1a38880976b9b59a760834d34d52f54" args="" -->mscBusStrategyNone</em>&nbsp;</td><td>
No unit has bus priority </td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00109">109</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="ga548bd1d520a543e249b6a85338b59c0"></a><!-- doxytag: member="em_msc.h::MSC_Status_TypeDef" ref="ga548bd1d520a543e249b6a85338b59c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return codes for writing/erasing the flash <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga548bd1d520a543e249b6a85338b59c01194171cf80ee1904596c838b67bf8dc"></a><!-- doxytag: member="mscReturnOk" ref="gga548bd1d520a543e249b6a85338b59c01194171cf80ee1904596c838b67bf8dc" args="" -->mscReturnOk</em>&nbsp;</td><td>
Flash write/erase successful. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga548bd1d520a543e249b6a85338b59c09e4a7b0e66a5e0ce269c24448ad53ce9"></a><!-- doxytag: member="mscReturnInvalidAddr" ref="gga548bd1d520a543e249b6a85338b59c09e4a7b0e66a5e0ce269c24448ad53ce9" args="" -->mscReturnInvalidAddr</em>&nbsp;</td><td>
Invalid address. Write to an address that is not flash. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga548bd1d520a543e249b6a85338b59c06665fd5d688be1ae3622da00e3c44e80"></a><!-- doxytag: member="mscReturnLocked" ref="gga548bd1d520a543e249b6a85338b59c06665fd5d688be1ae3622da00e3c44e80" args="" -->mscReturnLocked</em>&nbsp;</td><td>
Flash address is locked. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga548bd1d520a543e249b6a85338b59c060b2f4d7977d34fde474915d77a86e82"></a><!-- doxytag: member="mscReturnTimeOut" ref="gga548bd1d520a543e249b6a85338b59c060b2f4d7977d34fde474915d77a86e82" args="" -->mscReturnTimeOut</em>&nbsp;</td><td>
Timeout while writing to flash. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga548bd1d520a543e249b6a85338b59c02cd0f16db1ef497f581731cb74bc2bfc"></a><!-- doxytag: member="mscReturnUnaligned" ref="gga548bd1d520a543e249b6a85338b59c02cd0f16db1ef497f581731cb74bc2bfc" args="" -->mscReturnUnaligned</em>&nbsp;</td><td>
Unaligned access to flash. </td></tr>
</table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00097">97</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga73ee06d21d343104769724064ec5a99"></a><!-- doxytag: member="em_msc.h::MSC_BusStrategy" ref="ga73ee06d21d343104769724064ec5a99" args="(mscBusStrategy_Typedef mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_BusStrategy           </td>
          <td>(</td>
          <td class="paramtype">mscBusStrategy_Typedef&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configure which unit should get priority on system bus. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>Unit to prioritize bus accesses for. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00412">412</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="gdb2eab07fedfb79fba5a3abdd8b5c96a"></a><!-- doxytag: member="em_msc.h::MSC_Deinit" ref="gdb2eab07fedfb79fba5a3abdd8b5c96a" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MSC_Deinit           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disables the flash controller for writing. 
<p>

<p>
Definition at line <a class="el" href="em__msc_8c-source.html#l00153">153</a> of file <a class="el" href="em__msc_8c-source.html">em_msc.c</a>.
</div>
</div><p>
<a class="anchor" name="g5245d3b0940fea9a9c812e95476e9aa1"></a><!-- doxytag: member="em_msc.h::MSC_EnableAutoCacheFlush" ref="g5245d3b0940fea9a9c812e95476e9aa1" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_EnableAutoCacheFlush           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable instruction cache flushing when writing to flash. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>Enable automatic cache flushing. Default is on. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00398">398</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
<p>
References <a class="el" href="em__bus_8h-source.html#l00146">BUS_RegBitWrite()</a>.
<p>
Here is the call graph for this function:<p><center><img src="group__MSC_g5245d3b0940fea9a9c812e95476e9aa1_cgraph.png" border="0" usemap="#group__MSC_g5245d3b0940fea9a9c812e95476e9aa1_cgraph_map" alt=""></center>
<map name="group__MSC_g5245d3b0940fea9a9c812e95476e9aa1_cgraph_map">
<area href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164" shape="rect" coords="259,5,386,32" alt="">
</map>

</div>
</div><p>
<a class="anchor" name="ge1220a12c62b8709ae553b0a155c0d18"></a><!-- doxytag: member="em_msc.h::MSC_EnableCache" ref="ge1220a12c62b8709ae553b0a155c0d18" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_EnableCache           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable instruction cache functionality. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>Enable instruction cache. Default is on. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00372">372</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
<p>
References <a class="el" href="em__bus_8h-source.html#l00146">BUS_RegBitWrite()</a>.
<p>
Here is the call graph for this function:<p><center><img src="group__MSC_ge1220a12c62b8709ae553b0a155c0d18_cgraph.png" border="0" usemap="#group__MSC_ge1220a12c62b8709ae553b0a155c0d18_cgraph_map" alt=""></center>
<map name="group__MSC_ge1220a12c62b8709ae553b0a155c0d18_cgraph_map">
<area href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164" shape="rect" coords="198,5,325,32" alt="">
</map>

</div>
</div><p>
<a class="anchor" name="g474b3f23a041eea03a7f600727d2e41f"></a><!-- doxytag: member="em_msc.h::MSC_EnableCacheIRQs" ref="g474b3f23a041eea03a7f600727d2e41f" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_EnableCacheIRQs           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable instruction cache functionality in IRQs. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>Enable instruction cache. Default is on. </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00385">385</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
<p>
References <a class="el" href="em__bus_8h-source.html#l00146">BUS_RegBitWrite()</a>.
<p>
Here is the call graph for this function:<p><center><img src="group__MSC_g474b3f23a041eea03a7f600727d2e41f_cgraph.png" border="0" usemap="#group__MSC_g474b3f23a041eea03a7f600727d2e41f_cgraph_map" alt=""></center>
<map name="group__MSC_g474b3f23a041eea03a7f600727d2e41f_cgraph_map">
<area href="group__BUS.html#gf8574f14855448ecae32c5a9dd0c7164" shape="rect" coords="227,5,354,32" alt="">
</map>

</div>
</div><p>
<a class="anchor" name="g25bb7197232a0fa92f3fc22d3a128161"></a><!-- doxytag: member="em_msc.h::MSC_ErasePage" ref="g25bb7197232a0fa92f3fc22d3a128161" args="(uint32_t *startAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a> MSC_ErasePage           </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>startAddress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases a page in flash memory. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>It is recommended to run this code from RAM. On the Gecko family, it is required to run this function from RAM.</dd></dl>
For IAR, Rowley, SimplicityStudio, Atollic and armgcc this will be achieved automatically by using attributes in the function proctype. For Keil uVision you must define a section called "ram_code" and place this manually in your project's scatter file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>startAddress</em>&nbsp;</td><td>Pointer to the flash page to erase. Must be aligned to beginning of page boundary. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the status of erase operation, <a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a> <div class="fragment"><pre class="fragment"> *   mscReturnOk - Operation completed successfully.
 *   mscReturnInvalidAddr - Operation tried to erase a non-flash area.
 *   mscReturnLocked - Operation tried to erase a locked area of the flash.
 *   mscReturnTimeOut - Operation timed out waiting for flash operation
 *       to complete.
 * </pre></div> </dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8c-source.html#l00637">637</a> of file <a class="el" href="em__msc_8c-source.html">em_msc.c</a>.
<p>
References <a class="el" href="em__msc_8h-source.html#l00072">MSC_PROGRAM_TIMEOUT</a>, <a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c09e4a7b0e66a5e0ce269c24448ad53ce9">mscReturnInvalidAddr</a>, <a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c06665fd5d688be1ae3622da00e3c44e80">mscReturnLocked</a>, <a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c01194171cf80ee1904596c838b67bf8dc">mscReturnOk</a>, and <a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c060b2f4d7977d34fde474915d77a86e82">mscReturnTimeOut</a>.
</div>
</div><p>
<a class="anchor" name="gbefc7774cd8e2ddf3c77895ca8198775"></a><!-- doxytag: member="em_msc.h::MSC_ExecConfigSet" ref="gbefc7774cd8e2ddf3c77895ca8198775" args="(MSC_ExecConfig_TypeDef *execConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MSC_ExecConfigSet           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMSC__ExecConfig__TypeDef.html">MSC_ExecConfig_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>execConfig</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set MSC code execution configuration. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>execConfig</em>&nbsp;</td><td>Code execution configuration </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8c-source.html#l00170">170</a> of file <a class="el" href="em__msc_8c-source.html">em_msc.c</a>.
<p>
References <a class="el" href="em__msc_8h-source.html#l00124">MSC_ExecConfig_TypeDef::aiDis</a>, <a class="el" href="em__msc_8h-source.html#l00125">MSC_ExecConfig_TypeDef::iccDis</a>, <a class="el" href="em__msc_8h-source.html#l00123">MSC_ExecConfig_TypeDef::ifcDis</a>, <a class="el" href="em__msc_8h-source.html#l00122">MSC_ExecConfig_TypeDef::prefetchEn</a>, <a class="el" href="em__msc_8h-source.html#l00121">MSC_ExecConfig_TypeDef::scbtEn</a>, and <a class="el" href="em__msc_8h-source.html#l00126">MSC_ExecConfig_TypeDef::useHprot</a>.
</div>
</div><p>
<a class="anchor" name="gd19a98dedaa95d382183f8e126243d64"></a><!-- doxytag: member="em_msc.h::MSC_FlushCache" ref="gd19a98dedaa95d382183f8e126243d64" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_FlushCache           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flush the contents of the instruction cache. 
<p>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00356">356</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="g0dc3182b945bc354c87b78eab586cfa7"></a><!-- doxytag: member="em_msc.h::MSC_GetCacheMeasurement" ref="g0dc3182b945bc354c87b78eab586cfa7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE int32_t MSC_GetCacheMeasurement           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stops measuring the hit rate. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This function is defined inline to minimize the impact of this code on the measurement itself. This code only works for relatively short sections of code. If you wish to measure longer sections of code you need to implement a IRQ Handler for The CHOF and CMOF overflow interrupts. Theses overflows needs to be counted and included in the total. The functions can then be implemented as follows: <div class="fragment"><pre class="fragment"> * volatile uint32_t hitOverflows
 * volatile uint32_t missOverflows
 *
 * void MSC_IRQHandler(void)
 * {
 *   uint32_t flags;
 *   flags = MSC-&gt;IF;
 *   if (flags &amp; MSC_IF_CHOF)
 *   {
 *      MSC-&gt;IFC = MSC_IF_CHOF;
 *      hitOverflows++;
 *   }
 *   if (flags &amp; MSC_IF_CMOF)
 *   {
 *     MSC-&gt;IFC = MSC_IF_CMOF;
 *     missOverflows++;
 *   }
 * }
 *
 * void startPerformanceCounters(void)
 * {
 *   hitOverflows = 0;
 *   missOverflows = 0;
 *
 *   MSC_IntEnable(MSC_IF_CHOF | MSC_IF_CMOF);
 *   NVIC_EnableIRQ(MSC_IRQn);
 *
 *   MSC_StartCacheMeasurement();
 * }
 * </pre></div> </dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns -1 if there has been no cache accesses. Returns -2 if there has been an overflow in the performance counters. If not, it will return the percentage of hits versus misses. </dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00324">324</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="ga02df815c14caedbc2fd0a8910d2e055"></a><!-- doxytag: member="em_msc.h::MSC_Init" ref="ga02df815c14caedbc2fd0a8910d2e055" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MSC_Init           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the flash controller for writing. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>IMPORTANT: This function must be called before flash operations when AUXHFRCO clock has been changed from default 14MHz band. <p>
This function calls SystemCoreClockGet in order to set the global variable SystemCoreClock which is used in subseqent calls of MSC_WriteWord to make sure the frequency is sufficiently high for flash operations. If the clock frequency is changed then software is responsible for calling MSC_Init or SystemCoreClockGet in order to set the SystemCoreClock variable to the correct value. </dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8c-source.html#l00101">101</a> of file <a class="el" href="em__msc_8c-source.html">em_msc.c</a>.
<p>
References <a class="el" href="em__cmu_8c-source.html#l01559">CMU_ClockFreqGet()</a>, and <a class="el" href="group__CMU.html#gg519ea66a1a21e07f2d1cccc9aa55799eab68f7d1104c6933fb997f6acbd10f34">cmuClock_AUX</a>.
<p>
Here is the call graph for this function:<p><center><img src="group__MSC_ga02df815c14caedbc2fd0a8910d2e055_cgraph.png" border="0" usemap="#group__MSC_ga02df815c14caedbc2fd0a8910d2e055_cgraph_map" alt=""></center>
<map name="group__MSC_ga02df815c14caedbc2fd0a8910d2e055_cgraph_map">
<area href="group__CMU.html#gc9aa0ed17f83bd48abcf7b430843374a" shape="rect" coords="128,31,272,57" alt="">
<area href="group__CMU.html#g3ac649cb01dd184676c6bdea7ff3d768" shape="rect" coords="320,5,445,32" alt="">
<area href="group__CMU.html#g535e1e8fa3a9131d7151cc549bfb4f29" shape="rect" coords="320,56,445,83" alt="">
</map>

</div>
</div><p>
<a class="anchor" name="g3e99a1115d2fdec306e3ebd3a9c5e3b4"></a><!-- doxytag: member="em_msc.h::MSC_IntClear" ref="g3e99a1115d2fdec306e3ebd3a9c5e3b4" args="(uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_IntClear           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear one or more pending MSC interrupts. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>Pending MSC intterupt source to clear. Use a bitwise logic OR combination of valid interrupt flags for the MSC module (MSC_IF_nnn). </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00163">163</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="ge93719c876be33cc035e8a4791c4c9fe"></a><!-- doxytag: member="em_msc.h::MSC_IntDisable" ref="ge93719c876be33cc035e8a4791c4c9fe" args="(uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_IntDisable           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable one or more MSC interrupts. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>MSC interrupt sources to disable. Use a bitwise logic OR combination of valid interrupt flags for the MSC module (MSC_IF_nnn). </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00176">176</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="g4824f067a4895d743b9d369b2d261e1c"></a><!-- doxytag: member="em_msc.h::MSC_IntEnable" ref="g4824f067a4895d743b9d369b2d261e1c" args="(uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_IntEnable           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable one or more MSC interrupts. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Depending on the use, a pending interrupt may already be set prior to enabling the interrupt. Consider using <a class="el" href="group__MSC.html#g3e99a1115d2fdec306e3ebd3a9c5e3b4">MSC_IntClear()</a> prior to enabling if such a pending interrupt should be ignored.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>MSC interrupt sources to enable. Use a bitwise logic OR combination of valid interrupt flags for the MSC module (MSC_IF_nnn). </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00195">195</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="ge8463b277bec80606e0eb8fe71641f78"></a><!-- doxytag: member="em_msc.h::MSC_IntGet" ref="ge8463b277bec80606e0eb8fe71641f78" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t MSC_IntGet           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get pending MSC interrupt flags. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>The event bits are not cleared by the use of this function.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>MSC interrupt sources pending. A bitwise logic OR combination of valid interrupt flags for the MSC module (MSC_IF_nnn). </dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00212">212</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="g30acc1e5a9cbe04debbc18e40f95ee65"></a><!-- doxytag: member="em_msc.h::MSC_IntGetEnabled" ref="g30acc1e5a9cbe04debbc18e40f95ee65" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t MSC_IntGetEnabled           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get enabled and pending MSC interrupt flags. Useful for handling more interrupt sources in the same interrupt handler. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>Interrupt flags are not cleared by the use of this function.</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>Pending and enabled MSC interrupt sources The return value is the bitwise AND of<ul>
<li>the enabled interrupt sources in MSC_IEN and</li><li>the pending interrupt flags MSC_IF </li></ul>
</dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00232">232</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="g0792aa6d5cef984923e3d10d44b5723f"></a><!-- doxytag: member="em_msc.h::MSC_IntSet" ref="g0792aa6d5cef984923e3d10d44b5723f" args="(uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_IntSet           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set one or more pending MSC interrupts from SW. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>MSC interrupt sources to set to pending. Use a bitwise logic OR combination of valid interrupt flags for the MSC module (MSC_IF_nnn). </td></tr>
  </table>
</dl>

<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00249">249</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="g9fad087d13139eb8e281ac49b52718a8"></a><!-- doxytag: member="em_msc.h::MSC_MassErase" ref="g9fad087d13139eb8e281ac49b52718a8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a> MSC_MassErase           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase entire flash in one operation. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>This command will erase the entire contents of the device. Use with care, both a debug session and all contents of the flash will be lost. The lock bit, MLW will prevent this operation from executing and might prevent successful mass erase. </dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8c-source.html#l00827">827</a> of file <a class="el" href="em__msc_8c-source.html">em_msc.c</a>.
<p>
References <a class="el" href="group__MSC.html#gga548bd1d520a543e249b6a85338b59c01194171cf80ee1904596c838b67bf8dc">mscReturnOk</a>.
</div>
</div><p>
<a class="anchor" name="gc7691792864bdeae85744036eac93f41"></a><!-- doxytag: member="em_msc.h::MSC_StartCacheMeasurement" ref="gc7691792864bdeae85744036eac93f41" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void MSC_StartCacheMeasurement           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts measuring cache hit ratio. 
<p>
This function starts the performance counters. It is defined inline to minimize the impact of this code on the measurement itself. 
<p>
Definition at line <a class="el" href="em__msc_8h-source.html#l00263">263</a> of file <a class="el" href="em__msc_8h-source.html">em_msc.h</a>.
</div>
</div><p>
<a class="anchor" name="g76309e04e090815bd80e7e5da3ee6ff6"></a><!-- doxytag: member="em_msc.h::MSC_WriteWord" ref="g76309e04e090815bd80e7e5da3ee6ff6" args="(uint32_t *address, void const *data, uint32_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a> MSC_WriteWord           </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes data to flash memory. This function is interrupt safe, but slower than <a class="el" href="group__MSC.html#gb9b796ba26919fd0f434bbb7c339f1c4">MSC_WriteWordFast()</a>, which writes to flash with interrupts disabled. Write data must be aligned to words and contain a number of bytes that is divisable by four. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>It is recommended to erase the flash page before performing a write.</dd></dl>
It is recommended to run this code from RAM. On the Gecko family, it is required to run this function from RAM.<p>
For IAR, Rowley, SimplicityStudio, Atollic and armgcc this will be achieved automatically by using attributes in the function proctype. For Keil uVision you must define a section called "ram_code" and place this manually in your project's scatter file.<p>
This function requires a ystem core clock at 1MHz or higher.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>Pointer to the flash word to write to. Must be aligned to words. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Data to write to flash. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numBytes</em>&nbsp;</td><td>Number of bytes to write from flash. NB: Must be divisable by four. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the status of the write operation <div class="fragment"><pre class="fragment"> *   flashReturnOk - Operation completed successfully.
 *   flashReturnInvalidAddr - Operation tried to erase a non-flash area.
 *   flashReturnLocked - Operation tried to erase a locked area of the flash.
 *   flashReturnTimeOut - Operation timed out waiting for flash operation
 *       to complete. Or the MSC timed out waiting for the software to write
 *       the next word into the DWORD register.
 * </pre></div> </dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8c-source.html#l00738">738</a> of file <a class="el" href="em__msc_8c-source.html">em_msc.c</a>.
</div>
</div><p>
<a class="anchor" name="gb9b796ba26919fd0f434bbb7c339f1c4"></a><!-- doxytag: member="em_msc.h::MSC_WriteWordFast" ref="gb9b796ba26919fd0f434bbb7c339f1c4" args="(uint32_t *address, void const *data, uint32_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__MSC.html#ga548bd1d520a543e249b6a85338b59c0">MSC_Status_TypeDef</a> MSC_WriteWordFast           </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes data to flash memory. This function is faster than <a class="el" href="group__MSC.html#g76309e04e090815bd80e7e5da3ee6ff6">MSC_WriteWord()</a>, but it disables interrupts. Write data must be aligned to words and contain a number of bytes that is divisable by four. 
<p>
<dl compact><dt><b>Note:</b></dt><dd>It is recommended to erase the flash page before performing a write.</dd></dl>
It is recommended to run this code from RAM. On the Gecko family, it is required to run this function from RAM.<p>
For IAR, Rowley, SimplicityStudio, Atollic and armgcc this will be achieved automatically by using attributes in the function proctype. For Keil uVision you must define a section called "ram_code" and place this manually in your project's scatter file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>address</em>&nbsp;</td><td>Pointer to the flash word to write to. Must be aligned to words. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Data to write to flash. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numBytes</em>&nbsp;</td><td>Number of bytes to write from flash. NB: Must be divisable by four. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the status of the write operation <div class="fragment"><pre class="fragment"> *   flashReturnOk - Operation completed successfully.
 *   flashReturnInvalidAddr - Operation tried to erase a non-flash area.
 *   flashReturnLocked - Operation tried to erase a locked area of the flash.
 *   flashReturnTimeOut - Operation timed out waiting for flash operation
 *       to complete. Or the MSC timed out waiting for the software to write
 *       the next word into the DWORD register.
 * </pre></div> </dd></dl>

<p>
Definition at line <a class="el" href="em__msc_8c-source.html#l00797">797</a> of file <a class="el" href="em__msc_8c-source.html">em_msc.c</a>.
</div>
</div><p>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Thu Sep 10 08:15:58 2015</small> for Silicon Labs EZR32 emlib Peripheral Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.4.7 </small></address></div>
</body>
</html>
