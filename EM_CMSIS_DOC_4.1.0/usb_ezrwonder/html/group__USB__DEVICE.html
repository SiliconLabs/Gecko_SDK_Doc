<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs EZR32 USB Stack: USB_DEVICE</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>USB_DEVICE<br/>
<small>
[<a class="el" href="group__USB.html">USB</a>]</small>
</h1>
<p>USB DEVICE protocol stack, see <a class="el" href="usb__device.html">USB device stack library</a> page for detailed documentation.  
<a href="#_details">More...</a></p>

<p><div class="dynheader">
Collaboration diagram for USB_DEVICE:</div>
<div class="dynsection">
<center><table><tr><td><img src="group__USB__DEVICE.png" border="0" alt="" usemap="#group____USB____DEVICE_map"/>
<map name="group____USB____DEVICE_map" id="group____USB____DEVICE">
<area shape="rect" id="node2" href="group__USB.html" title="USB HOST and DEVICE protocol stacks." alt="" coords="6,5,53,32"/></map></td></tr></table></center>
</div>
</p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUSBD__Init__TypeDef.html">USBD_Init_TypeDef</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB Device stack initialization structure.  <a href="structUSBD__Init__TypeDef.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUSBD__Callbacks__TypeDef.html">USBD_Callbacks_TypeDef</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB Device stack callback structure.  <a href="structUSBD__Callbacks__TypeDef.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gaed832194c88151c731cdc01d356d5715">USB_PWRSAVE_MODE_OFF</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">No energy saving mode selected.  <a href="#gaed832194c88151c731cdc01d356d5715"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gaecc3288da02dc30b204b355a3fb2a8af">USB_PWRSAVE_MODE_ONSUSPEND</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter USB power-save mode on suspend.  <a href="#gaecc3288da02dc30b204b355a3fb2a8af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gab3b6ff4a605085b5491c986590e485a1">USB_PWRSAVE_MODE_ONVBUSOFF</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter USB power-save mode when not attached to host.  <a href="#gab3b6ff4a605085b5491c986590e485a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga001311728c77fec4acc7c9f1d014807d">USB_PWRSAVE_MODE_ENTEREM2</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enter EM2 while in power-save mode.  <a href="#ga001311728c77fec4acc7c9f1d014807d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gaf8d187657d473708015f844f4c8aa61e">USB_USBC_32kHz_CLK_LFXO</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use 32kHz LFXO clock while in powersave mode.  <a href="#gaf8d187657d473708015f844f4c8aa61e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gaac14afa136f38a5e84029f8f027cc216">USB_USBC_32kHz_CLK_LFRCO</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use 32kHz LFRCO clock while in powersave mode.  <a href="#gaac14afa136f38a5e84029f8f027cc216"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gafad47dbaf3af2786eec106d0594b9d4b">USBD_UsbResetCb_TypeDef</a> )(void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB Reset callback function.  <a href="#gafad47dbaf3af2786eec106d0594b9d4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga0dc83723a1a28a1b6bea080d36125567">USBD_SofIntCb_TypeDef</a> )(uint16_t sofNr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB Start Of Frame (SOF) interrupt callback function.  <a href="#ga0dc83723a1a28a1b6bea080d36125567"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga6f06aa8508bb655941774d7f688ffb85">USBD_DeviceStateChangeCb_TypeDef</a> )(<a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a> oldState, <a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a> newState)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB State change callback function.  <a href="#ga6f06aa8508bb655941774d7f688ffb85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bool(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gaba846e8094973b242a43be1edcfc8451">USBD_IsSelfPoweredCb_TypeDef</a> )(void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB power mode callback function.  <a href="#gaba846e8094973b242a43be1edcfc8451"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gaeab2bf0232b86efd7afb6ad54ae950a6">USBD_SetupCmdCb_TypeDef</a> )(const <a class="el" href="structUSB__Setup__TypeDef.html">USB_Setup_TypeDef</a> *setup)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB setup request callback function.  <a href="#gaeab2bf0232b86efd7afb6ad54ae950a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="structUSBD__Callbacks__TypeDef.html">USBD_Callbacks_TypeDef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gaa981b243246dbd611a4ba8bdd042424a">USBD_Callbacks_TypeDef</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USB Device stack callback structure.  <a href="#gaa981b243246dbd611a4ba8bdd042424a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__USB__DEVICE.html#gga437a2e7bf70740fc715ac9a5c7310a6da35ca8b56bdc46ce0dd7c39400796ba7c">USBD_STATE_NONE</a> =  0, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__USB__DEVICE.html#gga437a2e7bf70740fc715ac9a5c7310a6da01e32e620c7692ea767d99bb4120940b">USBD_STATE_ATTACHED</a> =  1, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__USB__DEVICE.html#gga437a2e7bf70740fc715ac9a5c7310a6da47b9228ad86b300416ed28d2c2b7e5d3">USBD_STATE_POWERED</a> =  2, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__USB__DEVICE.html#gga437a2e7bf70740fc715ac9a5c7310a6da978c707d313eb49b70bc62dfae304048">USBD_STATE_DEFAULT</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__USB__DEVICE.html#gga437a2e7bf70740fc715ac9a5c7310a6da8abe2fca377f950a2a9c95316f5246be">USBD_STATE_ADDRESSED</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__USB__DEVICE.html#gga437a2e7bf70740fc715ac9a5c7310a6da44c1920b09ea1062ea4d7ac31a846509">USBD_STATE_CONFIGURED</a> =  5, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__USB__DEVICE.html#gga437a2e7bf70740fc715ac9a5c7310a6da74e1d49afc6b25e202cc9e42f595f4ed">USBD_STATE_SUSPENDED</a> =  6, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__USB__DEVICE.html#gga437a2e7bf70740fc715ac9a5c7310a6dad588a80fcef0bcb009e0822908b36d29">USBD_STATE_LASTMARKER</a> =  7
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>USB device state enumerator. </p>
 <a href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga325117af9b3a9ad1df068cf3b19dc1ba">USBD_AbortAllTransfers</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort all pending transfers.  <a href="#ga325117af9b3a9ad1df068cf3b19dc1ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga83f32dfa4f6a5d010e413967850c52b2">USBD_AbortTransfer</a> (int epAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abort a pending transfer on a specific endpoint.  <a href="#ga83f32dfa4f6a5d010e413967850c52b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga71b9264662d74666e4b058984e3346e5">USBD_Connect</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start USB device operation.  <a href="#ga71b9264662d74666e4b058984e3346e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga2d952f8cf9bde552cfd5559ae47e70fc">USBD_Disconnect</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop USB device operation.  <a href="#ga2d952f8cf9bde552cfd5559ae47e70fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga9eb41fa7508126bea30d672b777e250f">USBD_EpIsBusy</a> (int epAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if an endpoint is busy doing a transfer.  <a href="#ga9eb41fa7508126bea30d672b777e250f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gab4e55bb0aacaa90aab28a79e9b131b0f">USBD_GetUsbState</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get current USB device state.  <a href="#gab4e55bb0aacaa90aab28a79e9b131b0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga7c151fd9cf5ab159d8a74cf65a27975f">USBD_GetUsbStateName</a> (<a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a> state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a string naming a device USB state.  <a href="#ga7c151fd9cf5ab159d8a74cf65a27975f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga0e5f5bd847e7cc1c4c384bb6b7f0ce77">USBD_Init</a> (const <a class="el" href="structUSBD__Init__TypeDef.html">USBD_Init_TypeDef</a> *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initializes USB device hardware and internal protocol stack data structures, then connects the data-line (D+ or D-) pullup resistor to signal host that enumeration can begin.  <a href="#ga0e5f5bd847e7cc1c4c384bb6b7f0ce77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga9e0a1cf705301d9e035feff27ea41cda">USBD_Read</a> (int epAddr, void *data, int byteCount, <a class="el" href="group__USB__COMMON.html#ga521fe3060be2a8de6fdd5ee01193958b">USB_XferCompleteCb_TypeDef</a> callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a read (OUT) transfer on an endpoint.  <a href="#ga9e0a1cf705301d9e035feff27ea41cda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga9fb12718f509c578656e4fc08bc40f69">USBD_RemoteWakeup</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Perform a remote wakeup signalling sequence.  <a href="#ga9fb12718f509c578656e4fc08bc40f69"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga958a83c23eaa9fd51672808ac7c3fa65">USBD_SafeToEnterEM2</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if it is ok to enter energy mode EM2.  <a href="#ga958a83c23eaa9fd51672808ac7c3fa65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga9bf435e62169bfb3ee0a43ef0e9d009d">USBD_StallEp</a> (int epAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set an endpoint in the stalled (halted) state.  <a href="#ga9bf435e62169bfb3ee0a43ef0e9d009d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gae26fedf61e90eb1e50ae5d24cd65d0b8">USBD_Stop</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop USB device stack operation.  <a href="#gae26fedf61e90eb1e50ae5d24cd65d0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#gacb0ed1c21fd4aecfe96060ea87a617a8">USBD_UnStallEp</a> (int epAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset stall state on a stalled (halted) endpoint.  <a href="#gacb0ed1c21fd4aecfe96060ea87a617a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__USB__DEVICE.html#ga656c8d2935af97156bc0babdc43c32ee">USBD_Write</a> (int epAddr, void *data, int byteCount, <a class="el" href="group__USB__COMMON.html#ga521fe3060be2a8de6fdd5ee01193958b">USB_XferCompleteCb_TypeDef</a> callback)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start a write (IN) transfer on an endpoint.  <a href="#ga656c8d2935af97156bc0babdc43c32ee"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>USB DEVICE protocol stack, see <a class="el" href="usb__device.html">USB device stack library</a> page for detailed documentation. </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga001311728c77fec4acc7c9f1d014807d"></a><!-- doxytag: member="em_usb.h::USB_PWRSAVE_MODE_ENTEREM2" ref="ga001311728c77fec4acc7c9f1d014807d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_PWRSAVE_MODE_ENTEREM2&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enter EM2 while in power-save mode. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00350">350</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaed832194c88151c731cdc01d356d5715"></a><!-- doxytag: member="em_usb.h::USB_PWRSAVE_MODE_OFF" ref="gaed832194c88151c731cdc01d356d5715" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_PWRSAVE_MODE_OFF&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>No energy saving mode selected. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00347">347</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaecc3288da02dc30b204b355a3fb2a8af"></a><!-- doxytag: member="em_usb.h::USB_PWRSAVE_MODE_ONSUSPEND" ref="gaecc3288da02dc30b204b355a3fb2a8af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_PWRSAVE_MODE_ONSUSPEND&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enter USB power-save mode on suspend. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00348">348</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gab3b6ff4a605085b5491c986590e485a1"></a><!-- doxytag: member="em_usb.h::USB_PWRSAVE_MODE_ONVBUSOFF" ref="gab3b6ff4a605085b5491c986590e485a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_PWRSAVE_MODE_ONVBUSOFF&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enter USB power-save mode when not attached to host. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00349">349</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaac14afa136f38a5e84029f8f027cc216"></a><!-- doxytag: member="em_usb.h::USB_USBC_32kHz_CLK_LFRCO" ref="gaac14afa136f38a5e84029f8f027cc216" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_USBC_32kHz_CLK_LFRCO&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use 32kHz LFRCO clock while in powersave mode. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00353">353</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf8d187657d473708015f844f4c8aa61e"></a><!-- doxytag: member="em_usb.h::USB_USBC_32kHz_CLK_LFXO" ref="gaf8d187657d473708015f844f4c8aa61e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USB_USBC_32kHz_CLK_LFXO&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use 32kHz LFXO clock while in powersave mode. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00352">352</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaa981b243246dbd611a4ba8bdd042424a"></a><!-- doxytag: member="em_usb.h::USBD_Callbacks_TypeDef" ref="gaa981b243246dbd611a4ba8bdd042424a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUSBD__Callbacks__TypeDef.html">USBD_Callbacks_TypeDef</a>  <a class="el" href="structUSBD__Callbacks__TypeDef.html">USBD_Callbacks_TypeDef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB Device stack callback structure. </p>
<p>Callback functions used by the device stack to signal events or query status to/from the application. See <a class="el" href="structUSBD__Init__TypeDef.html">USBD_Init_TypeDef</a>. Assign members to NULL if your application don't need a specific callback. </p>

</div>
</div>
<a class="anchor" id="ga6f06aa8508bb655941774d7f688ffb85"></a><!-- doxytag: member="em_usb.h::USBD_DeviceStateChangeCb_TypeDef" ref="ga6f06aa8508bb655941774d7f688ffb85" args=")(USBD_State_TypeDef oldState, USBD_State_TypeDef newState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__USB__DEVICE.html#ga6f06aa8508bb655941774d7f688ffb85">USBD_DeviceStateChangeCb_TypeDef</a>)(<a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a> oldState, <a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a> newState)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB State change callback function. </p>
<p>Called whenever the device change state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>oldState</em>&nbsp;</td><td>The device USB state just leaved. See <a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a>.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newState</em>&nbsp;</td><td>New (the current) USB device state. See <a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00731">731</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaba846e8094973b242a43be1edcfc8451"></a><!-- doxytag: member="em_usb.h::USBD_IsSelfPoweredCb_TypeDef" ref="gaba846e8094973b242a43be1edcfc8451" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* <a class="el" href="group__USB__DEVICE.html#gaba846e8094973b242a43be1edcfc8451">USBD_IsSelfPoweredCb_TypeDef</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB power mode callback function. </p>
<p>Called whenever the device stack needs to query if the device is currently self- or bus-powered. Typically when host has issued an <a class="el" href="group__USB__COMMON.html#gaeba76c92af8f1a94982ec4cb767452f0">GET_STATUS</a> setup command.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if self-powered, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00745">745</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeab2bf0232b86efd7afb6ad54ae950a6"></a><!-- doxytag: member="em_usb.h::USBD_SetupCmdCb_TypeDef" ref="gaeab2bf0232b86efd7afb6ad54ae950a6" args=")(const USB_Setup_TypeDef *setup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__USB__DEVICE.html#gaeab2bf0232b86efd7afb6ad54ae950a6">USBD_SetupCmdCb_TypeDef</a>)(const <a class="el" href="structUSB__Setup__TypeDef.html">USB_Setup_TypeDef</a> *setup)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB setup request callback function. </p>
<p>Called on each setup request received from host. This gives the application a possibility to extend or override standard requests, and to implement class or vendor specific requests. Return <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> if the request is handled, return <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a551e7a6fbdf7e891b8232818179fa229">USB_STATUS_REQ_ERR</a> if it is an illegal request or return <a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1ae32e2e8da1dce5b54ea6542adabec3a4">USB_STATUS_REQ_UNHANDLED</a> to pass the request on to the default request handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>setup</em>&nbsp;</td><td>Pointer to an USB setup packet. See <a class="el" href="structUSB__Setup__TypeDef.html">USB_Setup_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An appropriate status/error code. See <a class="el" href="group__USB__COMMON.html#ga889b575b566a663621c33eebf46272c1">USB_Status_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00765">765</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0dc83723a1a28a1b6bea080d36125567"></a><!-- doxytag: member="em_usb.h::USBD_SofIntCb_TypeDef" ref="ga0dc83723a1a28a1b6bea080d36125567" args=")(uint16_t sofNr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__USB__DEVICE.html#ga0dc83723a1a28a1b6bea080d36125567">USBD_SofIntCb_TypeDef</a>)(uint16_t sofNr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB Start Of Frame (SOF) interrupt callback function. </p>
<p>Called at each SOF interrupt (if enabled),</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sofNr</em>&nbsp;</td><td>Current frame number. The value rolls over to 0 after 16383 (0x3FFF). </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00716">716</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<a class="anchor" id="gafad47dbaf3af2786eec106d0594b9d4b"></a><!-- doxytag: member="em_usb.h::USBD_UsbResetCb_TypeDef" ref="gafad47dbaf3af2786eec106d0594b9d4b" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__USB__DEVICE.html#gafad47dbaf3af2786eec106d0594b9d4b">USBD_UsbResetCb_TypeDef</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB Reset callback function. </p>
<p>Called whenever USB reset signalling is detected on the USB port. </p>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00704">704</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga437a2e7bf70740fc715ac9a5c7310a6d"></a><!-- doxytag: member="em_usb.h::USBD_State_TypeDef" ref="ga437a2e7bf70740fc715ac9a5c7310a6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>USB device state enumerator. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga437a2e7bf70740fc715ac9a5c7310a6da35ca8b56bdc46ce0dd7c39400796ba7c"></a><!-- doxytag: member="USBD_STATE_NONE" ref="gga437a2e7bf70740fc715ac9a5c7310a6da35ca8b56bdc46ce0dd7c39400796ba7c" args="" -->USBD_STATE_NONE</em>&nbsp;</td><td>
<p>Device state is undefined/unknown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga437a2e7bf70740fc715ac9a5c7310a6da01e32e620c7692ea767d99bb4120940b"></a><!-- doxytag: member="USBD_STATE_ATTACHED" ref="gga437a2e7bf70740fc715ac9a5c7310a6da01e32e620c7692ea767d99bb4120940b" args="" -->USBD_STATE_ATTACHED</em>&nbsp;</td><td>
<p>Device state is ATTACHED. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga437a2e7bf70740fc715ac9a5c7310a6da47b9228ad86b300416ed28d2c2b7e5d3"></a><!-- doxytag: member="USBD_STATE_POWERED" ref="gga437a2e7bf70740fc715ac9a5c7310a6da47b9228ad86b300416ed28d2c2b7e5d3" args="" -->USBD_STATE_POWERED</em>&nbsp;</td><td>
<p>Device state is POWERED. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga437a2e7bf70740fc715ac9a5c7310a6da978c707d313eb49b70bc62dfae304048"></a><!-- doxytag: member="USBD_STATE_DEFAULT" ref="gga437a2e7bf70740fc715ac9a5c7310a6da978c707d313eb49b70bc62dfae304048" args="" -->USBD_STATE_DEFAULT</em>&nbsp;</td><td>
<p>Device state is DEFAULT. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga437a2e7bf70740fc715ac9a5c7310a6da8abe2fca377f950a2a9c95316f5246be"></a><!-- doxytag: member="USBD_STATE_ADDRESSED" ref="gga437a2e7bf70740fc715ac9a5c7310a6da8abe2fca377f950a2a9c95316f5246be" args="" -->USBD_STATE_ADDRESSED</em>&nbsp;</td><td>
<p>Device state is ADDRESSED. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga437a2e7bf70740fc715ac9a5c7310a6da44c1920b09ea1062ea4d7ac31a846509"></a><!-- doxytag: member="USBD_STATE_CONFIGURED" ref="gga437a2e7bf70740fc715ac9a5c7310a6da44c1920b09ea1062ea4d7ac31a846509" args="" -->USBD_STATE_CONFIGURED</em>&nbsp;</td><td>
<p>Device state is CONFIGURED. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga437a2e7bf70740fc715ac9a5c7310a6da74e1d49afc6b25e202cc9e42f595f4ed"></a><!-- doxytag: member="USBD_STATE_SUSPENDED" ref="gga437a2e7bf70740fc715ac9a5c7310a6da74e1d49afc6b25e202cc9e42f595f4ed" args="" -->USBD_STATE_SUSPENDED</em>&nbsp;</td><td>
<p>Device state is SUSPENDED. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga437a2e7bf70740fc715ac9a5c7310a6dad588a80fcef0bcb009e0822908b36d29"></a><!-- doxytag: member="USBD_STATE_LASTMARKER" ref="gga437a2e7bf70740fc715ac9a5c7310a6dad588a80fcef0bcb009e0822908b36d29" args="" -->USBD_STATE_LASTMARKER</em>&nbsp;</td><td>
<p>Device state enum end marker. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="em__usb_8h_source.html#l00356">356</a> of file <a class="el" href="em__usb_8h_source.html">em_usb.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga325117af9b3a9ad1df068cf3b19dc1ba"></a><!-- doxytag: member="em_usb.h::USBD_AbortAllTransfers" ref="ga325117af9b3a9ad1df068cf3b19dc1ba" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_AbortAllTransfers </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort all pending transfers. </p>
<p>Aborts transfers for all endpoints currently in use. Pending transfers on the default endpoint (EP0) are not aborted. </p>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00053">53</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00325">USB_STATUS_EP_ABORTED</a>.</p>

</div>
</div>
<a class="anchor" id="ga83f32dfa4f6a5d010e413967850c52b2"></a><!-- doxytag: member="em_usb.h::USBD_AbortTransfer" ref="ga83f32dfa4f6a5d010e413967850c52b2" args="(int epAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBD_AbortTransfer </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>epAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Abort a pending transfer on a specific endpoint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>epAddr</em>&nbsp;</td><td>The address of the endpoint to abort. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00067">67</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00325">USB_STATUS_EP_ABORTED</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usb_8h_source.html#l00362">USBD_STATE_ADDRESSED</a>, and <a class="el" href="em__usb_8h_source.html#l00363">USBD_STATE_CONFIGURED</a>.</p>

</div>
</div>
<a class="anchor" id="ga71b9264662d74666e4b058984e3346e5"></a><!-- doxytag: member="em_usb.h::USBD_Connect" ref="ga71b9264662d74666e4b058984e3346e5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_Connect </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start USB device operation. </p>
<p>Device operation is started by connecting a pullup resistor on the appropriate USB data line. </p>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00123">123</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d952f8cf9bde552cfd5559ae47e70fc"></a><!-- doxytag: member="em_usb.h::USBD_Disconnect" ref="ga2d952f8cf9bde552cfd5559ae47e70fc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_Disconnect </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop USB device operation. </p>
<p>Device operation is stopped by disconnecting the pullup resistor from the appropriate USB data line. Often referred to as a "soft" disconnect. </p>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00138">138</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>Referenced by <a class="el" href="em__usbd_8c_source.html#l00747">USBD_Stop()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__USB__DEVICE_ga2d952f8cf9bde552cfd5559ae47e70fc_icgraph.png" border="0" usemap="#group__USB__DEVICE_ga2d952f8cf9bde552cfd5559ae47e70fc_icgraph_map" alt=""></div>
<map name="group__USB__DEVICE_ga2d952f8cf9bde552cfd5559ae47e70fc_icgraph_map" id="group__USB__DEVICE_ga2d952f8cf9bde552cfd5559ae47e70fc_icgraph">
<area shape="rect" id="node2" href="group__USB__DEVICE.html#gae26fedf61e90eb1e50ae5d24cd65d0b8" title="Stop USB device stack operation." alt="" coords="190,5,282,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9eb41fa7508126bea30d672b777e250f"></a><!-- doxytag: member="em_usb.h::USBD_EpIsBusy" ref="ga9eb41fa7508126bea30d672b777e250f" args="(int epAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USBD_EpIsBusy </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>epAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if an endpoint is busy doing a transfer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>epAddr</em>&nbsp;</td><td>The address of the endpoint to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if endpoint is busy, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00155">155</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>.</p>

</div>
</div>
<a class="anchor" id="gab4e55bb0aacaa90aab28a79e9b131b0f"></a><!-- doxytag: member="em_usb.h::USBD_GetUsbState" ref="gab4e55bb0aacaa90aab28a79e9b131b0f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a> USBD_GetUsbState </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get current USB device state. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Device USB state. See <a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a>. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00179">179</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>Referenced by <a class="el" href="em__usbd_8c_source.html#l00545">USBD_Read()</a>, and <a class="el" href="em__usbd_8c_source.html#l00820">USBD_Write()</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__USB__DEVICE_gab4e55bb0aacaa90aab28a79e9b131b0f_icgraph.png" border="0" usemap="#group__USB__DEVICE_gab4e55bb0aacaa90aab28a79e9b131b0f_icgraph_map" alt=""></div>
<map name="group__USB__DEVICE_gab4e55bb0aacaa90aab28a79e9b131b0f_icgraph_map" id="group__USB__DEVICE_gab4e55bb0aacaa90aab28a79e9b131b0f_icgraph">
<area shape="rect" id="node2" href="group__USB__DEVICE.html#ga9e0a1cf705301d9e035feff27ea41cda" title="Start a read (OUT) transfer on an endpoint." alt="" coords="198,5,295,32"/><area shape="rect" id="node3" href="group__USB__DEVICE.html#ga656c8d2935af97156bc0babdc43c32ee" title="Start a write (IN) transfer on an endpoint." alt="" coords="198,56,295,83"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga7c151fd9cf5ab159d8a74cf65a27975f"></a><!-- doxytag: member="em_usb.h::USBD_GetUsbStateName" ref="ga7c151fd9cf5ab159d8a74cf65a27975f" args="(USBD_State_TypeDef state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* USBD_GetUsbStateName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a>&nbsp;</td>
          <td class="paramname"> <em>state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a string naming a device USB state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>state</em>&nbsp;</td><td>Device USB state. See <a class="el" href="group__USB__DEVICE.html#ga437a2e7bf70740fc715ac9a5c7310a6d">USBD_State_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>State name string pointer. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00194">194</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00365">USBD_STATE_LASTMARKER</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e5f5bd847e7cc1c4c384bb6b7f0ce77"></a><!-- doxytag: member="em_usb.h::USBD_Init" ref="ga0e5f5bd847e7cc1c4c384bb6b7f0ce77" args="(const USBD_Init_TypeDef *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBD_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUSBD__Init__TypeDef.html">USBD_Init_TypeDef</a> *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes USB device hardware and internal protocol stack data structures, then connects the data-line (D+ or D-) pullup resistor to signal host that enumeration can begin. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>You may later use <a class="el" href="group__USB__DEVICE.html#ga2d952f8cf9bde552cfd5559ae47e70fc">USBD_Disconnect()</a> and <a class="el" href="group__USB__DEVICE.html#ga71b9264662d74666e4b058984e3346e5">USBD_Connect()</a> to force reenumeration.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>p</em>&nbsp;</td><td>Pointer to device initialization struct. See <a class="el" href="structUSBD__Init__TypeDef.html">USBD_Init_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00218">218</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00464">USB_InterfaceDescriptor_TypeDef::bAlternateSetting</a>, <a class="el" href="em__usb_8h_source.html#l00502">USB_EndpointDescriptor_TypeDef::bEndpointAddress</a>, <a class="el" href="em__usb_8h_source.html#l00461">USB_InterfaceDescriptor_TypeDef::bInterfaceNumber</a>, <a class="el" href="em__usb_8h_source.html#l00503">USB_EndpointDescriptor_TypeDef::bmAttributes</a>, <a class="el" href="em__usb_8h_source.html#l00413">USB_DeviceDescriptor_TypeDef::bMaxPacketSize0</a>, <a class="el" href="em__usb_8h_source.html#l00782">USBD_Init_TypeDef::bufferingMultiplier</a>, <a class="el" href="em__usb_8h_source.html#l00787">USBD_Init_TypeDef::callbacks</a>, <a class="el" href="em__usb_8h_source.html#l00186">CONFIG_DESC_BM_TRANSFERTYPE</a>, <a class="el" href="em__usb_8h_source.html#l00779">USBD_Init_TypeDef::configDescriptor</a>, <a class="el" href="em__usb_8h_source.html#l00778">USBD_Init_TypeDef::deviceDescriptor</a>, <a class="el" href="em__usb_8h_source.html#l00781">USBD_Init_TypeDef::numberOfStrings</a>, <a class="el" href="em__usb_8h_source.html#l00780">USBD_Init_TypeDef::stringDescriptors</a>, <a class="el" href="em__usb_8h_source.html#l00121">USB_ENDPOINT_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00179">USB_EPNUM_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00169">USB_EPTYPE_CTRL</a>, <a class="el" href="em__usb_8h_source.html#l00120">USB_INTERFACE_DESCRIPTOR</a>, <a class="el" href="em__usb_8h_source.html#l00060">USB_SETUP_DIR_MASK</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usb_8h_source.html#l00365">USBD_STATE_LASTMARKER</a>, <a class="el" href="em__usb_8h_source.html#l00358">USBD_STATE_NONE</a>, <a class="el" href="em__usb_8h_source.html#l00360">USBD_STATE_POWERED</a>, <a class="el" href="em__usbtimer_8c_source.html#l00190">USBTIMER_Init()</a>, and <a class="el" href="em__usb_8h_source.html#l00504">USB_EndpointDescriptor_TypeDef::wMaxPacketSize</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__USB__DEVICE_ga0e5f5bd847e7cc1c4c384bb6b7f0ce77_cgraph.png" border="0" usemap="#group__USB__DEVICE_ga0e5f5bd847e7cc1c4c384bb6b7f0ce77_cgraph_map" alt=""></div>
<map name="group__USB__DEVICE_ga0e5f5bd847e7cc1c4c384bb6b7f0ce77_cgraph_map" id="group__USB__DEVICE_ga0e5f5bd847e7cc1c4c384bb6b7f0ce77_cgraph">
<area shape="rect" id="node2" href="group__USB__COMMON.html#ga21c87b800d87fd731173dd4f48f23c28" title="Activate the hardware timer used to pace the 1 millisecond timer system." alt="" coords="137,5,247,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9e0a1cf705301d9e035feff27ea41cda"></a><!-- doxytag: member="em_usb.h::USBD_Read" ref="ga9e0a1cf705301d9e035feff27ea41cda" args="(int epAddr, void *data, int byteCount, USB_XferCompleteCb_TypeDef callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBD_Read </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__USB__COMMON.html#ga521fe3060be2a8de6fdd5ee01193958b">USB_XferCompleteCb_TypeDef</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a read (OUT) transfer on an endpoint. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The transfer buffer length must be a multiple of 4 bytes in length and WORD (4 byte) aligned. When allocating the buffer, round buffer length up. If it is possible that the host will send more data than your device expects, round buffer size up to the next multiple of maxpacket size.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>epAddr</em>&nbsp;</td><td>Endpoint address.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to transfer data buffer.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byteCount</em>&nbsp;</td><td>Transfer length.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Function to be called on transfer completion. Supply NULL if no callback is needed. See <a class="el" href="group__USB__COMMON.html#ga521fe3060be2a8de6fdd5ee01193958b">USB_XferCompleteCb_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00545">545</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00328">USB_STATUS_DEVICE_UNCONFIGURED</a>, <a class="el" href="em__usb_8h_source.html#l00321">USB_STATUS_EP_BUSY</a>, <a class="el" href="em__usb_8h_source.html#l00324">USB_STATUS_EP_STALLED</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usbd_8c_source.html#l00179">USBD_GetUsbState()</a>, and <a class="el" href="em__usb_8h_source.html#l00363">USBD_STATE_CONFIGURED</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__USB__DEVICE_ga9e0a1cf705301d9e035feff27ea41cda_cgraph.png" border="0" usemap="#group__USB__DEVICE_ga9e0a1cf705301d9e035feff27ea41cda_cgraph_map" alt=""></div>
<map name="group__USB__DEVICE_ga9e0a1cf705301d9e035feff27ea41cda_cgraph_map" id="group__USB__DEVICE_ga9e0a1cf705301d9e035feff27ea41cda_cgraph">
<area shape="rect" id="node2" href="group__USB__DEVICE.html#gab4e55bb0aacaa90aab28a79e9b131b0f" title="Get current USB device state." alt="" coords="153,5,295,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga9fb12718f509c578656e4fc08bc40f69"></a><!-- doxytag: member="em_usb.h::USBD_RemoteWakeup" ref="ga9fb12718f509c578656e4fc08bc40f69" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBD_RemoteWakeup </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform a remote wakeup signalling sequence. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the application to ensure that remote wakeup is not attempted before the device has been suspended for at least 5 miliseconds. This function should not be called from within an interrupt handler.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00631">631</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usb_8h_source.html#l00364">USBD_STATE_SUSPENDED</a>, and <a class="el" href="em__usbtimer_8c_source.html#l00135">USBTIMER_DelayMs()</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__USB__DEVICE_ga9fb12718f509c578656e4fc08bc40f69_cgraph.png" border="0" usemap="#group__USB__DEVICE_ga9fb12718f509c578656e4fc08bc40f69_cgraph_map" alt=""></div>
<map name="group__USB__DEVICE_ga9fb12718f509c578656e4fc08bc40f69_cgraph_map" id="group__USB__DEVICE_ga9fb12718f509c578656e4fc08bc40f69_cgraph">
<area shape="rect" id="node2" href="group__USB__COMMON.html#gabb1c11cad365c7c3b99a3e7826035951" title="Active wait millisecond delay function." alt="" coords="221,5,368,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga958a83c23eaa9fd51672808ac7c3fa65"></a><!-- doxytag: member="em_usb.h::USBD_SafeToEnterEM2" ref="ga958a83c23eaa9fd51672808ac7c3fa65" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool USBD_SafeToEnterEM2 </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if it is ok to enter energy mode EM2. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Before entering EM2 both the USB hardware and the USB stack must be in a certain state, this function checks if all conditions for entering EM2 is met. Refer to the <a class="el" href="usb__device.html#usb_device_powersave">Energy-saving modes</a> section for more information.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if ok to enter EM2, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00665">665</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

</div>
</div>
<a class="anchor" id="ga9bf435e62169bfb3ee0a43ef0e9d009d"></a><!-- doxytag: member="em_usb.h::USBD_StallEp" ref="ga9bf435e62169bfb3ee0a43ef0e9d009d" args="(int epAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBD_StallEp </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>epAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set an endpoint in the stalled (halted) state. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>epAddr</em>&nbsp;</td><td>The address of the endpoint to stall.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00708">708</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, and <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="gae26fedf61e90eb1e50ae5d24cd65d0b8"></a><!-- doxytag: member="em_usb.h::USBD_Stop" ref="gae26fedf61e90eb1e50ae5d24cd65d0b8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USBD_Stop </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stop USB device stack operation. </p>
<p>The data-line pullup resistor is turned off, USB interrupts are disabled, and finally the USB pins are disabled. </p>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00747">747</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usbd_8c_source.html#l00138">USBD_Disconnect()</a>, and <a class="el" href="em__usb_8h_source.html#l00358">USBD_STATE_NONE</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__USB__DEVICE_gae26fedf61e90eb1e50ae5d24cd65d0b8_cgraph.png" border="0" usemap="#group__USB__DEVICE_gae26fedf61e90eb1e50ae5d24cd65d0b8_cgraph_map" alt=""></div>
<map name="group__USB__DEVICE_gae26fedf61e90eb1e50ae5d24cd65d0b8_cgraph_map" id="group__USB__DEVICE_gae26fedf61e90eb1e50ae5d24cd65d0b8_cgraph">
<area shape="rect" id="node2" href="group__USB__DEVICE.html#ga2d952f8cf9bde552cfd5559ae47e70fc" title="Stop USB device operation." alt="" coords="147,5,283,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gacb0ed1c21fd4aecfe96060ea87a617a8"></a><!-- doxytag: member="em_usb.h::USBD_UnStallEp" ref="gacb0ed1c21fd4aecfe96060ea87a617a8" args="(int epAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBD_UnStallEp </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>epAddr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset stall state on a stalled (halted) endpoint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>epAddr</em>&nbsp;</td><td>The address of the endpoint to un-stall.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00769">769</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, and <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>.</p>

</div>
</div>
<a class="anchor" id="ga656c8d2935af97156bc0babdc43c32ee"></a><!-- doxytag: member="em_usb.h::USBD_Write" ref="ga656c8d2935af97156bc0babdc43c32ee" args="(int epAddr, void *data, int byteCount, USB_XferCompleteCb_TypeDef callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int USBD_Write </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>epAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__USB__COMMON.html#ga521fe3060be2a8de6fdd5ee01193958b">USB_XferCompleteCb_TypeDef</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start a write (IN) transfer on an endpoint. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>epAddr</em>&nbsp;</td><td>Endpoint address.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Pointer to transfer data buffer. This buffer must be WORD (4 byte) aligned.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>byteCount</em>&nbsp;</td><td>Transfer length.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>callback</em>&nbsp;</td><td>Function to be called on transfer completion. Supply NULL if no callback is needed. See <a class="el" href="group__USB__COMMON.html#ga521fe3060be2a8de6fdd5ee01193958b">USB_XferCompleteCb_TypeDef</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="group__USB__COMMON.html#gga889b575b566a663621c33eebf46272c1a7fc3604700f290c08102ab7a60dbeac2">USB_STATUS_OK</a> on success, else an appropriate error code. </dd></dl>

<p>Definition at line <a class="el" href="em__usbd_8c_source.html#l00820">820</a> of file <a class="el" href="em__usbd_8c_source.html">em_usbd.c</a>.</p>

<p>References <a class="el" href="em__usb_8h_source.html#l00328">USB_STATUS_DEVICE_UNCONFIGURED</a>, <a class="el" href="em__usb_8h_source.html#l00321">USB_STATUS_EP_BUSY</a>, <a class="el" href="em__usb_8h_source.html#l00324">USB_STATUS_EP_STALLED</a>, <a class="el" href="em__usb_8h_source.html#l00323">USB_STATUS_ILLEGAL</a>, <a class="el" href="em__usb_8h_source.html#l00319">USB_STATUS_OK</a>, <a class="el" href="em__usbd_8c_source.html#l00179">USBD_GetUsbState()</a>, and <a class="el" href="em__usb_8h_source.html#l00363">USBD_STATE_CONFIGURED</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<div class="center"><img src="group__USB__DEVICE_ga656c8d2935af97156bc0babdc43c32ee_cgraph.png" border="0" usemap="#group__USB__DEVICE_ga656c8d2935af97156bc0babdc43c32ee_cgraph_map" alt=""></div>
<map name="group__USB__DEVICE_ga656c8d2935af97156bc0babdc43c32ee_cgraph_map" id="group__USB__DEVICE_ga656c8d2935af97156bc0babdc43c32ee_cgraph">
<area shape="rect" id="node2" href="group__USB__DEVICE.html#gab4e55bb0aacaa90aab28a79e9b131b0f" title="Get current USB device state." alt="" coords="153,5,295,32"/></map>
</div>
</p>

</div>
</div>
</div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Thu Sep 10 08:16:16 2015</small> for Silicon Labs EZR32 USB Stack by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
