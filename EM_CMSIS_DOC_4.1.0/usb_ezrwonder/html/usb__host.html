<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs EZR32 USB Stack: USB host stack library</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="usb_host">USB host stack library </a></h1><p>The source files for the USB host stack resides in the usb directory and follows the naming convention: em_usbh<em>nnn</em>.c/h.</p>
<ul>
<li><a class="el" href="usb__host.html#usb_host_intro">Introduction</a> </li>
<li><a class="el" href="usb__host.html#usb_host_getting_started">Getting started</a> </li>
<li><a class="el" href="usb__host.html#usb_host_api">The host stack API</a> </li>
<li><a class="el" href="usb__host.html#usb_host_conf">Configuring the host stack</a></li>
</ul>
<p><br/>
 </p>
<h2><a class="anchor" id="usb_host_intro">
Introduction</a></h2>
<p>The USB host protocol stack provides an API which makes it possible to create USB hosts with a minimum of effort. The host stack supports control, bulk and interrupt transfers.</p>
<p>The stack is highly configurable to suit various needs, it does also contain useful debugging features together with several demonstration projects to get you started fast.</p>
<p>We recommend that you read through this documentation, then proceed to build and test a few example projects before you start designing your own USB host applications.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="usb_host_getting_started">
Getting started</a></h2>
<p>To use an USB device, its pratical to divide the initial steps needed into : </p>
<ul>
<li><a class="el" href="usb__host.html#usb_device_connection">Device connection</a> </li>
<li><a class="el" href="usb__host.html#usb_device_enumeration">Device enumeration and configuration</a></li>
</ul>
<p><br/>
 </p>
<h3><a class="anchor" id="usb_device_connection">
Device connection</a></h3>
<p>This framework can be used to establish a device connection. </p>
<div class="fragment"><pre class="fragment">

// Initialize USB host stack
USBH_Init( &amp;is );

for (;;)
{
  // Wait for ever on device attachment

  // The second parameter is timeout in seconds, 0 means for ever
  if ( USBH_WaitForDeviceConnectionB( tmpBuf, 0 ) == USB_STATUS_OK )
  {

    // Device is now connected and ready for enumeration !

  }

  // Wait for disconnection
  while ( USBH_DeviceConnected() ){}

  // Disable USB peripheral, power down USB port.
  USBH_Stop();
}</pre></div><p><br/>
 </p>
<h3><a class="anchor" id="usb_device_enumeration">
Device enumeration and configuration</a></h3>
<p>This framework can be used to enumerate and activate the device. </p>
<div class="fragment"><pre class="fragment">

  // Enumerate device, retrieve device and configuration descriptors from device
  USBH_QueryDeviceB( tmpBuf, sizeof( tmpBuf ), USBH_GetPortSpeed() );

  // Qualify the device
  if ( ( USBH_QGetDeviceDescriptor( tmpBuf )-&gt;idVendor  == 0x10C4               ) &amp;&amp;
       ( USBH_QGetDeviceDescriptor( tmpBuf )-&gt;idProduct == 0x0001               ) &amp;&amp;
       ( USBH_QGetDeviceDescriptor( tmpBuf )-&gt;bNumConfigurations == 1           ) &amp;&amp;
       ( USBH_QGetConfigurationDescriptor( tmpBuf, 0 )-&gt;bNumInterfaces  == 1    ) &amp;&amp;
       ( USBH_QGetInterfaceDescriptor(  tmpBuf, 0, 0 )-&gt;bInterfaceClass == 0xFF ) &amp;&amp;
       ( USBH_QGetInterfaceDescriptor(  tmpBuf, 0, 0 )-&gt;bNumEndpoints   == 2    )    )
  {
    // After having determined that the device is "our" device, it's time to
    // give it an USB address and activate the configuration.

    // Populate device and endpoint data structures with
    // data retrieved during enumeration.
    USBH_InitDeviceData( &amp;device, tmpBuf, ep, 2, USBH_GetPortSpeed() );

    USBH_SetAddressB( &amp;device, DEV_ADDR );
    USBH_SetConfigurationB( &amp;device, device.confDesc.bConfigurationValue );

    // Assign host channels to device endpoints
    USBH_AssignHostChannel( &amp;ep[ 0 ], 2 );
    USBH_AssignHostChannel( &amp;ep[ 1 ], 3 );

    // We are now ready to use the device !

  }</pre></div><p><br/>
 </p>
<h2><a class="anchor" id="usb_host_api">
The host stack API</a></h2>
<ul>
<li><a class="el" href="usb__host.html#usb_host_apiintro">Introduction</a> </li>
<li><a class="el" href="usb__host.html#usb_host_init">Top level control functions</a> </li>
<li><a class="el" href="usb__host.html#usb_host_transfer">USB transfer functions</a> </li>
<li><a class="el" href="usb__host.html#usb_host_ch9">USB Chapter 9 support functions</a> </li>
<li><a class="el" href="usb__host.html#usb_host_port">Host port control functions</a> </li>
<li><a class="el" href="usb__host.html#usb_host_enum">Enumeration and query functions</a> </li>
<li><a class="el" href="usb__host.html#usb_host_print">Utility functions</a></li>
</ul>
<p><br/>
 </p>
<h3><a class="anchor" id="usb_host_apiintro">
Introduction</a></h3>
<p>This section contains brief descriptions of all functions in the API. You will find detailed information on input and output parameters and return values by clicking on the hyperlinked function names. It is also a good idea to study the code in the USB demonstration projects.</p>
<p>Your application code must include one header file: <em><a class="el" href="em__usb_8h.html" title="USB protocol stack library API for EFM32/EZR32.">em_usb.h</a></em>.</p>
<p>The functions in the API come in two flavours, they are either blocking or non-blocking. The blocking functions have an uppercase letter B at the end of the function name. Blocking functions can not be called when interrupts are disabled. Note that all API callback functions are called from within the USB peripheral interrupt handler with interrupts disabled.</p>
<p>The USB stack use a hardware timer to keep track of time. TIMER0 is the default choice, refer to <a class="el" href="usb__host.html#usb_host_conf">Configuring the host stack</a> for other possibilities. Your application must not use the selected timer.</p>
<p><b>Pitfalls:</b><br/>
 An USB peripheral will fill host receive buffers in quantities of WORD's (4 bytes). When allocating storage for receive buffers, round size up to next WORD boundary. If it is possible that a device will send more data than host expects, round buffer size up to the next multiple of maxpacket size for the relevant endpoint to avoid buffer overflow. <br/>
 Transmit and receive buffers must also be WORD aligned. Macros are available for allocating buffers, see <a class="el" href="group__USB__COMMON.html#ga6ebfcb1d36f8b5b124f2e3ec032a410c">UBUF</a> and <a class="el" href="group__USB__COMMON.html#gaa057d31fe63604d11d6cec2b2b75e30c">STATIC_UBUF</a>.</p>
<p>Transmit buffers passed to non-blocking transfer functions must be statically allocated because these functions do not have their own buffers. The data in the transmit buffers must be valid until the transfer completes, times out or fails.</p>
<p><br/>
 </p>
<h3><a class="anchor" id="usb_host_init">
Top level control functions</a></h3>
<p><a class="el" href="group__USB__HOST.html#gaedb37814762148d4977bd0dbc1a9b46e">USBH_Init()</a> <br/>
 Initial host stack initialization, call once in start of main().</p>
<p><a class="el" href="group__USB__HOST.html#ga154c6b268f2d39d4e1577f917e0da239">USBH_Stop()</a> <br/>
 Terminates host operation, turns off VBUS.</p>
<p><a class="el" href="group__USB__HOST.html#ga62f99f2ed786c98d00935fc2fd140aaf">USBH_WaitForDeviceConnectionB()</a> <br/>
 Wait for device connection with optional timeout.</p>
<p><a class="el" href="group__USB__HOST.html#ga06f1146ad72c09a1ed1d9a9c4b98edb2">USBH_AssignHostChannel()</a> <br/>
 Associate a device endpoint with a host channel.</p>
<p><br/>
 </p>
<h3><a class="anchor" id="usb_host_transfer">
USB transfer functions</a></h3>
<p><a class="el" href="group__USB__HOST.html#ga0b43c59fc9d3c91d0039f761ef4d6333">USBH_ControlMsg()</a>, <a class="el" href="group__USB__HOST.html#gad94fe14defe6b7e33472364c65f07f17">USBH_ControlMsgB()</a> <br/>
 Perform a non-blocking or blocking USB control message transfer.</p>
<p><a class="el" href="group__USB__HOST.html#ga3514adea6bc6da41b8a083153e3f9365">USBH_Read()</a>, <a class="el" href="group__USB__HOST.html#gab5829c1ebeed8cfd36317dd57c6584c9">USBH_ReadB()</a> <br/>
 Perform a non-blocking or blocking USB IN data transfer. Data direction is <em>from</em> device <em>to</em> host.</p>
<p><a class="el" href="group__USB__HOST.html#ga0c9fcc6a9f2db01206c010330b6e41f6">USBH_Write()</a>, <a class="el" href="group__USB__HOST.html#ga27c7b3b7944f7f1b8e4327dd66fa7ff8">USBH_WriteB()</a> <br/>
 Perform a non-blocking or blocking USB OUT data transfer. Data direction is <em>from</em> host <em>to</em> device.</p>
<p><br/>
 </p>
<h3><a class="anchor" id="usb_host_ch9">
USB Chapter 9 support functions</a></h3>
<p>All Chapter 9 support functions are blocking with a timeout of 1 second.</p>
<p><a class="el" href="group__USB__HOST.html#gad09af4f14c4b205a9e159cb4c5fa7b8f">USBH_GetConfigurationDescriptorB()</a> <br/>
 Read a configuration descriptor from a device.</p>
<p><a class="el" href="group__USB__HOST.html#ga2656404a391e6894b03dde7d42d11f4f">USBH_GetDeviceDescriptorB()</a> <br/>
 Read a device descriptor from a device.</p>
<p><a class="el" href="group__USB__HOST.html#ga4e40f21d20e36116da7a45f4a8b7ee3c">USBH_GetStringB()</a> <br/>
 Read a string descriptor from a device.</p>
<p><a class="el" href="group__USB__HOST.html#gac93ecf15f240abf7093506c8e8ef9e61">USBH_SetAddressB()</a> <br/>
 Set new USB device address on device currently on USB address 0.</p>
<p><a class="el" href="group__USB__HOST.html#ga0f156ce4b8660203cf4957c019064d9f">USBH_SetAltInterfaceB()</a> <br/>
 Set alternate interface on a device.</p>
<p><a class="el" href="group__USB__HOST.html#ga6938e5856e9d28116922070621be36a5">USBH_SetConfigurationB()</a> <br/>
 Set device configuration.</p>
<p><a class="el" href="group__USB__HOST.html#ga547d9df531d791c90fd6f44d28e7089a">USBH_StallEpB()</a>, <a class="el" href="group__USB__HOST.html#gabf8fcc4a69080f3d1005d1bc21d44218">USBH_UnStallEpB()</a> <br/>
 These functions stalls or un-stalls an endpoint. Uses USB standard requests SET_FEATURE and CLEAR_FEATURE.</p>
<p><br/>
 </p>
<h3><a class="anchor" id="usb_host_port">
Host port control functions</a></h3>
<p><a class="el" href="group__USB__HOST.html#gaf791f134a36bb5376abaf59c45b84e84">USBH_DeviceConnected()</a> <br/>
 Check if a device is connected on the USB host port.</p>
<p><a class="el" href="group__USB__HOST.html#gad011363a4aa7f78c702a361bcebe67fb">USBH_GetPortSpeed()</a> <br/>
 Get the bus speed (low speed or full speed) of the device currently connected to the USB host port.</p>
<p><a class="el" href="group__USB__HOST.html#gac57479eb6271bc262a6652b50fd122ce">USBH_PortReset()</a> <br/>
 Drive reset signalling on the USB host port.</p>
<p><a class="el" href="group__USB__HOST.html#gaa2cb3b486c0d628c23cce6a26984580b">USBH_PortResume()</a> <br/>
 Drive resume signalling on the USB host port.</p>
<p><a class="el" href="group__USB__HOST.html#ga3b518bcdfa5c19f42a362736767f273c">USBH_PortSuspend()</a> <br/>
 Set the USB host port in suspend mode.</p>
<p><br/>
 </p>
<h3><a class="anchor" id="usb_host_enum">
Enumeration and query functions</a></h3>
<p><a class="el" href="group__USB__HOST.html#gae9ef72709bb00accb740a0350f79fe35">USBH_QueryDeviceB()</a> <br/>
 This function will read the device and configuration descriptors from a device at USB address 0. The application must allocate a buffer of sufficent size to hold the data. This data buffer can later be used by all USBH_Q<em>xxx</em> functions to retrieve pointers to any descriptor within any configuration descriptor. Data retrieved by this function must also be passed to  USBH_InitDeviceData()
         before normal device communication can start. Ref. section <a class="el" href="usb__host.html#usb_device_enumeration">Device enumeration and configuration</a>.</p>
<p><a class="el" href="group__USB__HOST.html#ga2ac91d938f8553e31913afdb8d8d80dc">USBH_QGetConfigurationDescriptor()</a> <br/>
 Get a pointer to a given configuration descriptor. Parses through a data buffer which must have been previously populated by a call to  USBH_QueryDeviceB() .</p>
<p><a class="el" href="group__USB__HOST.html#ga4d6a8d78ebde4e394bb25aa62a871b30">USBH_QGetDeviceDescriptor()</a> <br/>
 Get a pointer to the device descriptor. Parses through a data buffer which must have been previously populated by a call to  
        USBH_QueryDeviceB() .</p>
<p><a class="el" href="group__USB__HOST.html#ga10e6eb1a2e9802af4ec16254e3d44783">USBH_QGetEndpointDescriptor()</a> <br/>
 Get a pointer to a given endpoint descriptor within a given interface within a given configuration. Parses through a data buffer which must have been previously populated by a call to  USBH_QueryDeviceB().
        <p><a class="el" href="group__USB__HOST.html#gabd04b4b1ea26459d6db42aa77b6d592d">USBH_QGetInterfaceDescriptor()</a> <br/>
 Get a pointer to an interface descriptor within a given configuration. Parses through a data buffer which must have been previously populated by a call to  USBH_QueryDeviceB() .</p>
<p><a class="el" href="group__USB__HOST.html#ga50dc10ac598c6c8479319ff58c186266">USBH_InitDeviceData()</a> <br/>
 Populates device and endpoint data structures with data which must have been retrieved from a device by a call to  USBH_QueryDeviceB() . The application must allocate and provide device and endpoint data structures to the host stack. After this function is called the device and endpoint data structures can be used as parameters (<em>handles</em>) to other API functions as needed.</p>
<p><br/>
 </p>
<h3><a class="anchor" id="usb_host_print">
Utility functions</a></h3>
<p><a class="el" href="group__USB__HOST.html#ga60806aa452e18cee2002a2a5de015982">USBH_PrintString()</a> <br/>
 Print an USB string descriptor on the debug serial port with optional leader and trailer strings.</p>
<p><a class="el" href="group__USB__HOST.html#gab7a5bb1a4f4cae3b9cc0556b98d3a4d9">USBH_PrintConfigurationDescriptor()</a>, <a class="el" href="group__USB__HOST.html#ga465475632c744fb3fae7a73e09606fb3">USBH_PrintDeviceDescriptor()</a>, <a class="el" href="group__USB__HOST.html#gabe253e3e072d805774b8714aacf9182c">USBH_PrintEndpointDescriptor()</a>, <a class="el" href="group__USB__HOST.html#ga7a4aa696c25dfd0b99a2cda6e02d7a36">USBH_PrintInterfaceDescriptor()</a> <br/>
 Pretty print descriptors on the debug serial port.</p>
<p><a class="el" href="group__USB__COMMON.html#gac49ccf1d69a08567d1a5911b0312e735" title="Transmit a single char on the debug serial port.">USB_PUTCHAR()</a> <br/>
 Transmit a single char on the debug serial port.</p>
<p><a class="el" href="group__USB__COMMON.html#ga7276e056a2f6aeb99240f72529f41f8f" title="Transmit a zero terminated string on the debug serial port.">USB_PUTS()</a> <br/>
 Transmit a zero terminated string on the debug serial port.</p>
<p><a class="el" href="group__USB__COMMON.html#ga43cf32af5653cb2cd27fb6729be245fb" title="Transmit &quot;printf&quot; formated data on the debug serial port.">USB_PRINTF()</a> <br/>
 Transmit "printf" formated data on the debug serial port.</p>
<p><a class="el" href="group__USB__COMMON.html#gaedc267ca571518980b7f7f4392386844" title="Return an error message string for a given error code.">USB_GetErrorMsgString()</a> <br/>
 Return an error message string for a given error code.</p>
<p><a class="el" href="group__USB__COMMON.html#ga543c505ec86acb344f7f0c00c55fc266" title="Format and print a text string given an error code, prepends an optional user supplied...">USB_PrintErrorMsgString()</a> <br/>
 Format and print a text string given an error code, prepends an optional user supplied leader string.</p>
<p><a class="el" href="group__USB__COMMON.html#gabb1c11cad365c7c3b99a3e7826035951" title="Active wait millisecond delay function.">USBTIMER_DelayMs()</a> <br/>
 Active wait millisecond delay function. Can also be used inside interrupt handlers.</p>
<p><a class="el" href="group__USB__COMMON.html#gafef1ec052374683fb7f26c5d27645e2c" title="Active wait microsecond delay function.">USBTIMER_DelayUs()</a> <br/>
 Active wait microsecond delay function. Can also be used inside interrupt handlers.</p>
<p><a class="el" href="group__USB__COMMON.html#ga21c87b800d87fd731173dd4f48f23c28" title="Activate the hardware timer used to pace the 1 millisecond timer system.">USBTIMER_Init()</a> <br/>
 Initialize the timer system. Called by  
      USBH_Init(),  but your application must call it again to reinitialize whenever you change the HFPERCLK frequency.</p>
<p><a class="el" href="group__USB__COMMON.html#gac2a406f16d989b04c4fc5b37d5c10b45" title="Start a timer.">USBTIMER_Start()</a> <br/>
 Start a timer. You can configure the USB device stack to provide any number of timers. The timers have 1 ms resolution, your application is notified of timeout by means of a callback.</p>
<p><a class="el" href="group__USB__COMMON.html#gab73c922427cf0d509788a8063451703f" title="Stop a timer.">USBTIMER_Stop()</a> <br/>
 Stop a timer.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="usb_host_conf">
Configuring the host stack</a></h2>
<p>Your application must provide a header file named <em>usbconfig.h</em>. This file must contain the following #define's:<br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
#define USB_HOST         // Compile the stack for host mode.
#define NUM_HC_USED n    // Your application use 'n' host channels in addition
                         // to channels 0 and 1 which are assigned by the
                         // host stack for device endpoint 0 communication. </pre></div><p><br/>
 <em>usbconfig.h</em> may define the following items: <br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
#define NUM_APP_TIMERS n // Your application needs 'n' timers

#define DEBUG_USB_API    // Turn on API debug diagnostics.

// Some utility functions in the API needs printf. These
// functions have "print" in their name. This macro enables
// these functions.
#define USB_USE_PRINTF   // Enable utility print functions.

// Define a function for transmitting a single char on the serial port.
extern int RETARGET_WriteChar(char c);
#define USER_PUTCHAR  RETARGET_WriteChar

#define USB_TIMER USB_TIMERn  // Select which hardware timer the USB stack
                              // is allowed to use. Valid values are n=0,1,2...
                              // corresponding to TIMER0, TIMER1, ...
                              // If not specified, TIMER0 is used </pre></div><p><br/>
 You are strongly encouraged to start application development with DEBUG_USB_API turned on. When DEBUG_USB_API is turned on and USER_PUTCHAR is defined, useful debugging information will be output on the development kit serial port. Compiling with the DEBUG_EFM_USER flag will also enable all asserts in both <em>emlib</em> and in the USB stack. If asserts are enabled and USER_PUTCHAR defined, assert texts will be output on the serial port.</p>
<p>You application must include <em>retargetserial.c</em> if DEBUG_USB_API is defined and <em>retargetio.c</em> if USB_USE_PRINTF is defined. These files reside in the <em>drivers</em> directory in the software package for your development board.</p>
<p><br/>
 The host stack can be configured to monitor a GPIO input pin for detection of VBUS overcurrent or short circuit conditions. The stack will by default use pin 2 on PortE and low polarity for this purpose. Override by using the following three #define's: <br/>
 <br/>
 </p>
<div class="fragment"><pre class="fragment">
#define USB_VBUSOVRCUR_PORT       gpioPortB       // The port
#define USB_VBUSOVRCUR_PIN        7               // The pin number within the port
#define USB_VBUSOVRCUR_POLARITY   USB_VBUSOVRCUR_POLARITY_LOW </pre></div><p>Select any GPIO port for <b>USB_VBUSOVRCUR_PORT</b> or <b>USB_VBUSOVRCUR_PORT_NONE</b> if no overcurrent circuitry in the hw design. For <b>USB_VBUSOVRCUR_POLARITY</b> use <b>USB_VBUSOVRCUR_POLARITY_LOW</b> or <b>USB_VBUSOVRCUR_POLARITY_HIGH</b>. </p>
</div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Thu Sep 10 08:16:15 2015</small> for Silicon Labs EZR32 USB Stack by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
