<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs Energy Aware Drivers: SPIDRV Serial Peripheral Interface driver</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="spidrv_doc">SPIDRV Serial Peripheral Interface driver </a></h1><p>The source files for the SPI driver library resides in the emdrv/spidrv folder, and are named <a class="el" href="spidrv_8c.html" title="SPIDRV API implementation.">spidrv.c</a> and <a class="el" href="spidrv_8h.html" title="SPIDRV API definition.">spidrv.h</a>.</p>
<ul>
<li><a class="el" href="spidrv__doc.html#spidrv_intro">Introduction</a> </li>
<li><a class="el" href="spidrv__doc.html#spidrv_conf">Configuration Options</a> </li>
<li><a class="el" href="spidrv__doc.html#spidrv_api">The API</a> </li>
<li><a class="el" href="spidrv__doc.html#spidrv_example">Example</a></li>
</ul>
<p><br/>
 </p>
<h2><a class="anchor" id="spidrv_intro">
Introduction</a></h2>
<p>The SPI driver support the SPI capabilities of EFM32/EZR32/EFR32 USARTs. The driver is fully reentrant and several driver instances can coexist. The driver does not buffer or queue data. The driver has SPI transfer functions for both master and slave SPI mode. Both synchronous and asynchronous transfer functions are present. Synchronous transfer functions are blocking and will not return to caller before the transfer has completed. Asynchronous transfer functions report transfer completion with callback functions. Transfers are done using DMA.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Transfer completion callback functions are called from within the DMA interrupt handler with interrupts disabled.</dd></dl>
<p><br/>
 </p>
<h2><a class="anchor" id="spidrv_conf">
Configuration Options</a></h2>
<p>Some properties of the SPIDRV driver are compile-time configurable. These properties are stored in a file named <a class="el" href="spidrv__config_8h.html">spidrv_config.h</a>. A template for this file, containing default values, resides in the emdrv/config folder. Currently the configuration options are: </p>
<ul>
<li>Inclusion of slave API transfer functions.</li>
</ul>
<p>To configure SPIDRV, provide your own configuration file. Here is a sample <a class="el" href="spidrv__config_8h.html">spidrv_config.h</a> file: </p>
<div class="fragment"><pre class="fragment">
#ifndef __SILICON_LABS_SPIDRV_CONFIG_H__
#define __SILICON_LABS_SPIDRV_CONFIG_H__

// SPIDRV configuration option. Use this define to include the
// slave part of the SPIDRV API.
#define EMDRV_SPIDRV_INCLUDE_SLAVE

#endif
  </pre></div><p>The properties of each SPI driver instance are set at run-time via the <a class="el" href="structSPIDRV__Init__t.html">SPIDRV_Init_t</a> data structure input parameter to the <a class="el" href="group__SPIDRV.html#gae1bf2b297eca13e7e46cbbcb66202239">SPIDRV_Init()</a> function.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="spidrv_api">
The API</a></h2>
<p>This section contain brief descriptions of the functions in the API. You will find detailed information on input and output parameters and return values by clicking on the hyperlinked function names. Most functions return an error code, <a class="el" href="group__SPIDRV.html#ga38b85d953fb373f09638bcf7c44d0967">ECODE_EMDRV_SPIDRV_OK</a> is returned on success, see <a class="el" href="ecode_8h.html">ecode.h</a> and <a class="el" href="spidrv_8h.html">spidrv.h</a> for other error codes.</p>
<p>Your application code must include one header file: <em><a class="el" href="spidrv_8h.html" title="SPIDRV API definition.">spidrv.h</a></em>.</p>
<p><a class="el" href="group__SPIDRV.html#gae1bf2b297eca13e7e46cbbcb66202239">SPIDRV_Init()</a>, <a class="el" href="group__SPIDRV.html#ga1bebced0f8f5b3a3ac582916e4b13460">SPIDRV_DeInit()</a> <br/>
 These functions initializes or deinitializes the SPIDRV driver. Typically  SPIDRV_Init()  is called once in your startup code.</p>
<p><a class="el" href="group__SPIDRV.html#ga7d440db45246649580c6c5b08eb332da">SPIDRV_GetTransferStatus()</a> <br/>
 Query the status of a transfer. Reports number of items (frames) transmitted and remaining.</p>
<p><a class="el" href="group__SPIDRV.html#ga071d128b28b8acff08396fb090b8025a">SPIDRV_AbortTransfer()</a> <br/>
 Stop an ongoing transfer.</p>
<p><a class="el" href="group__SPIDRV.html#ga3e6e2f999eb2ef0fd16df41339e6dc84">SPIDRV_SetBitrate()</a>, <a class="el" href="group__SPIDRV.html#ga9b3613b7cfbd6f3584a957c757934841">SPIDRV_GetBitrate()</a> <br/>
 Set or query SPI bus bitrate.</p>
<p><a class="el" href="group__SPIDRV.html#ga54ce984fad9b30b3e8e860b6ada5b77a">SPIDRV_SetFramelength()</a>, <a class="el" href="group__SPIDRV.html#ga08075cb727e683585eeace6de71fcc80">SPIDRV_GetFramelength()</a> <br/>
 Set or query SPI bus frame length.</p>
<p><a class="el" href="group__SPIDRV.html#ga791215fe6c21c8630d8acd45dd02491c" title="Start a SPI master receive transfer.">SPIDRV_MReceive()</a>, <a class="el" href="group__SPIDRV.html#gace57de2fe713e7eed216c8f4d00e19b8" title="Start a SPI master blocking receive transfer.">SPIDRV_MReceiveB()</a> <br/>
 <a class="el" href="group__SPIDRV.html#ga783d2e10fd457bdb7b214f59238c3deb" title="Start a SPI master transfer.">SPIDRV_MTransfer()</a>, <a class="el" href="group__SPIDRV.html#gac897032e6a00ff40e476f1f3dadc55ba" title="Start a SPI master blocking transfer.">SPIDRV_MTransferB()</a>, <a class="el" href="group__SPIDRV.html#gaea943a66137078855a6511a75fb27437" title="Start a SPI master blocking single item (frame) transfer.">SPIDRV_MTransferSingleItemB()</a> <br/>
 <a class="el" href="group__SPIDRV.html#ga29fb3ab707b29dbb8efaad5523e162b3" title="Start a SPI master transmit transfer.">SPIDRV_MTransmit()</a>, <a class="el" href="group__SPIDRV.html#gaf53f10ccb89d8ae2c5c397db7cb87a9e" title="Start a SPI master blocking transmit transfer.">SPIDRV_MTransmitB()</a> <br/>
 <a class="el" href="group__SPIDRV.html#gaa4a1d07a7cfa1b461231b81ee9bd7208" title="Start a SPI slave receive transfer.">SPIDRV_SReceive()</a>, <a class="el" href="group__SPIDRV.html#gaacf21de6f56b73897137afe66c8a55fc" title="Start a SPI slave blocking receive transfer.">SPIDRV_SReceiveB()</a> <br/>
 <a class="el" href="group__SPIDRV.html#ga3b0e6cefe8389131f8cda2d3422ca165" title="Start a SPI slave transfer.">SPIDRV_STransfer()</a>, <a class="el" href="group__SPIDRV.html#ga2117731649ff7375202f3db7c7eaea14" title="Start a SPI slave blocking transfer.">SPIDRV_STransferB()</a> <br/>
 <a class="el" href="group__SPIDRV.html#gab17e267c072c9fa5424ac0dbb6d162b4" title="Start a SPI slave transmit transfer.">SPIDRV_STransmit()</a>, <a class="el" href="group__SPIDRV.html#ga950e481559e49f805c4c65701f272df5" title="Start a SPI slave blocking transmit transfer.">SPIDRV_STransmitB()</a> <br/>
 SPI transfer functions for SPI masters have an uppercase M in their name, the slave counterparts have an S.</p>
<p>Transfer functions come in both synchronous and asynchronous versions, the synchronous versions have an uppercase B (for Blocking) at the end of their function name. Synchronous functions will not return before the transfer has completed. The aynchronous functions signal transfer completion with a callback function.</p>
<p><em>Transmit</em> functions discards received data, <em>receive</em> functions transmit a fixed data pattern set when the driver is initialized (<a class="el" href="structSPIDRV__Init__t.html#ac0e481f17684b16ae2706fc4f3fd71a6">SPIDRV_Init_t::dummyTxValue</a>). <em>Transfer</em> functions both receive and transmit data.</p>
<p>All slave transfer functions have a millisecond timeout parameter. Use 0 for no (infinite) timeout.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="spidrv_example">
Example</a></h2>
<div class="fragment"><pre class="fragment">
#include "spidrv.h"

SPIDRV_HandleData_t handleData;
SPIDRV_Handle_t handle = &amp;handleData;

void TransferComplete( SPIDRV_Handle_t handle,
                       Ecode_t transferStatus,
                       int itemsTransferred )
{
  if ( transferStatus == ECODE_EMDRV_SPIDRV_OK )
  {
    // Success !
  }
}

int main( void )
{
  uint8_t buffer[10];
  SPIDRV_Init_t initData = SPIDRV_MASTER_USART2;

  // Initialize a SPI driver instance
  SPIDRV_Init( handle, &amp;initData );

  // Transmit data using a blocking transmit function
  SPIDRV_MTransmitB( handle, buffer, 10 );

  // Transmit data using a callback to catch transfer completion.
  SPIDRV_MTransmit( handle, buffer, 10, TransferComplete );
}
  </pre></div> </div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Sep 7 08:55:22 2015</small> for Silicon Labs Energy Aware Drivers by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
