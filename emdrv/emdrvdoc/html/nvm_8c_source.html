<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs Energy Aware Drivers: nvm/src/nvm.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_cab5eac6601b941afe1ff211733eceb1.html">nvm</a>&nbsp;&raquo;&nbsp;<a class="el" href="dir_6ac14e044a974337bc5f7e2cf76ea57f.html">src</a>
  </div>
</div>
<div class="contents">
<h1>nvm.c</h1><a href="nvm_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/***************************************************************************/</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;stdbool.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;<a class="code" href="nvm_8h.html" title="NVM API definition.">nvm.h</a>&quot;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">/*******************************************************************************</span>
<a name="l00020"></a>00020 <span class="comment"> *******************************   DEFINES   ***********************************</span>
<a name="l00021"></a>00021 <span class="comment"> ******************************************************************************/</span>
<a name="l00022"></a>00022 
<a name="l00027"></a>00027 <span class="preprocessor">#define NVM_VERSION                            0x2U</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="comment">/* Sizes. Internal sizes of different objects */</span>
<a name="l00030"></a>00030 <span class="preprocessor">#define NVM_CONTENT_SIZE         (NVM_PAGE_SIZE - (NVM_HEADER_SIZE + NVM_FOOTER_SIZE))</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#define NVM_WEAR_CONTENT_SIZE    (NVM_PAGE_SIZE - NVM_HEADER_SIZE)</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00033"></a>00033 <span class="preprocessor">#define NVM_PAGE_EMPTY_VALUE                   0xffffU</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#define NVM_NO_PAGE_RETURNED                   0xffffffffUL</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="preprocessor">#define NVM_NO_WRITE_16BIT                     0xffffU</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span><span class="preprocessor">#define NVM_NO_WRITE_32BIT                     0xffffffffUL</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define NVM_HIGHEST_32BIT                      0xffffffffUL</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#define NVM_FLIP_FIRST_BIT_OF_32_WHEN_WRITE    0xffff7fffUL</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#define NVM_FIRST_BIT_ONE                      0x8000U</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#define NVM_FIRST_BIT_ZERO                     0x7fffU</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#define NVM_LAST_BIT_ZERO                      0xfffeU</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#define NVM_CHECKSUM_INITIAL                   0xffffU</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#define NVM_CHECKSUM_LENGTH                    0x2U</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <span class="preprocessor">#define NVM_PAGES_PER_WEAR_HISTORY             0x8U</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span>
<a name="l00048"></a>00048 <span class="comment">/* Macros for acquiring and releasing write lock. Currently empty but could be redefined</span>
<a name="l00049"></a>00049 <span class="comment">   in RTOSes to add resources protection. It is not recommended to call the NVM module</span>
<a name="l00050"></a>00050 <span class="comment">   from interrupts or other tasks without ensuring that it is not used by main thread.   */</span>
<a name="l00051"></a>00051 <span class="preprocessor">#ifndef NVM_ACQUIRE_WRITE_LOCK</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define NVM_ACQUIRE_WRITE_LOCK</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span>
<a name="l00055"></a>00055 <span class="preprocessor">#ifndef NVM_RELEASE_WRITE_LOCK</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#define NVM_RELEASE_WRITE_LOCK</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>
<a name="l00061"></a>00061 <span class="comment">/*******************************************************************************</span>
<a name="l00062"></a>00062 <span class="comment"> ******************************   TYPEDEFS   ***********************************</span>
<a name="l00063"></a>00063 <span class="comment"> ******************************************************************************/</span>
<a name="l00064"></a>00064 
<a name="l00067"></a>00067 <span class="keyword">typedef</span> <span class="keyword">enum</span>
<a name="l00068"></a>00068 {
<a name="l00069"></a>00069   nvmValidateResultOk       = 0, 
<a name="l00070"></a>00070   nvmValidateResultOkMarked = 1, 
<a name="l00071"></a>00071   nvmValidateResultOld      = 2, 
<a name="l00072"></a>00072   nvmValidateResultError    = 3  
<a name="l00073"></a>00073 } NVM_ValidateResult_t;
<a name="l00074"></a>00074 
<a name="l00077"></a>00077 <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00078"></a>00078 {
<a name="l00079"></a>00079   uint16_t watermark; 
<a name="l00080"></a>00080   uint32_t updateId;  
<a name="l00081"></a>00081   uint16_t version;   
<a name="l00082"></a>00082 } NVM_Page_Header_t;
<a name="l00083"></a>00083 
<a name="l00085"></a>00085 <span class="preprocessor">#define NVM_HEADER_SIZE          (2 * sizeof(uint16_t) + sizeof(uint32_t))</span>
<a name="l00086"></a>00086 <span class="preprocessor"></span>
<a name="l00089"></a>00089 <span class="keyword">typedef</span> <span class="keyword">struct</span>
<a name="l00090"></a>00090 {
<a name="l00091"></a>00091   uint16_t checksum;  
<a name="l00092"></a>00092   uint16_t watermark; 
<a name="l00093"></a>00093 } NVM_Page_Footer_t;
<a name="l00094"></a>00094 
<a name="l00096"></a>00096 <span class="preprocessor">#define NVM_FOOTER_SIZE          (2 * sizeof(uint16_t))</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span>
<a name="l00100"></a>00100 <span class="comment">/*******************************************************************************</span>
<a name="l00101"></a>00101 <span class="comment"> *******************************   STATICS   ***********************************</span>
<a name="l00102"></a>00102 <span class="comment"> ******************************************************************************/</span>
<a name="l00103"></a>00103 
<a name="l00107"></a>00107 <span class="keyword">static</span> <a class="code" href="structNVM__Config__t.html" title="Configuration structure.">NVM_Config_t</a> <span class="keyword">const</span> *<a class="code" href="nvm__config_8c.html#a24533bdf8b11e45c64b9425baeb40c71" title="Top-level configuration data.">nvmConfig</a>;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="preprocessor">#if (NVM_FEATURE_STATIC_WEAR_ENABLED == true)</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="comment">/* Static wear leveling */</span>
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="comment">/* Bit list that records which pages have been rewritten.</span>
<a name="l00113"></a>00113 <span class="comment"> * The array contains number of pages divided by 8 bits in a byte. */</span>
<a name="l00114"></a>00114 <span class="keyword">static</span> uint8_t nvmStaticWearWriteHistory[(<a class="code" href="group__NVM.html#ga9fc5731ea0401c43f6c6b52ebd029b1e" title="define maximum number of flash pages that can be used as NVM">NVM_MAX_NUMBER_OF_PAGES</a> + (NVM_PAGES_PER_WEAR_HISTORY - 1)) / NVM_PAGES_PER_WEAR_HISTORY];
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="comment">/* Number of different page writes recorded in history. */</span>
<a name="l00117"></a>00117 <span class="keyword">static</span> uint16_t nvmStaticWearWritesInHistory;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="comment">/* Number of page erases performed since last rest. */</span>
<a name="l00120"></a>00120 <span class="keyword">static</span> uint16_t nvmStaticWearErasesSinceReset;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="comment">/* Stop recurring calls from causing mayhem. */</span>
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keywordtype">bool</span> nvmStaticWearWorking = <span class="keyword">false</span>;
<a name="l00124"></a>00124 <span class="preprocessor">#endif</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span>
<a name="l00128"></a>00128 <span class="comment">/*******************************************************************************</span>
<a name="l00129"></a>00129 <span class="comment"> ******************************   PROTOTYPES   *********************************</span>
<a name="l00130"></a>00130 <span class="comment"> ******************************************************************************/</span>
<a name="l00131"></a>00131 
<a name="l00134"></a>00134 <span class="keyword">static</span> uint8_t* NVM_PageFind(uint16_t pageId);
<a name="l00135"></a>00135 <span class="keyword">static</span> uint8_t* NVM_ScratchPageFindBest(<span class="keywordtype">void</span>);
<a name="l00136"></a>00136 <span class="keyword">static</span> <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> NVM_PageErase(uint8_t *pPhysicalAddress);
<a name="l00137"></a>00137 <span class="keyword">static</span> <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> NVM_PageGet(uint16_t pageId);
<a name="l00138"></a>00138 <span class="keyword">static</span> NVM_ValidateResult_t NVM_PageValidate(uint8_t *pPhysicalAddress);
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span><span class="keyword">static</span> uint16_t NVM_WearIndex(uint8_t *pPhysicalAddress, <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> *pPageDesc);
<a name="l00142"></a>00142 <span class="keyword">static</span> <span class="keywordtype">bool</span> NVM_WearReadIndex(uint8_t *pPhysicalAddress, <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> *pPageDesc, uint16_t *pIndex);
<a name="l00143"></a>00143 <span class="preprocessor">#endif</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>
<a name="l00145"></a>00145 <span class="keyword">static</span> <span class="keywordtype">void</span> NVM_ChecksumAdditive(uint16_t *pChecksum, <span class="keywordtype">void</span> *pBuffer, uint16_t len);
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="preprocessor">#if (NVM_FEATURE_STATIC_WEAR_ENABLED == true)</span>
<a name="l00148"></a>00148 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">void</span> NVM_StaticWearReset(<span class="keywordtype">void</span>);
<a name="l00149"></a>00149 <span class="keyword">static</span> <span class="keywordtype">void</span> NVM_StaticWearUpdate(uint16_t address);
<a name="l00150"></a>00150 <span class="keyword">static</span> <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> NVM_StaticWearCheck(<span class="keywordtype">void</span>);
<a name="l00151"></a>00151 <span class="preprocessor">#endif</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span>
<a name="l00154"></a>00154 <span class="comment">/*******************************************************************************</span>
<a name="l00155"></a>00155 <span class="comment"> ***************************   GLOBAL FUNCTIONS   ******************************</span>
<a name="l00156"></a>00156 <span class="comment"> ******************************************************************************/</span>
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="comment">/***************************************************************************/</span>
<a name="l00184"></a><a class="code" href="group__NVM.html#gaf74bb05f10ed4959e65e85fa438ead67">00184</a> <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> <a class="code" href="group__NVM.html#gaf74bb05f10ed4959e65e85fa438ead67" title="Initialize the NVM manager.">NVM_Init</a>(<a class="code" href="structNVM__Config__t.html" title="Configuration structure.">NVM_Config_t</a> <span class="keyword">const</span> *config)
<a name="l00185"></a>00185 {
<a name="l00186"></a>00186   uint16_t page;
<a name="l00187"></a>00187   <span class="comment">/* Variable to store the result returned at the end. */</span>
<a name="l00188"></a>00188   <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> result = <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>;
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="comment">/* Physical address of the current page. */</span>
<a name="l00191"></a>00191   uint8_t *pPhysicalAddress = (uint8_t *)(config-&gt;<a class="code" href="structNVM__Config__t.html#a3096ad0ec94fcc2df81e891908027ddc" title="Pointer to nvm area in flash.">nvmArea</a>);
<a name="l00192"></a>00192   <span class="comment">/* Physical address of a suspected duplicate page under observation. */</span>
<a name="l00193"></a>00193   uint8_t *pDuplicatePhysicalAddress;
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   <span class="comment">/* Logical address of the current page. */</span>
<a name="l00196"></a>00196   uint16_t logicalAddress;
<a name="l00197"></a>00197   <span class="comment">/* Logical address of a duplicate page. */</span>
<a name="l00198"></a>00198   uint16_t duplicateLogicalAddress;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200   <span class="comment">/* Temporary variable to store results of a validation operation. */</span>
<a name="l00201"></a>00201   NVM_ValidateResult_t validationResult;
<a name="l00202"></a>00202   <span class="comment">/* Temporary variable to store results of a erase operation. */</span>
<a name="l00203"></a>00203   <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> eraseResult;
<a name="l00204"></a>00204 
<a name="l00205"></a>00205   <span class="comment">/* if there is no spare page, return error */</span>
<a name="l00206"></a>00206   <span class="keywordflow">if</span>( (config-&gt;<a class="code" href="structNVM__Config__t.html#a29a3ddbe19f1c8535a07d94ca028f39c" title="Total number of physical pages.">pages</a> &lt;= config-&gt;<a class="code" href="structNVM__Config__t.html#a59511e0aadcd44292a5fc52c6020c391" title="Number of defined (used) pages.">userPages</a>) || (config-&gt;<a class="code" href="structNVM__Config__t.html#a29a3ddbe19f1c8535a07d94ca028f39c" title="Total number of physical pages.">pages</a> &gt; <a class="code" href="group__NVM.html#ga9fc5731ea0401c43f6c6b52ebd029b1e" title="define maximum number of flash pages that can be used as NVM">NVM_MAX_NUMBER_OF_PAGES</a>) )
<a name="l00207"></a>00207     <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209   <span class="comment">/* now check that page structures fits to physical page size */</span>
<a name="l00210"></a>00210   {
<a name="l00211"></a>00211     uint16_t pageIdx = 0, obj = 0, sum = 0;
<a name="l00212"></a>00212     <span class="keyword">const</span> <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> *currentPage;
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     <span class="keywordflow">for</span>(pageIdx = 0; pageIdx &lt; config-&gt;<a class="code" href="structNVM__Config__t.html#a59511e0aadcd44292a5fc52c6020c391" title="Number of defined (used) pages.">userPages</a>; pageIdx++)
<a name="l00215"></a>00215     {
<a name="l00216"></a>00216       sum = 0;
<a name="l00217"></a>00217       obj = 0;
<a name="l00218"></a>00218       currentPage = &amp;((*(config-&gt;<a class="code" href="structNVM__Config__t.html#aa6a79150e4b1db9181a2f5fc2534038d" title="Pointer to table defining NVM pages.">nvmPages</a>))[pageIdx]);
<a name="l00219"></a>00219 
<a name="l00220"></a>00220       <span class="keywordflow">while</span>( (*(currentPage-&gt;<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>))[obj].location != 0)
<a name="l00221"></a>00221         sum += (*(currentPage-&gt;<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>))[obj++].size;
<a name="l00222"></a>00222 
<a name="l00223"></a>00223       <span class="keywordflow">if</span>(currentPage-&gt;<a class="code" href="structNVM__Page__Descriptor__t.html#abc9be6e483194ebbb8846c864729b71c" title="The type of page, normal or wear.">pageType</a> == <a class="code" href="group__NVM.html#ggae2a292fc163eaa08574b4c061c0b1ecaa2e7a6f6ed6a5752e4c4148104af077cd" title="Normal page, always rewrite.">nvmPageTypeNormal</a>)
<a name="l00224"></a>00224       {
<a name="l00225"></a>00225         <span class="keywordflow">if</span>( sum &gt; NVM_CONTENT_SIZE )
<a name="l00226"></a>00226         {
<a name="l00227"></a>00227           <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>; <span class="comment">/* objects bigger than page size */</span>
<a name="l00228"></a>00228         }
<a name="l00229"></a>00229       }
<a name="l00230"></a>00230       <span class="keywordflow">else</span>
<a name="l00231"></a>00231       {
<a name="l00232"></a>00232         <span class="keywordflow">if</span>(currentPage-&gt;<a class="code" href="structNVM__Page__Descriptor__t.html#abc9be6e483194ebbb8846c864729b71c" title="The type of page, normal or wear.">pageType</a> == <a class="code" href="group__NVM.html#ggae2a292fc163eaa08574b4c061c0b1ecaa81f13288c7f3413c4dc96832d7c11117" title="Wear page.">nvmPageTypeWear</a>)
<a name="l00233"></a>00233         {
<a name="l00234"></a>00234           <span class="keywordflow">if</span>( (sum+NVM_CHECKSUM_LENGTH) &gt; NVM_WEAR_CONTENT_SIZE )
<a name="l00235"></a>00235           {
<a name="l00236"></a>00236             <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>; <span class="comment">/* objects bigger than page size */</span>
<a name="l00237"></a>00237           }
<a name="l00238"></a>00238         } <span class="keywordflow">else</span>
<a name="l00239"></a>00239           {
<a name="l00240"></a>00240             <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>; <span class="comment">/* unknown page type */</span>
<a name="l00241"></a>00241           }
<a name="l00242"></a>00242       }
<a name="l00243"></a>00243     }
<a name="l00244"></a>00244   }
<a name="l00245"></a>00245 
<a name="l00246"></a>00246   nvmConfig = config;
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   <span class="comment">/* Require write lock to continue. */</span>
<a name="l00249"></a>00249   NVM_ACQUIRE_WRITE_LOCK
<a name="l00250"></a>00250 
<a name="l00251"></a>00251   <span class="comment">/* Initialize the NVM. */</span>
<a name="l00252"></a>00252   <a class="code" href="nvm__hal_8h.html#ae2c572327803a74275c5877bc496bbcc" title="Use energy saving version of format function.">NVMHAL_Init</a>();
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="preprocessor">#if (NVM_FEATURE_STATIC_WEAR_ENABLED == true)</span>
<a name="l00255"></a>00255 <span class="preprocessor"></span>  <span class="comment">/* Initialize the static wear leveling functionality. */</span>
<a name="l00256"></a>00256   NVM_StaticWearReset();
<a name="l00257"></a>00257 <span class="preprocessor">#endif</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span>
<a name="l00259"></a>00259   <span class="comment">/* Run through all pages and see if they validate if they contain content. */</span>
<a name="l00260"></a>00260   <span class="keywordflow">for</span> (page = 0; page &lt; nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a29a3ddbe19f1c8535a07d94ca028f39c" title="Total number of physical pages.">pages</a>; ++page)
<a name="l00261"></a>00261   {
<a name="l00262"></a>00262     <span class="comment">/* Read the logical address of the page stored at the current physical</span>
<a name="l00263"></a>00263 <span class="comment">     * address, and compare it to the value of an empty page. */</span>
<a name="l00264"></a>00264     <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress, &amp;logicalAddress, <span class="keyword">sizeof</span>(logicalAddress));
<a name="l00265"></a>00265     <span class="keywordflow">if</span> (NVM_PAGE_EMPTY_VALUE != logicalAddress)
<a name="l00266"></a>00266     {
<a name="l00267"></a>00267       <span class="comment">/* Not an empty page. Check if it validates. */</span>
<a name="l00268"></a>00268       validationResult = NVM_PageValidate(pPhysicalAddress);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270       <span class="comment">/* Three different kinds of pages. */</span>
<a name="l00271"></a>00271       <span class="keywordflow">if</span> (nvmValidateResultOk == validationResult)
<a name="l00272"></a>00272       {
<a name="l00273"></a>00273         <span class="comment">/* We have found a valid page, so the initial error can be changed to an</span>
<a name="l00274"></a>00274 <span class="comment">         * OK result. */</span>
<a name="l00275"></a>00275         <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a> == result)
<a name="l00276"></a>00276         {
<a name="l00277"></a>00277           result = <a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a>;
<a name="l00278"></a>00278         }
<a name="l00279"></a>00279       }
<a name="l00280"></a>00280       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (nvmValidateResultOkMarked == validationResult)
<a name="l00281"></a>00281       {
<a name="l00282"></a>00282         <span class="comment">/* Page validates, but is marked for write.</span>
<a name="l00283"></a>00283 <span class="comment">         * There might exist a newer version. */</span>
<a name="l00284"></a>00284 
<a name="l00285"></a>00285         <span class="comment">/* Walk through all the possible pages looking for a page with</span>
<a name="l00286"></a>00286 <span class="comment">         * matching watermark. */</span>
<a name="l00287"></a>00287         pDuplicatePhysicalAddress = (uint8_t *)(nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a3096ad0ec94fcc2df81e891908027ddc" title="Pointer to nvm area in flash.">nvmArea</a>);
<a name="l00288"></a>00288         <span class="keywordflow">for</span> (page = 0; (NVM_PAGE_EMPTY_VALUE != logicalAddress) &amp;&amp; (page &lt; nvmConfig-&gt;pages);
<a name="l00289"></a>00289              ++page)
<a name="l00290"></a>00290         {
<a name="l00291"></a>00291           <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pDuplicatePhysicalAddress, &amp;duplicateLogicalAddress, <span class="keyword">sizeof</span>(duplicateLogicalAddress));
<a name="l00292"></a>00292 
<a name="l00293"></a>00293           <span class="keywordflow">if</span> ((pDuplicatePhysicalAddress != pPhysicalAddress) &amp;&amp; ((logicalAddress | NVM_FIRST_BIT_ONE) == duplicateLogicalAddress))
<a name="l00294"></a>00294           {
<a name="l00295"></a>00295             <span class="comment">/* Duplicate page has got the same logical address. Check if it</span>
<a name="l00296"></a>00296 <span class="comment">             * validates. */</span>
<a name="l00297"></a>00297             validationResult = NVM_PageValidate(pDuplicatePhysicalAddress);
<a name="l00298"></a>00298 
<a name="l00299"></a>00299             <span class="keywordflow">if</span> (nvmValidateResultOk == validationResult)
<a name="l00300"></a>00300             {
<a name="l00301"></a>00301               <span class="comment">/* The new one validates, delete the old one. */</span>
<a name="l00302"></a>00302               eraseResult = NVM_PageErase(pPhysicalAddress);
<a name="l00303"></a>00303             }
<a name="l00304"></a>00304             <span class="keywordflow">else</span>
<a name="l00305"></a>00305             {
<a name="l00306"></a>00306               <span class="comment">/* The new one is broken, delete the new one. */</span>
<a name="l00307"></a>00307               eraseResult = NVM_PageErase(pDuplicatePhysicalAddress);
<a name="l00308"></a>00308             }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310             <span class="comment">/* Something went wrong */</span>
<a name="l00311"></a>00311             <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a> != eraseResult)
<a name="l00312"></a>00312             {
<a name="l00313"></a>00313               result = <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>;
<a name="l00314"></a>00314             }
<a name="l00315"></a>00315           }
<a name="l00316"></a>00316 
<a name="l00317"></a>00317           <span class="comment">/* Go to the next physical page. */</span>
<a name="l00318"></a>00318           pDuplicatePhysicalAddress += <a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a>;
<a name="l00319"></a>00319         } <span class="comment">/* End duplicate search loop. */</span>
<a name="l00320"></a>00320 
<a name="l00321"></a>00321         <span class="comment">/* If everything went OK and this is the first page we found, then</span>
<a name="l00322"></a>00322 <span class="comment">         * we can change the status from initial error to OK. */</span>
<a name="l00323"></a>00323         <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a> == result)
<a name="l00324"></a>00324         {
<a name="l00325"></a>00325           result = <a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a>;
<a name="l00326"></a>00326         }
<a name="l00327"></a>00327       }
<a name="l00328"></a>00328       <span class="keywordflow">else</span>
<a name="l00329"></a>00329       {
<a name="l00330"></a>00330         <span class="comment">/* Page does not validate */</span>
<a name="l00331"></a>00331         result = <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>;
<a name="l00332"></a>00332       }
<a name="l00333"></a>00333     } <span class="comment">/* End - not empty if. */</span>
<a name="l00334"></a>00334 
<a name="l00335"></a>00335     <span class="comment">/* Go to the next physical page. */</span>
<a name="l00336"></a>00336     pPhysicalAddress += <a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a>;
<a name="l00337"></a>00337   } <span class="comment">/* End pages loop. */</span>
<a name="l00338"></a>00338 
<a name="l00339"></a>00339   <span class="comment">/* If no pages was found, the system is not in use and should be reset. */</span>
<a name="l00340"></a>00340   <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a> == result)
<a name="l00341"></a>00341   {
<a name="l00342"></a>00342     result = <a class="code" href="group__NVM.html#ga2345b10d783d735ed6be169a918ec991" title="Initialization didn&amp;#39;t find any pages available to allocate.">ECODE_EMDRV_NVM_NO_PAGES_AVAILABLE</a>;
<a name="l00343"></a>00343   }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l00346"></a>00346   NVM_RELEASE_WRITE_LOCK
<a name="l00347"></a>00347 
<a name="l00348"></a>00348   <span class="keywordflow">return</span> result;
<a name="l00349"></a>00349 }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351 <span class="comment">/***************************************************************************/</span>
<a name="l00369"></a><a class="code" href="group__NVM.html#gab056662c41fc69f6b1fe44ee5f94852b">00369</a> <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> <a class="code" href="group__NVM.html#gab056662c41fc69f6b1fe44ee5f94852b" title="Erase the entire allocated NVM area.">NVM_Erase</a>(uint32_t erasureCount)
<a name="l00370"></a>00370 {
<a name="l00371"></a>00371   uint16_t page;
<a name="l00372"></a>00372   <span class="comment">/* Result used when returning from the function. */</span>
<a name="l00373"></a>00373   <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> result = <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="comment">/* Location of physical page. */</span>
<a name="l00376"></a>00376   uint8_t *pPhysicalAddress = (uint8_t *)(nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a3096ad0ec94fcc2df81e891908027ddc" title="Pointer to nvm area in flash.">nvmArea</a>);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378   <span class="comment">/* Container for moving old erasure count, or set to new. */</span>
<a name="l00379"></a>00379   uint32_t tempErasureCount = erasureCount;
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <span class="comment">/* Require write lock to continue. */</span>
<a name="l00382"></a>00382   NVM_ACQUIRE_WRITE_LOCK
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   <span class="comment">/* Loop over all the pages, as long as everything is OK. */</span>
<a name="l00385"></a>00385   <span class="keywordflow">for</span> (page = 0;
<a name="l00386"></a>00386        (page &lt; nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a29a3ddbe19f1c8535a07d94ca028f39c" title="Total number of physical pages.">pages</a>) &amp;&amp; ((<a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a> == result) || (<a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a> == result));
<a name="l00387"></a>00387        ++page)
<a name="l00388"></a>00388   {
<a name="l00389"></a>00389     <span class="comment">/* If erasureCount input is set to the retain constant, we need to get the</span>
<a name="l00390"></a>00390 <span class="comment">     * old erasure count before we erase the page. */</span>
<a name="l00391"></a>00391     <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#gaddbc995da5f67dc3b176213f32008a62" title="Retains the registered erase count when eraseing a page.">NVM_ERASE_RETAINCOUNT</a> == erasureCount)
<a name="l00392"></a>00392     {
<a name="l00393"></a>00393       <span class="comment">/* Read old erasure count. */</span>
<a name="l00394"></a>00394       <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + 2, &amp;tempErasureCount, <span class="keyword">sizeof</span>(tempErasureCount));
<a name="l00395"></a>00395     }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397     <span class="comment">/* Erase page. */</span>
<a name="l00398"></a>00398     result = <a class="code" href="nvm__hal_8h.html#aaa2acd545c460f4cea576178fc185a21" title="Erase a page in the NVM.">NVMHAL_PageErase</a>(pPhysicalAddress);
<a name="l00399"></a>00399 
<a name="l00400"></a>00400     <span class="comment">/* If still OK, write erasure count to page. */</span>
<a name="l00401"></a>00401     <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a> == result)
<a name="l00402"></a>00402     {
<a name="l00403"></a>00403       result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pPhysicalAddress + 2, &amp;tempErasureCount, <span class="keyword">sizeof</span>(tempErasureCount));
<a name="l00404"></a>00404     }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406     <span class="comment">/* Go to the next physical page. */</span>
<a name="l00407"></a>00407     pPhysicalAddress += <a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a>;
<a name="l00408"></a>00408   }
<a name="l00409"></a>00409 
<a name="l00410"></a>00410   <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l00411"></a>00411   NVM_RELEASE_WRITE_LOCK
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="keywordflow">return</span> result;
<a name="l00414"></a>00414 }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 <span class="comment">/***************************************************************************/</span>
<a name="l00441"></a><a class="code" href="group__NVM.html#gad181be9b434658d3552fb311039ff691">00441</a> <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> <a class="code" href="group__NVM.html#gad181be9b434658d3552fb311039ff691" title="Write an object or a page.">NVM_Write</a>(uint16_t pageId, uint8_t objectId)
<a name="l00442"></a>00442 {
<a name="l00443"></a>00443   <span class="comment">/* Result variable used as return value from the function. */</span>
<a name="l00444"></a>00444   <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> result = <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446   <span class="comment">/* Watermark to look for when finding page. First bit true. */</span>
<a name="l00447"></a>00447   uint16_t watermark = pageId | NVM_FIRST_BIT_ONE;
<a name="l00448"></a>00448   <span class="comment">/* Watermark used when flipping the duplication bit of a page. */</span>
<a name="l00449"></a>00449   <span class="keyword">const</span> uint32_t flipWatermark = NVM_FLIP_FIRST_BIT_OF_32_WHEN_WRITE;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451   <span class="comment">/* Page descriptor used for accessing page type and page objects. */</span>
<a name="l00452"></a>00452   <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> pageDesc;
<a name="l00453"></a>00453 
<a name="l00454"></a>00454   <span class="comment">/* Page header and footer. Used to store old version and to easily update and</span>
<a name="l00455"></a>00455 <span class="comment">   * write new version. */</span>
<a name="l00456"></a>00456   NVM_Page_Header_t header;
<a name="l00457"></a>00457 
<a name="l00458"></a>00458   <span class="comment">/* Variable used for checksum calculation. Starts at defined initial value. */</span>
<a name="l00459"></a>00459   uint16_t checksum = NVM_CHECKSUM_INITIAL;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="comment">/* Physical addresses in memory for the old and new version of the page. */</span>
<a name="l00462"></a>00462   uint8_t *pOldPhysicalAddress = (uint8_t *) NVM_NO_PAGE_RETURNED;
<a name="l00463"></a>00463   uint8_t *pNewPhysicalAddress = (uint8_t *) NVM_NO_PAGE_RETURNED;
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <span class="comment">/* Offset address within page. */</span>
<a name="l00466"></a>00466   uint16_t offsetAddress;
<a name="l00467"></a>00467   <span class="comment">/* Single byte buffer used when copying data from an old page.*/</span>
<a name="l00468"></a>00468   uint8_t  copyBuffer;
<a name="l00469"></a>00469   <span class="comment">/* Object in page counter. */</span>
<a name="l00470"></a>00470   uint8_t  objectIndex;
<a name="l00471"></a>00471   <span class="comment">/* Amount of bytes to copy. */</span>
<a name="l00472"></a>00472   uint16_t copyLength;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474   <span class="comment">/* Handle wear pages. Should we handle this as an extra write to an existing</span>
<a name="l00475"></a>00475 <span class="comment">   * page or create a new one. */</span>
<a name="l00476"></a>00476   <span class="keywordtype">bool</span> wearWrite = <span class="keyword">false</span>;
<a name="l00477"></a>00477 
<a name="l00478"></a>00478 <span class="preprocessor">#if (NVM_FEATURE_WRITE_NECESSARY_CHECK_ENABLED == true)</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>  <span class="comment">/* Bool used when checking if a write operation is needed. */</span>
<a name="l00480"></a>00480   <span class="keywordtype">bool</span> rewriteNeeded;
<a name="l00481"></a>00481 <span class="preprocessor">#endif</span>
<a name="l00482"></a>00482 <span class="preprocessor"></span>
<a name="l00483"></a>00483 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l00484"></a>00484 <span class="preprocessor"></span>  <span class="comment">/* Used to hold the checksum of the wear object. */</span>
<a name="l00485"></a>00485   uint16_t wearChecksum;
<a name="l00486"></a>00486   <span class="comment">/* Byte size of the wear object. Includes checksum length. */</span>
<a name="l00487"></a>00487   uint16_t wearObjectSize;
<a name="l00488"></a>00488   <span class="comment">/* Used to specify the internal index of the wear object in a page. */</span>
<a name="l00489"></a>00489   uint16_t wearIndex;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="preprocessor">  #if (NVM_FEATURE_WRITE_VALIDATION_ENABLED == true)</span>
<a name="l00492"></a>00492 <span class="preprocessor"></span>  <span class="comment">/* The new wear index the object will be written to. */</span>
<a name="l00493"></a>00493   uint16_t wearIndexNew;
<a name="l00494"></a>00494 <span class="preprocessor">  #endif</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00496"></a>00496 <span class="preprocessor"></span>
<a name="l00497"></a>00497   <span class="comment">/* Require write lock to continue. */</span>
<a name="l00498"></a>00498   NVM_ACQUIRE_WRITE_LOCK
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   <span class="comment">/* Find old physical address. */</span>
<a name="l00501"></a>00501   pOldPhysicalAddress = NVM_PageFind(pageId);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503   <span class="comment">/* Get the page configuration. */</span>
<a name="l00504"></a>00504   pageDesc = NVM_PageGet(pageId);
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="preprocessor">#if (NVM_FEATURE_WRITE_NECESSARY_CHECK_ENABLED == true)</span>
<a name="l00507"></a>00507 <span class="preprocessor"></span>  <span class="comment">/* If there is an old version of the page, it might not be necessary to update</span>
<a name="l00508"></a>00508 <span class="comment">   * the data. Also check that this is a normal page and that the static wear</span>
<a name="l00509"></a>00509 <span class="comment">   * leveling system is not working (this system might want to rewrite pages</span>
<a name="l00510"></a>00510 <span class="comment">   * even if the data is similar to the old version). */</span>
<a name="l00511"></a>00511   <span class="keywordflow">if</span> (((uint8_t *) NVM_NO_PAGE_RETURNED != pOldPhysicalAddress)
<a name="l00512"></a>00512       &amp;&amp; (<a class="code" href="group__NVM.html#ggae2a292fc163eaa08574b4c061c0b1ecaa2e7a6f6ed6a5752e4c4148104af077cd" title="Normal page, always rewrite.">nvmPageTypeNormal</a> == pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#abc9be6e483194ebbb8846c864729b71c" title="The type of page, normal or wear.">pageType</a>)
<a name="l00513"></a>00513 #if (<a class="code" href="group__NVM.html#ga0d9706aadc11d6e812a8f01514a18fb9" title="Include and activate the static wear leveling functionality.">NVM_FEATURE_STATIC_WEAR_ENABLED</a> == <span class="keyword">true</span>)
<a name="l00514"></a>00514       &amp;&amp; !nvmStaticWearWorking
<a name="l00515"></a>00515 #endif
<a name="l00516"></a>00516 
<a name="l00517"></a>00517       )
<a name="l00518"></a>00518   {
<a name="l00519"></a>00519     rewriteNeeded = <span class="keyword">false</span>;
<a name="l00520"></a>00520     objectIndex   = 0;
<a name="l00521"></a>00521     offsetAddress = 0;
<a name="l00522"></a>00522 
<a name="l00523"></a>00523     <span class="comment">/* Loop over items as long as no rewrite is needed and the current item has</span>
<a name="l00524"></a>00524 <span class="comment">    * got a size other than 0. Size 0 is used as a marker for a NULL object. */</span>
<a name="l00525"></a>00525     <span class="keywordflow">while</span> (((*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size != 0) &amp;&amp; !rewriteNeeded)
<a name="l00526"></a>00526     {
<a name="l00527"></a>00527       <span class="comment">/* Check if every object should be written or if this is the object to</span>
<a name="l00528"></a>00528 <span class="comment">       * write. */</span>
<a name="l00529"></a>00529       <span class="keywordflow">if</span> ((<a class="code" href="group__NVM.html#ga69ca4a7805f154f9e3b65bf2a42c8037" title="All objects are written from RAM.">NVM_WRITE_ALL_CMD</a> == objectId) ||
<a name="l00530"></a>00530           ((*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].objectId == objectId))
<a name="l00531"></a>00531       {
<a name="l00532"></a>00532         <span class="comment">/* Compare object to RAM. */</span>
<a name="l00533"></a>00533 
<a name="l00534"></a>00534         copyLength = (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size;
<a name="l00535"></a>00535 
<a name="l00536"></a>00536         <span class="comment">/* Loop over each byte of the object and compare with RAM. */</span>
<a name="l00537"></a>00537         <span class="keywordflow">while</span> (copyLength != 0)
<a name="l00538"></a>00538         {
<a name="l00539"></a>00539           <span class="comment">/* Get byte from NVM. */</span>
<a name="l00540"></a>00540           <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pOldPhysicalAddress + offsetAddress + NVM_HEADER_SIZE,
<a name="l00541"></a>00541                       &amp;copyBuffer,
<a name="l00542"></a>00542                       <span class="keyword">sizeof</span>(copyBuffer));
<a name="l00543"></a>00543 
<a name="l00544"></a>00544           <span class="comment">/* Check byte in NVM with the corresponding byte in RAM. */</span>
<a name="l00545"></a>00545           <span class="keywordflow">if</span> (*(uint8_t *)((*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].location + offsetAddress) != copyBuffer)
<a name="l00546"></a>00546           {
<a name="l00547"></a>00547             rewriteNeeded = <span class="keyword">true</span>;
<a name="l00548"></a>00548             <span class="keywordflow">break</span>;
<a name="l00549"></a>00549           }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551           <span class="comment">/* Move offset. */</span>
<a name="l00552"></a>00552           offsetAddress += <span class="keyword">sizeof</span>(copyBuffer);
<a name="l00553"></a>00553           copyLength    -= <span class="keyword">sizeof</span>(copyBuffer);
<a name="l00554"></a>00554         }
<a name="l00555"></a>00555       }
<a name="l00556"></a>00556       <span class="keywordflow">else</span>
<a name="l00557"></a>00557       {
<a name="l00558"></a>00558         <span class="comment">/* Move offset past the object. */</span>
<a name="l00559"></a>00559         offsetAddress += (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size;
<a name="l00560"></a>00560       }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562       <span class="comment">/* Check next object. */</span>
<a name="l00563"></a>00563       objectIndex++;
<a name="l00564"></a>00564     }
<a name="l00565"></a>00565 
<a name="l00566"></a>00566     <span class="keywordflow">if</span> (!rewriteNeeded)
<a name="l00567"></a>00567     {
<a name="l00568"></a>00568       <span class="comment">/* Release write lock before return. */</span>
<a name="l00569"></a>00569       NVM_RELEASE_WRITE_LOCK
<a name="l00570"></a>00570 
<a name="l00571"></a>00571       <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a>;
<a name="l00572"></a>00572     }
<a name="l00573"></a>00573   }
<a name="l00574"></a>00574 <span class="preprocessor">#endif</span>
<a name="l00575"></a>00575 <span class="preprocessor"></span>
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 
<a name="l00578"></a>00578 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l00579"></a>00579 <span class="preprocessor"></span>  <span class="comment">/* If this is a wear page then we can check if we can possibly squeeze another</span>
<a name="l00580"></a>00580 <span class="comment">   * version of the object inside the already existing page. If this is possible</span>
<a name="l00581"></a>00581 <span class="comment">   * we set the wearWrite boolean. This will then make us ignore the normal</span>
<a name="l00582"></a>00582 <span class="comment">   * write operation. */</span>
<a name="l00583"></a>00583   <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#ggae2a292fc163eaa08574b4c061c0b1ecaa81f13288c7f3413c4dc96832d7c11117" title="Wear page.">nvmPageTypeWear</a> == pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#abc9be6e483194ebbb8846c864729b71c" title="The type of page, normal or wear.">pageType</a>)
<a name="l00584"></a>00584   {
<a name="l00585"></a>00585     <span class="comment">/* Calculate checksum. The wear page checksum is only stored in 15 bits,</span>
<a name="l00586"></a>00586 <span class="comment">     * because we need one bit to mark that the object is written. This bit is</span>
<a name="l00587"></a>00587 <span class="comment">     * always set to 0. */</span>
<a name="l00588"></a>00588 
<a name="l00589"></a>00589     wearChecksum = NVM_CHECKSUM_INITIAL;
<a name="l00590"></a>00590     NVM_ChecksumAdditive(&amp;wearChecksum, (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].location, (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size);
<a name="l00591"></a>00591     wearChecksum &amp;= NVM_LAST_BIT_ZERO;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     <span class="comment">/* If there was an old page. */</span>
<a name="l00594"></a>00594     <span class="keywordflow">if</span> ((uint8_t *) NVM_NO_PAGE_RETURNED != pOldPhysicalAddress)
<a name="l00595"></a>00595     {
<a name="l00596"></a>00596       <span class="comment">/* Find location in old page. */</span>
<a name="l00597"></a>00597       wearIndex      = NVM_WearIndex(pOldPhysicalAddress, &amp;pageDesc);
<a name="l00598"></a>00598       wearObjectSize = (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size + NVM_CHECKSUM_LENGTH;
<a name="l00599"></a>00599 
<a name="l00600"></a>00600       <span class="comment">/* Check that the wearIndex returned is within the length of the page. */</span>
<a name="l00601"></a>00601       <span class="keywordflow">if</span> (wearIndex &lt; ((uint16_t) NVM_WEAR_CONTENT_SIZE) / wearObjectSize)
<a name="l00602"></a>00602       {
<a name="l00603"></a>00603         result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pOldPhysicalAddress + NVM_HEADER_SIZE + wearIndex * wearObjectSize,
<a name="l00604"></a>00604                               (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].location,
<a name="l00605"></a>00605                               (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size);
<a name="l00606"></a>00606         result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pOldPhysicalAddress + NVM_HEADER_SIZE + wearIndex * wearObjectSize + (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size,
<a name="l00607"></a>00607                               &amp;wearChecksum,
<a name="l00608"></a>00608                               <span class="keyword">sizeof</span>(wearChecksum));
<a name="l00609"></a>00609 
<a name="l00610"></a>00610         <span class="comment">/* Register that we have now written to the old page. */</span>
<a name="l00611"></a>00611         wearWrite = <span class="keyword">true</span>;
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="preprocessor">#if (NVM_FEATURE_WRITE_VALIDATION_ENABLED == true)</span>
<a name="l00614"></a>00614 <span class="preprocessor"></span>        <span class="comment">/* Check if the newest one that is valid is the same as the one we just</span>
<a name="l00615"></a>00615 <span class="comment">         * wrote to the NVM. */</span>
<a name="l00616"></a>00616         <span class="keywordflow">if</span> ((!NVM_WearReadIndex(pOldPhysicalAddress, &amp;pageDesc, &amp;wearIndexNew)) ||
<a name="l00617"></a>00617             (wearIndexNew != wearIndex))
<a name="l00618"></a>00618         {
<a name="l00619"></a>00619           result = <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>;
<a name="l00620"></a>00620         }
<a name="l00621"></a>00621 <span class="preprocessor">#endif</span>
<a name="l00622"></a>00622 <span class="preprocessor"></span>      }
<a name="l00623"></a>00623     } <span class="comment">/* End of old page if. */</span>
<a name="l00624"></a>00624   }   <span class="comment">/* End of wear page if. */</span>
<a name="l00625"></a>00625 <span class="preprocessor">#endif</span>
<a name="l00626"></a>00626 <span class="preprocessor"></span>
<a name="l00627"></a>00627 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l00628"></a>00628 <span class="preprocessor"></span>  <span class="comment">/* Do not create a new page if we have already done an in-page wear write. */</span>
<a name="l00629"></a>00629   <span class="keywordflow">if</span> (!wearWrite)
<a name="l00630"></a>00630   {
<a name="l00631"></a>00631 <span class="preprocessor">#endif</span>
<a name="l00632"></a>00632 <span class="preprocessor"></span>  <span class="comment">/* Mark any old page before creating a new one. */</span>
<a name="l00633"></a>00633   <span class="keywordflow">if</span> ((uint8_t *) NVM_NO_PAGE_RETURNED != pOldPhysicalAddress)
<a name="l00634"></a>00634   {
<a name="l00635"></a>00635     result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pOldPhysicalAddress, &amp;flipWatermark, 4);
<a name="l00636"></a>00636 
<a name="l00637"></a>00637     <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a> != result)
<a name="l00638"></a>00638     {
<a name="l00639"></a>00639       <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l00640"></a>00640       NVM_RELEASE_WRITE_LOCK
<a name="l00641"></a>00641       <span class="keywordflow">return</span> result;
<a name="l00642"></a>00642     }
<a name="l00643"></a>00643   }
<a name="l00644"></a>00644 
<a name="l00645"></a>00645   <span class="comment">/* Find new physical address to write to. */</span>
<a name="l00646"></a>00646   pNewPhysicalAddress = NVM_ScratchPageFindBest();
<a name="l00647"></a>00647 
<a name="l00648"></a>00648   <span class="keywordflow">if</span> ((uint8_t*) NVM_NO_PAGE_RETURNED == pNewPhysicalAddress)
<a name="l00649"></a>00649   {
<a name="l00650"></a>00650     <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l00651"></a>00651     NVM_RELEASE_WRITE_LOCK
<a name="l00652"></a>00652     <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>;
<a name="l00653"></a>00653   }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655   <span class="comment">/* Generate and write header */</span>
<a name="l00656"></a>00656   header.watermark = watermark;
<a name="l00657"></a>00657   header.updateId  = NVM_NO_WRITE_32BIT;
<a name="l00658"></a>00658   header.version   = NVM_VERSION;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   <span class="comment">/* store header at beginning of page */</span>
<a name="l00661"></a>00661   result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pNewPhysicalAddress, &amp;header.watermark, <span class="keyword">sizeof</span>(header.watermark));
<a name="l00662"></a>00662   result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pNewPhysicalAddress + <span class="keyword">sizeof</span>(header.watermark), &amp;header.updateId, <span class="keyword">sizeof</span>(header.updateId));
<a name="l00663"></a>00663   result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pNewPhysicalAddress + <span class="keyword">sizeof</span>(header.watermark)+ + <span class="keyword">sizeof</span>(header.updateId), &amp;header.version, <span class="keyword">sizeof</span>(header.version));
<a name="l00664"></a>00664 
<a name="l00665"></a>00665   <span class="comment">/* Reset address index within page. */</span>
<a name="l00666"></a>00666   offsetAddress = 0;
<a name="l00667"></a>00667   <span class="comment">/* Reset object in page counter. */</span>
<a name="l00668"></a>00668   objectIndex = 0;
<a name="l00669"></a>00669 
<a name="l00670"></a>00670   <span class="comment">/* Loop over items as long as everything is OK, and the current item has got</span>
<a name="l00671"></a>00671 <span class="comment">   * a size other than 0. Size 0 is used as a marker for a NULL object. */</span>
<a name="l00672"></a>00672   <span class="keywordflow">while</span> (((*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size != 0) &amp;&amp; (<a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a> == result))
<a name="l00673"></a>00673   {
<a name="l00674"></a>00674     <span class="comment">/* Check if every object should be written or if this is the object to</span>
<a name="l00675"></a>00675 <span class="comment">     * write. */</span>
<a name="l00676"></a>00676     <span class="keywordflow">if</span> ((<a class="code" href="group__NVM.html#ga69ca4a7805f154f9e3b65bf2a42c8037" title="All objects are written from RAM.">NVM_WRITE_ALL_CMD</a> == objectId) ||
<a name="l00677"></a>00677         ((*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].objectId == objectId))
<a name="l00678"></a>00678     {
<a name="l00679"></a>00679       <span class="comment">/* Write object from RAM. */</span>
<a name="l00680"></a>00680       result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pNewPhysicalAddress + offsetAddress + NVM_HEADER_SIZE,
<a name="l00681"></a>00681                             (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].location,
<a name="l00682"></a>00682                             (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size);
<a name="l00683"></a>00683       offsetAddress += (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size;
<a name="l00684"></a>00684 
<a name="l00685"></a>00685       NVM_ChecksumAdditive(&amp;checksum, (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].location, (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size);
<a name="l00686"></a>00686     }
<a name="l00687"></a>00687     <span class="keywordflow">else</span>
<a name="l00688"></a>00688     {
<a name="l00689"></a>00689       <span class="comment">/* Get version from old page. */</span>
<a name="l00690"></a>00690       <span class="keywordflow">if</span> ((uint8_t *) NVM_NO_PAGE_RETURNED != pOldPhysicalAddress)
<a name="l00691"></a>00691       {
<a name="l00692"></a>00692         NVM_ChecksumAdditive(&amp;checksum, pOldPhysicalAddress + offsetAddress + NVM_HEADER_SIZE, (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size);
<a name="l00693"></a>00693 
<a name="l00694"></a>00694         copyLength = (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size;
<a name="l00695"></a>00695 
<a name="l00696"></a>00696         <span class="keywordflow">while</span> ((copyLength != 0) &amp;&amp; (<a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a> == result))
<a name="l00697"></a>00697         {
<a name="l00698"></a>00698           <span class="comment">/* Copies using an 1 byte buffer. Might be better to dynamically use larger if possible. */</span>
<a name="l00699"></a>00699           <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pOldPhysicalAddress + offsetAddress + NVM_HEADER_SIZE,
<a name="l00700"></a>00700                       &amp;copyBuffer,
<a name="l00701"></a>00701                       <span class="keyword">sizeof</span>(copyBuffer));
<a name="l00702"></a>00702           result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pNewPhysicalAddress + offsetAddress + NVM_HEADER_SIZE,
<a name="l00703"></a>00703                                 &amp;copyBuffer,
<a name="l00704"></a>00704                                 <span class="keyword">sizeof</span>(copyBuffer));
<a name="l00705"></a>00705 
<a name="l00706"></a>00706           offsetAddress += <span class="keyword">sizeof</span>(copyBuffer);
<a name="l00707"></a>00707           copyLength    -= <span class="keyword">sizeof</span>(copyBuffer);
<a name="l00708"></a>00708         }
<a name="l00709"></a>00709       }  <span class="comment">/* End if old page. */</span>
<a name="l00710"></a>00710     }   <span class="comment">/* Else-end of NVM_WRITE_ALL if-statement. */</span>
<a name="l00711"></a>00711 
<a name="l00712"></a>00712     objectIndex++;
<a name="l00713"></a>00713   }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715   <span class="comment">/* If we are creating a wear page, add the checksum directly after the data. */</span>
<a name="l00716"></a>00716 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l00717"></a>00717 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#ggae2a292fc163eaa08574b4c061c0b1ecaa81f13288c7f3413c4dc96832d7c11117" title="Wear page.">nvmPageTypeWear</a> == pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#abc9be6e483194ebbb8846c864729b71c" title="The type of page, normal or wear.">pageType</a>)
<a name="l00718"></a>00718   {
<a name="l00719"></a>00719     result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pNewPhysicalAddress + offsetAddress + NVM_HEADER_SIZE,
<a name="l00720"></a>00720                           &amp;wearChecksum,
<a name="l00721"></a>00721                           <span class="keyword">sizeof</span>(wearChecksum));
<a name="l00722"></a>00722   }
<a name="l00723"></a>00723   <span class="comment">/* Generate and write footer on normal pages. */</span>
<a name="l00724"></a>00724   <span class="keywordflow">else</span>
<a name="l00725"></a>00725   {
<a name="l00726"></a>00726 <span class="preprocessor">#endif</span>
<a name="l00727"></a>00727 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a> == result)
<a name="l00728"></a>00728   {
<a name="l00729"></a>00729     <span class="comment">/* write checksum at end of page */</span>
<a name="l00730"></a>00730     result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pNewPhysicalAddress + (<a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a> - NVM_FOOTER_SIZE), &amp;checksum, <span class="keyword">sizeof</span>(checksum));
<a name="l00731"></a>00731     <span class="comment">/* write watermark just after checksum at end of page */</span>
<a name="l00732"></a>00732     result = <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pNewPhysicalAddress + (<a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a> + <span class="keyword">sizeof</span>(checksum) - NVM_FOOTER_SIZE), &amp;watermark, <span class="keyword">sizeof</span>(watermark));
<a name="l00733"></a>00733   }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l00736"></a>00736 <span class="preprocessor"></span>}     <span class="comment">/* End of else from page type. */</span>
<a name="l00737"></a>00737 <span class="preprocessor">#endif</span>
<a name="l00738"></a>00738 <span class="preprocessor"></span>
<a name="l00739"></a>00739 <span class="preprocessor">#if (NVM_FEATURE_WRITE_VALIDATION_ENABLED == true)</span>
<a name="l00740"></a>00740 <span class="preprocessor"></span>  <span class="comment">/* Validate that the correct data was written. */</span>
<a name="l00741"></a>00741   <span class="keywordflow">if</span> (nvmValidateResultOk != NVM_PageValidate(pNewPhysicalAddress))
<a name="l00742"></a>00742   {
<a name="l00743"></a>00743     result = <a class="code" href="group__NVM.html#gad67929c11d6b7520bf992dc6dcfc4d2c" title="General error.">ECODE_EMDRV_NVM_ERROR</a>;
<a name="l00744"></a>00744   }
<a name="l00745"></a>00745 <span class="preprocessor">#endif</span>
<a name="l00746"></a>00746 <span class="preprocessor"></span>
<a name="l00747"></a>00747 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l00748"></a>00748 <span class="preprocessor"></span>}   <span class="comment">/* End of if for normal write (!wearWrite). */</span>
<a name="l00749"></a>00749 <span class="preprocessor">#endif</span>
<a name="l00750"></a>00750 <span class="preprocessor"></span>
<a name="l00751"></a>00751   <span class="comment">/* Erase old if there was an old one and everything else have gone OK. */</span>
<a name="l00752"></a>00752   <span class="keywordflow">if</span> ((!wearWrite) &amp;&amp;
<a name="l00753"></a>00753       ((uint8_t *) NVM_NO_PAGE_RETURNED != pOldPhysicalAddress))
<a name="l00754"></a>00754   {
<a name="l00755"></a>00755     <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a> == result)
<a name="l00756"></a>00756     {
<a name="l00757"></a>00757       result = NVM_PageErase(pOldPhysicalAddress);
<a name="l00758"></a>00758     }
<a name="l00759"></a>00759     <span class="keywordflow">else</span>
<a name="l00760"></a>00760     {
<a name="l00761"></a>00761       NVM_PageErase(pNewPhysicalAddress);
<a name="l00762"></a>00762     }
<a name="l00763"></a>00763   }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765   <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l00766"></a>00766   NVM_RELEASE_WRITE_LOCK
<a name="l00767"></a>00767 
<a name="l00768"></a>00768   <span class="keywordflow">return</span> result;
<a name="l00769"></a>00769 }
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 <span class="comment">/***************************************************************************/</span>
<a name="l00791"></a><a class="code" href="group__NVM.html#ga34880829bee50bf0fde0f6c9695dca86">00791</a> <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> <a class="code" href="group__NVM.html#ga34880829bee50bf0fde0f6c9695dca86" title="Read an object or an entire page.">NVM_Read</a>(uint16_t pageId, uint8_t objectId)
<a name="l00792"></a>00792 {
<a name="l00793"></a>00793 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l00794"></a>00794 <span class="preprocessor"></span>  <span class="comment">/* Variable used to fetch read index. */</span>
<a name="l00795"></a>00795   uint16_t wearIndex;
<a name="l00796"></a>00796 <span class="preprocessor">#endif</span>
<a name="l00797"></a>00797 <span class="preprocessor"></span>
<a name="l00798"></a>00798   <span class="comment">/* Physical address of the page to read from. */</span>
<a name="l00799"></a>00799   uint8_t *pPhysicalAddress;
<a name="l00800"></a>00800 
<a name="l00801"></a>00801   <span class="comment">/* Description of the page, used to find page type and objects. */</span>
<a name="l00802"></a>00802   <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> pageDesc;
<a name="l00803"></a>00803 
<a name="l00804"></a>00804   <span class="comment">/* Index of object in page. */</span>
<a name="l00805"></a>00805   uint8_t  objectIndex;
<a name="l00806"></a>00806   <span class="comment">/* Address of read location within a page. */</span>
<a name="l00807"></a>00807   uint16_t offsetAddress;
<a name="l00808"></a>00808 
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <span class="comment">/* Require write lock to continue. */</span>
<a name="l00811"></a>00811   NVM_ACQUIRE_WRITE_LOCK
<a name="l00812"></a>00812 
<a name="l00813"></a>00813   <span class="comment">/* Find physical page. */</span>
<a name="l00814"></a>00814   pPhysicalAddress = NVM_PageFind(pageId);
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="comment">/* If no page was found, we cannot read anything. */</span>
<a name="l00817"></a>00817   <span class="keywordflow">if</span> ((uint8_t*) NVM_NO_PAGE_RETURNED == pPhysicalAddress)
<a name="l00818"></a>00818   {
<a name="l00819"></a>00819     <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l00820"></a>00820     NVM_RELEASE_WRITE_LOCK
<a name="l00821"></a>00821     <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#ga6ea441c3105ea4a18a10a3b042bd7d86" title="Could not find the page specified.">ECODE_EMDRV_NVM_PAGE_INVALID</a>;
<a name="l00822"></a>00822   }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="comment">/* Get page description. */</span>
<a name="l00825"></a>00825   pageDesc = NVM_PageGet(pageId);
<a name="l00826"></a>00826 
<a name="l00827"></a>00827 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l00828"></a>00828 <span class="preprocessor"></span>  <span class="comment">/* If this is a wear page, we must find out which object in the page should be</span>
<a name="l00829"></a>00829 <span class="comment">   * read. */</span>
<a name="l00830"></a>00830   <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#ggae2a292fc163eaa08574b4c061c0b1ecaa81f13288c7f3413c4dc96832d7c11117" title="Wear page.">nvmPageTypeWear</a> == pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#abc9be6e483194ebbb8846c864729b71c" title="The type of page, normal or wear.">pageType</a>)
<a name="l00831"></a>00831   {
<a name="l00832"></a>00832     <span class="comment">/* Find valid object in wear page and read it. */</span>
<a name="l00833"></a>00833     <span class="keywordflow">if</span> (NVM_WearReadIndex(pPhysicalAddress, &amp;pageDesc, &amp;wearIndex))
<a name="l00834"></a>00834     {
<a name="l00835"></a>00835       <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + NVM_HEADER_SIZE +
<a name="l00836"></a>00836                   wearIndex * ((*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size + NVM_CHECKSUM_LENGTH),
<a name="l00837"></a>00837                   (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].location,
<a name="l00838"></a>00838                   (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size);
<a name="l00839"></a>00839     }
<a name="l00840"></a>00840     <span class="keywordflow">else</span>
<a name="l00841"></a>00841     {
<a name="l00842"></a>00842       <span class="comment">/* No valid object was found in the page. */</span>
<a name="l00843"></a>00843       <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l00844"></a>00844       NVM_RELEASE_WRITE_LOCK
<a name="l00845"></a>00845       <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#ga513abf6d9830442da42feae5d3aa3793" title="Invalid input data or format.">ECODE_EMDRV_NVM_DATA_INVALID</a>;
<a name="l00846"></a>00846     }
<a name="l00847"></a>00847   }
<a name="l00848"></a>00848   <span class="keywordflow">else</span>
<a name="l00849"></a>00849 <span class="preprocessor">#endif</span>
<a name="l00850"></a>00850 <span class="preprocessor"></span>  {
<a name="l00851"></a>00851     <span class="comment">/* Read normal page. */</span>
<a name="l00852"></a>00852     objectIndex   = 0;
<a name="l00853"></a>00853     offsetAddress = 0;
<a name="l00854"></a>00854 
<a name="l00855"></a>00855 <span class="preprocessor">#if (NVM_FEATURE_READ_VALIDATION_ENABLED == true)</span>
<a name="l00856"></a>00856 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (nvmValidateResultError == NVM_PageValidate(pPhysicalAddress))
<a name="l00857"></a>00857     {
<a name="l00858"></a>00858       <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l00859"></a>00859       NVM_RELEASE_WRITE_LOCK
<a name="l00860"></a>00860       <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#ga513abf6d9830442da42feae5d3aa3793" title="Invalid input data or format.">ECODE_EMDRV_NVM_DATA_INVALID</a>;
<a name="l00861"></a>00861     }
<a name="l00862"></a>00862 <span class="preprocessor">#endif</span>
<a name="l00863"></a>00863 <span class="preprocessor"></span>
<a name="l00864"></a>00864     <span class="comment">/* Loop through and read the objects of a page, as long as the current item</span>
<a name="l00865"></a>00865 <span class="comment">     * has got a size other than 0. Size 0 is a marker for the NULL object. */</span>
<a name="l00866"></a>00866     <span class="keywordflow">while</span> ((*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size != 0)
<a name="l00867"></a>00867     {
<a name="l00868"></a>00868       <span class="comment">/* Check if every object should be read or if this is the object to read. */</span>
<a name="l00869"></a>00869       <span class="keywordflow">if</span> ((<a class="code" href="group__NVM.html#gaf237b8d940d372ccbd82b8998fbc8f60" title="All objects are read to RAM.">NVM_READ_ALL_CMD</a> == objectId) || ((*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].objectId == objectId))
<a name="l00870"></a>00870       {
<a name="l00871"></a>00871         <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + offsetAddress + NVM_HEADER_SIZE,
<a name="l00872"></a>00872                     (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].location,
<a name="l00873"></a>00873                     (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size);
<a name="l00874"></a>00874       }
<a name="l00875"></a>00875 
<a name="l00876"></a>00876       offsetAddress += (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size;
<a name="l00877"></a>00877       objectIndex++;
<a name="l00878"></a>00878     }
<a name="l00879"></a>00879   }
<a name="l00880"></a>00880 
<a name="l00881"></a>00881   <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l00882"></a>00882   NVM_RELEASE_WRITE_LOCK
<a name="l00883"></a>00883 
<a name="l00884"></a>00884   <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a>;
<a name="l00885"></a>00885 }
<a name="l00886"></a>00886 
<a name="l00887"></a>00887 <span class="comment">/***************************************************************************/</span>
<a name="l00898"></a>00898 <span class="preprocessor">#if (NVM_FEATURE_WEARLEVELGET_ENABLED == true)</span>
<a name="l00899"></a><a class="code" href="group__NVM.html#ga00eaed13302c2951bec32c92dca57597">00899</a> <span class="preprocessor"></span>uint32_t <a class="code" href="group__NVM.html#ga00eaed13302c2951bec32c92dca57597" title="Get maximum wear level.">NVM_WearLevelGet</a>(<span class="keywordtype">void</span>)
<a name="l00900"></a>00900 {
<a name="l00901"></a>00901   uint16_t page;
<a name="l00902"></a>00902   <span class="comment">/* Used to temporarily store the update id of the current page. */</span>
<a name="l00903"></a>00903   uint32_t updateId;
<a name="l00904"></a>00904   <span class="comment">/* Worst (highest) update id. Used as return value. */</span>
<a name="l00905"></a>00905   uint32_t worstUpdateId = 0;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   <span class="comment">/* Address of physical page. */</span>
<a name="l00908"></a>00908   uint8_t *pPhysicalAddress = (uint8_t *)(nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a3096ad0ec94fcc2df81e891908027ddc" title="Pointer to nvm area in flash.">nvmArea</a>);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910   <span class="comment">/* Loop through all pages in memory. */</span>
<a name="l00911"></a>00911   <span class="keywordflow">for</span> (page = 0; page &lt; nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a29a3ddbe19f1c8535a07d94ca028f39c" title="Total number of physical pages.">pages</a>; ++page)
<a name="l00912"></a>00912   {
<a name="l00913"></a>00913     <span class="comment">/* Find and compare erasure count. */</span>
<a name="l00914"></a>00914     <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + 2, &amp;updateId, <span class="keyword">sizeof</span>(updateId));
<a name="l00915"></a>00915     <span class="keywordflow">if</span> (updateId &gt; worstUpdateId)
<a name="l00916"></a>00916     {
<a name="l00917"></a>00917       worstUpdateId = updateId;
<a name="l00918"></a>00918     }
<a name="l00919"></a>00919 
<a name="l00920"></a>00920     <span class="comment">/* Go to the next physical page. */</span>
<a name="l00921"></a>00921     pPhysicalAddress += <a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a>;
<a name="l00922"></a>00922   }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   <span class="keywordflow">return</span> worstUpdateId;
<a name="l00925"></a>00925 }
<a name="l00926"></a>00926 <span class="preprocessor">#endif</span>
<a name="l00927"></a>00927 <span class="preprocessor"></span>
<a name="l00928"></a>00928 <span class="comment">/*******************************************************************************</span>
<a name="l00929"></a>00929 <span class="comment"> ***************************   LOCAL FUNCTIONS   *******************************</span>
<a name="l00930"></a>00930 <span class="comment"> ******************************************************************************/</span>
<a name="l00931"></a>00931 
<a name="l00934"></a>00934 <span class="comment">/***************************************************************************/</span>
<a name="l00949"></a>00949 <span class="keyword">static</span> uint8_t* NVM_PageFind(uint16_t pageId)
<a name="l00950"></a>00950 {
<a name="l00951"></a>00951   uint16_t page;
<a name="l00952"></a>00952   <span class="comment">/* Physical address to return. */</span>
<a name="l00953"></a>00953   uint8_t  *pPhysicalAddress = (uint8_t *)(nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a3096ad0ec94fcc2df81e891908027ddc" title="Pointer to nvm area in flash.">nvmArea</a>);
<a name="l00954"></a>00954   <span class="comment">/* Temporary variable used to read and compare logical page address. */</span>
<a name="l00955"></a>00955   uint16_t logicalAddress;
<a name="l00956"></a>00956 
<a name="l00957"></a>00957   <span class="comment">/* Loop through memory looking for a matching watermark. */</span>
<a name="l00958"></a>00958   <span class="keywordflow">for</span> (page = 0; page &lt; nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a29a3ddbe19f1c8535a07d94ca028f39c" title="Total number of physical pages.">pages</a>; ++page)
<a name="l00959"></a>00959   {
<a name="l00960"></a>00960     <span class="comment">/* Allow both versions of writing mark, invalid duplicates should already</span>
<a name="l00961"></a>00961 <span class="comment">     * have been deleted. */</span>
<a name="l00962"></a>00962     <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress, &amp;logicalAddress, <span class="keyword">sizeof</span>(logicalAddress));
<a name="l00963"></a>00963     <span class="keywordflow">if</span> (((pageId | NVM_FIRST_BIT_ONE) == logicalAddress) || (pageId == logicalAddress))
<a name="l00964"></a>00964     {
<a name="l00965"></a>00965       <span class="keywordflow">return</span> pPhysicalAddress;
<a name="l00966"></a>00966     }
<a name="l00967"></a>00967 
<a name="l00968"></a>00968     <span class="comment">/* Move lookup point to the next page. */</span>
<a name="l00969"></a>00969     pPhysicalAddress += <a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a>;
<a name="l00970"></a>00970   }
<a name="l00971"></a>00971 
<a name="l00972"></a>00972   <span class="comment">/* No page found. */</span>
<a name="l00973"></a>00973   <span class="keywordflow">return</span> (uint8_t *) NVM_NO_PAGE_RETURNED;
<a name="l00974"></a>00974 }
<a name="l00975"></a>00975 
<a name="l00976"></a>00976 <span class="comment">/***************************************************************************/</span>
<a name="l00988"></a>00988 <span class="keyword">static</span> uint8_t* NVM_ScratchPageFindBest(<span class="keywordtype">void</span>)
<a name="l00989"></a>00989 {
<a name="l00990"></a>00990   uint16_t page;
<a name="l00991"></a>00991   <span class="comment">/* Address for physical page to return. */</span>
<a name="l00992"></a>00992   uint8_t  *pPhysicalPage = (uint8_t *) NVM_NO_PAGE_RETURNED;
<a name="l00993"></a>00993 
<a name="l00994"></a>00994   <span class="comment">/* Variable used to read and compare update id of physical pages. */</span>
<a name="l00995"></a>00995   uint32_t updateId = NVM_HIGHEST_32BIT;
<a name="l00996"></a>00996   <span class="comment">/* The best update id found. */</span>
<a name="l00997"></a>00997   uint32_t bestUpdateId = NVM_HIGHEST_32BIT;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999   <span class="comment">/* Pointer to the current physical page. */</span>
<a name="l01000"></a>01000   uint8_t  *pPhysicalAddress = (uint8_t *)(nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a3096ad0ec94fcc2df81e891908027ddc" title="Pointer to nvm area in flash.">nvmArea</a>);
<a name="l01001"></a>01001   <span class="comment">/* Logical address that identifies the page. */</span>
<a name="l01002"></a>01002   uint16_t logicalAddress;
<a name="l01003"></a>01003 
<a name="l01004"></a>01004   <span class="comment">/* Loop through all pages in memory. */</span>
<a name="l01005"></a>01005   <span class="keywordflow">for</span> (page = 0; page &lt; nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a29a3ddbe19f1c8535a07d94ca028f39c" title="Total number of physical pages.">pages</a>; ++page)
<a name="l01006"></a>01006   {
<a name="l01007"></a>01007     <span class="comment">/* Read and check logical address. */</span>
<a name="l01008"></a>01008     <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress, &amp;logicalAddress, <span class="keyword">sizeof</span>(logicalAddress));
<a name="l01009"></a>01009     <span class="keywordflow">if</span> ((uint16_t) NVM_PAGE_EMPTY_VALUE == logicalAddress)
<a name="l01010"></a>01010     {
<a name="l01011"></a>01011       <span class="comment">/* Find and compare erasure count. */</span>
<a name="l01012"></a>01012       <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + 2, &amp;updateId, <span class="keyword">sizeof</span>(updateId));
<a name="l01013"></a>01013       <span class="keywordflow">if</span> (updateId &lt; bestUpdateId)
<a name="l01014"></a>01014       {
<a name="l01015"></a>01015         bestUpdateId  = updateId;
<a name="l01016"></a>01016         pPhysicalPage = pPhysicalAddress;
<a name="l01017"></a>01017       }
<a name="l01018"></a>01018     }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020     <span class="comment">/* Move lookup point to the next page. */</span>
<a name="l01021"></a>01021     pPhysicalAddress += <a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a>;
<a name="l01022"></a>01022   }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024   <span class="comment">/* Return a pointer to the best/least used page. */</span>
<a name="l01025"></a>01025   <span class="keywordflow">return</span> pPhysicalPage;
<a name="l01026"></a>01026 }
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 <span class="comment">/***************************************************************************/</span>
<a name="l01042"></a>01042 <span class="keyword">static</span> <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> NVM_PageErase(uint8_t *pPhysicalAddress)
<a name="l01043"></a>01043 {
<a name="l01044"></a>01044 <span class="preprocessor">#if (NVM_FEATURE_STATIC_WEAR_ENABLED == true)</span>
<a name="l01045"></a>01045 <span class="preprocessor"></span>  <span class="comment">/* Logical page address. */</span>
<a name="l01046"></a>01046   uint16_t logicalAddress;
<a name="l01047"></a>01047 <span class="preprocessor">#endif</span>
<a name="l01048"></a>01048 <span class="preprocessor"></span>
<a name="l01049"></a>01049   <span class="comment">/* Read out the old page update id. */</span>
<a name="l01050"></a>01050   uint32_t updateId;
<a name="l01051"></a>01051   <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + 2, &amp;updateId, <span class="keyword">sizeof</span>(updateId));
<a name="l01052"></a>01052 
<a name="l01053"></a>01053 <span class="preprocessor">#if (NVM_FEATURE_STATIC_WEAR_ENABLED == true)</span>
<a name="l01054"></a>01054 <span class="preprocessor"></span>  <span class="comment">/* Get logical page address. */</span>
<a name="l01055"></a>01055   <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress, &amp;logicalAddress, <span class="keyword">sizeof</span>(logicalAddress));
<a name="l01056"></a>01056 
<a name="l01057"></a>01057   <span class="comment">/* If not empty: mark as erased and check against threshold. */</span>
<a name="l01058"></a>01058   <span class="keywordflow">if</span> (logicalAddress != NVM_PAGE_EMPTY_VALUE)
<a name="l01059"></a>01059   {
<a name="l01060"></a>01060     <span class="comment">/* Set first bit low. */</span>
<a name="l01061"></a>01061     logicalAddress = logicalAddress &amp; NVM_FIRST_BIT_ZERO;
<a name="l01062"></a>01062     NVM_StaticWearUpdate(logicalAddress);
<a name="l01063"></a>01063   }
<a name="l01064"></a>01064 <span class="preprocessor">#endif</span>
<a name="l01065"></a>01065 <span class="preprocessor"></span>
<a name="l01066"></a>01066   <span class="comment">/* Erase the page. */</span>
<a name="l01067"></a>01067   <a class="code" href="nvm__hal_8h.html#aaa2acd545c460f4cea576178fc185a21" title="Erase a page in the NVM.">NVMHAL_PageErase</a>(pPhysicalAddress);
<a name="l01068"></a>01068 
<a name="l01069"></a>01069   <span class="comment">/* Update erasure count. */</span>
<a name="l01070"></a>01070   updateId++;
<a name="l01071"></a>01071 
<a name="l01072"></a>01072   <span class="comment">/* Write increased erasure count. */</span>
<a name="l01073"></a>01073   <span class="keywordflow">return</span> <a class="code" href="nvm__hal_8h.html#a0800d58f7bb43d0462592d0062c5cef3" title="Write data to NVM.">NVMHAL_Write</a>(pPhysicalAddress + 2, &amp;updateId, <span class="keyword">sizeof</span>(updateId));
<a name="l01074"></a>01074 }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 <span class="comment">/***************************************************************************/</span>
<a name="l01095"></a>01095 <span class="keyword">static</span> <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> NVM_PageGet(uint16_t pageId)
<a name="l01096"></a>01096 {
<a name="l01097"></a>01097   uint8_t pageIndex;
<a name="l01098"></a>01098   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> nullPage = { (uint8_t) 0, 0, (<a class="code" href="group__NVM.html#gae2a292fc163eaa08574b4c061c0b1eca" title="Enum describing the type of logical page we have; normal or wear.">NVM_Page_Type_t</a>) 0 };
<a name="l01099"></a>01099 
<a name="l01100"></a>01100   <span class="comment">/* Step through all configured pages. */</span>
<a name="l01101"></a>01101   <span class="keywordflow">for</span> (pageIndex = 0; pageIndex &lt; nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a59511e0aadcd44292a5fc52c6020c391" title="Number of defined (used) pages.">userPages</a>; ++pageIndex)
<a name="l01102"></a>01102   {
<a name="l01103"></a>01103     <span class="comment">/* If this is the page we want, return it. */</span>
<a name="l01104"></a>01104     <span class="keywordflow">if</span> ( (*(nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#aa6a79150e4b1db9181a2f5fc2534038d" title="Pointer to table defining NVM pages.">nvmPages</a>))[pageIndex].pageId == pageId)
<a name="l01105"></a>01105     {
<a name="l01106"></a>01106       <span class="keywordflow">return</span> (*(nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#aa6a79150e4b1db9181a2f5fc2534038d" title="Pointer to table defining NVM pages.">nvmPages</a>))[pageIndex];
<a name="l01107"></a>01107     }
<a name="l01108"></a>01108   }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110   <span class="comment">/* No page matched the ID, return a NULL page to mark the error. */</span>
<a name="l01111"></a>01111   <span class="keywordflow">return</span> nullPage;
<a name="l01112"></a>01112 }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114 <span class="comment">/***************************************************************************/</span>
<a name="l01135"></a>01135 <span class="keyword">static</span> NVM_ValidateResult_t NVM_PageValidate(uint8_t *pPhysicalAddress)
<a name="l01136"></a>01136 {
<a name="l01137"></a>01137   <span class="comment">/* Result used as return value from the function. */</span>
<a name="l01138"></a>01138   NVM_ValidateResult_t result;
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <span class="comment">/* Objects used to read out the page header and footer. */</span>
<a name="l01141"></a>01141   NVM_Page_Header_t header;
<a name="l01142"></a>01142   NVM_Page_Footer_t footer;
<a name="l01143"></a>01143 
<a name="l01144"></a>01144   <span class="comment">/* Descriptor for the current page. */</span>
<a name="l01145"></a>01145   <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> pageDesc;
<a name="l01146"></a>01146 
<a name="l01147"></a>01147   <span class="comment">/* Variable used for calculating checksums. */</span>
<a name="l01148"></a>01148   uint16_t checksum;
<a name="l01149"></a>01149 
<a name="l01150"></a>01150   <span class="comment">/* Offset of object in page. */</span>
<a name="l01151"></a>01151   uint8_t  objectIndex;
<a name="l01152"></a>01152   <span class="comment">/* Address of read location within a page. */</span>
<a name="l01153"></a>01153   uint16_t offsetAddress;
<a name="l01154"></a>01154 
<a name="l01155"></a>01155 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l01156"></a>01156 <span class="preprocessor"></span>  <span class="comment">/* Variable used to fetch read index. */</span>
<a name="l01157"></a>01157   uint16_t index;
<a name="l01158"></a>01158 <span class="preprocessor">#endif</span>
<a name="l01159"></a>01159 <span class="preprocessor"></span>
<a name="l01160"></a>01160   <span class="comment">/* Read page header data */</span>
<a name="l01161"></a>01161   <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress, &amp;header.watermark, <span class="keyword">sizeof</span>(header.watermark));
<a name="l01162"></a>01162   <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + <span class="keyword">sizeof</span>(header.watermark), &amp;header.updateId, <span class="keyword">sizeof</span>(header.updateId));
<a name="l01163"></a>01163   <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + <span class="keyword">sizeof</span>(header.watermark) + <span class="keyword">sizeof</span>(header.updateId), &amp;header.version, <span class="keyword">sizeof</span>(header.version));
<a name="l01164"></a>01164 
<a name="l01165"></a>01165   <span class="comment">/* Stop immediately if data is from another version of the API. */</span>
<a name="l01166"></a>01166   <span class="keywordflow">if</span> (NVM_VERSION != header.version)
<a name="l01167"></a>01167   {
<a name="l01168"></a>01168     <span class="keywordflow">return</span> nvmValidateResultOld;
<a name="l01169"></a>01169   }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171   <span class="comment">/* Get the page configuration. */</span>
<a name="l01172"></a>01172   pageDesc = NVM_PageGet((header.watermark &amp; NVM_FIRST_BIT_ZERO));
<a name="l01173"></a>01173 
<a name="l01174"></a>01174 
<a name="l01175"></a>01175 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l01176"></a>01176 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#ggae2a292fc163eaa08574b4c061c0b1ecaa81f13288c7f3413c4dc96832d7c11117" title="Wear page.">nvmPageTypeWear</a> == pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#abc9be6e483194ebbb8846c864729b71c" title="The type of page, normal or wear.">pageType</a>)
<a name="l01177"></a>01177   {
<a name="l01178"></a>01178     <span class="comment">/* Wear page. */</span>
<a name="l01179"></a>01179 
<a name="l01180"></a>01180     <span class="comment">/* If first bit is already zero the page is marked as a duplicate. */</span>
<a name="l01181"></a>01181     <span class="keywordflow">if</span> ((header.watermark &amp; NVM_FIRST_BIT_ZERO) == header.watermark)
<a name="l01182"></a>01182     {
<a name="l01183"></a>01183       result = nvmValidateResultOkMarked;
<a name="l01184"></a>01184     }
<a name="l01185"></a>01185     <span class="keywordflow">else</span>
<a name="l01186"></a>01186     {
<a name="l01187"></a>01187       <span class="comment">/* Page is not marked as a duplicate. */</span>
<a name="l01188"></a>01188       result = nvmValidateResultOk;
<a name="l01189"></a>01189     }
<a name="l01190"></a>01190 
<a name="l01191"></a>01191     <span class="comment">/* If we do not have any valid objects in the page it is invalid. */</span>
<a name="l01192"></a>01192     <span class="keywordflow">if</span> (!NVM_WearReadIndex(pPhysicalAddress, &amp;pageDesc, &amp;index))
<a name="l01193"></a>01193     {
<a name="l01194"></a>01194       result = nvmValidateResultError;
<a name="l01195"></a>01195     }
<a name="l01196"></a>01196   }
<a name="l01197"></a>01197   <span class="keywordflow">else</span>
<a name="l01198"></a>01198 <span class="preprocessor">#endif</span>
<a name="l01199"></a>01199 <span class="preprocessor"></span>  {
<a name="l01200"></a>01200     <span class="comment">/* Normal page. */</span>
<a name="l01201"></a>01201     <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + (<a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a> - NVM_FOOTER_SIZE), &amp;footer.checksum, <span class="keyword">sizeof</span>(footer.checksum));
<a name="l01202"></a>01202     <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>(pPhysicalAddress + (<a class="code" href="group__NVM.html#ga08c4178cfbc31aaa81efee5588c5c6e6" title="Set the NVM driver page size to the size of the flash.">NVM_PAGE_SIZE</a> + <span class="keyword">sizeof</span>(checksum) - NVM_FOOTER_SIZE), &amp;footer.watermark, <span class="keyword">sizeof</span>(footer.watermark));
<a name="l01203"></a>01203     <span class="comment">/* Check if watermark or watermark with flipped write bit matches. */</span>
<a name="l01204"></a>01204     <span class="keywordflow">if</span> (header.watermark == footer.watermark)
<a name="l01205"></a>01205     {
<a name="l01206"></a>01206       result = nvmValidateResultOk;
<a name="l01207"></a>01207     }
<a name="l01208"></a>01208     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((header.watermark | NVM_FIRST_BIT_ONE) == footer.watermark)
<a name="l01209"></a>01209     {
<a name="l01210"></a>01210       result = nvmValidateResultOkMarked;
<a name="l01211"></a>01211     }
<a name="l01212"></a>01212     <span class="keywordflow">else</span>
<a name="l01213"></a>01213     {
<a name="l01214"></a>01214       result = nvmValidateResultError;
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216 
<a name="l01217"></a>01217     <span class="comment">/* Calculate checksum and compare with the one stored. */</span>
<a name="l01218"></a>01218     objectIndex   = 0;
<a name="l01219"></a>01219     offsetAddress = 0;
<a name="l01220"></a>01220     checksum      = NVM_CHECKSUM_INITIAL;
<a name="l01221"></a>01221 
<a name="l01222"></a>01222     <span class="comment">/* Calculate per object using the HAL. Loop over items as long as the</span>
<a name="l01223"></a>01223 <span class="comment">     * current object has got a size other than 0. Size 0 is used as a marker</span>
<a name="l01224"></a>01224 <span class="comment">     * for a NULL object. */</span>
<a name="l01225"></a>01225     <span class="keywordflow">while</span> ((*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size != 0)
<a name="l01226"></a>01226     {
<a name="l01227"></a>01227       <a class="code" href="nvm__hal_8h.html#a4536f39203aeefdb8f672d237316a762" title="Calculate checksum according to CCITT CRC16.">NVMHAL_Checksum</a>(&amp;checksum, (uint8_t *) pPhysicalAddress + NVM_HEADER_SIZE + offsetAddress, (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size);
<a name="l01228"></a>01228       offsetAddress += (*pageDesc.<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[objectIndex].size;
<a name="l01229"></a>01229       objectIndex++;
<a name="l01230"></a>01230     }
<a name="l01231"></a>01231 
<a name="l01232"></a>01232     <span class="keywordflow">if</span> (checksum != footer.checksum)
<a name="l01233"></a>01233     {
<a name="l01234"></a>01234       result = nvmValidateResultError;
<a name="l01235"></a>01235     }
<a name="l01236"></a>01236   }
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   <span class="keywordflow">return</span> result;
<a name="l01239"></a>01239 }
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l01242"></a>01242 <span class="preprocessor"></span><span class="comment">/***************************************************************************/</span>
<a name="l01260"></a>01260 <span class="keyword">static</span> uint16_t NVM_WearIndex(uint8_t *pPhysicalAddress, <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> *pPageDesc)
<a name="l01261"></a>01261 {
<a name="l01262"></a>01262   <span class="comment">/* Index to return. */</span>
<a name="l01263"></a>01263   uint16_t wearIndex = 0;
<a name="l01264"></a>01264 
<a name="l01265"></a>01265   <span class="comment">/* Temporary variable used when calculating and comparing checksums. */</span>
<a name="l01266"></a>01266   uint16_t checksum;
<a name="l01267"></a>01267 
<a name="l01268"></a>01268   <span class="comment">/* Size of the object in the wear page, including a 16 bit checksum. */</span>
<a name="l01269"></a>01269   uint16_t wearObjectSize = ((*pPageDesc-&gt;<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size + NVM_CHECKSUM_LENGTH);
<a name="l01270"></a>01270 
<a name="l01271"></a>01271 
<a name="l01272"></a>01272   <span class="comment">/* Loop over possible pages. Stop when empty page was found. */</span>
<a name="l01273"></a>01273   <span class="keywordflow">while</span> (wearIndex &lt; NVM_WEAR_CONTENT_SIZE / wearObjectSize)
<a name="l01274"></a>01274   {
<a name="l01275"></a>01275     <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>((uint8_t *)(pPhysicalAddress + NVM_HEADER_SIZE +
<a name="l01276"></a>01276                             wearIndex * wearObjectSize +
<a name="l01277"></a>01277                             (*pPageDesc-&gt;<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size
<a name="l01278"></a>01278                             ),
<a name="l01279"></a>01279                 &amp;checksum,
<a name="l01280"></a>01280                 <span class="keyword">sizeof</span>(checksum));
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     <span class="comment">/* Flip the last bit of the checksum to zero. This is a mark used to</span>
<a name="l01283"></a>01283 <span class="comment">     * determine that an object is written to this location. */</span>
<a name="l01284"></a>01284     <span class="keywordflow">if</span> ((checksum &amp; NVM_LAST_BIT_ZERO) != checksum)
<a name="l01285"></a>01285     {
<a name="l01286"></a>01286       <span class="comment">/* Break the loop and accept this location. */</span>
<a name="l01287"></a>01287       <span class="keywordflow">break</span>;
<a name="l01288"></a>01288     }
<a name="l01289"></a>01289 
<a name="l01290"></a>01290     <span class="comment">/* Not a valid position for a new write.</span>
<a name="l01291"></a>01291 <span class="comment">    * Increase the index and check again. */</span>
<a name="l01292"></a>01292     wearIndex++;
<a name="l01293"></a>01293   }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295   <span class="keywordflow">return</span> wearIndex;
<a name="l01296"></a>01296 }
<a name="l01297"></a>01297 <span class="preprocessor">#endif</span>
<a name="l01298"></a>01298 <span class="preprocessor"></span>
<a name="l01299"></a>01299 <span class="comment">/***************************************************************************/</span>
<a name="l01320"></a>01320 <span class="preprocessor">#if (NVM_FEATURE_WEAR_PAGES_ENABLED == true)</span>
<a name="l01321"></a>01321 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> NVM_WearReadIndex(uint8_t *pPhysicalAddress, <a class="code" href="structNVM__Page__Descriptor__t.html" title="Describes the properties of a page.">NVM_Page_Descriptor_t</a> *pPageDesc, uint16_t *pIndex)
<a name="l01322"></a>01322 {
<a name="l01323"></a>01323 <span class="preprocessor">#if (NVM_FEATURE_READ_VALIDATION_ENABLED == true)</span>
<a name="l01324"></a>01324 <span class="preprocessor"></span>  <span class="comment">/* Variable used for calculating checksum when validating. */</span>
<a name="l01325"></a>01325   uint16_t checksum = NVM_CHECKSUM_INITIAL;
<a name="l01326"></a>01326 <span class="preprocessor">#endif</span>
<a name="l01327"></a>01327 <span class="preprocessor"></span>
<a name="l01328"></a>01328   <span class="comment">/* Length of wear object plus checksum. */</span>
<a name="l01329"></a>01329   <span class="keyword">const</span> uint16_t wearObjectSize = ((*pPageDesc-&gt;<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size + NVM_CHECKSUM_LENGTH);
<a name="l01330"></a>01330 
<a name="l01331"></a>01331   <span class="comment">/* Return value. */</span>
<a name="l01332"></a>01332   <span class="keywordtype">bool</span> validObjectFound = <span class="keyword">false</span>;
<a name="l01333"></a>01333 
<a name="l01334"></a>01334   <span class="comment">/* Buffer used when reading checksum. */</span>
<a name="l01335"></a>01335   uint16_t readBuffer;
<a name="l01336"></a>01336 
<a name="l01337"></a>01337   <span class="comment">/* Initialize index at max plus one object. */</span>
<a name="l01338"></a>01338   *pIndex = (((uint16_t) NVM_WEAR_CONTENT_SIZE) / wearObjectSize);
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   <span class="comment">/* Loop over possible pages. Stop when first OK page is found. */</span>
<a name="l01341"></a>01341   <span class="keywordflow">while</span> ((*pIndex &gt; 0) &amp;&amp; (!validObjectFound))
<a name="l01342"></a>01342   {
<a name="l01343"></a>01343     (*pIndex)--;
<a name="l01344"></a>01344 
<a name="l01345"></a>01345     <span class="comment">/* Initialize checksum, and then calculate it from the HAL.*/</span>
<a name="l01346"></a>01346     uint8_t *temp = pPhysicalAddress + NVM_HEADER_SIZE + (*pIndex) * wearObjectSize + (*pPageDesc-&gt;<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size;
<a name="l01347"></a>01347     <a class="code" href="nvm__hal_8h.html#ae5903c7cb194ab35d7637879ca492479" title="Read data from NVM.">NVMHAL_Read</a>((uint8_t *) temp, &amp;readBuffer, <span class="keyword">sizeof</span>(readBuffer));
<a name="l01348"></a>01348 
<a name="l01349"></a>01349 <span class="preprocessor">#if (NVM_FEATURE_READ_VALIDATION_ENABLED == true)</span>
<a name="l01350"></a>01350 <span class="preprocessor"></span>    <span class="comment">/* Calculate the checksum before accepting the object. */</span>
<a name="l01351"></a>01351     checksum = NVM_CHECKSUM_INITIAL;
<a name="l01352"></a>01352     <a class="code" href="nvm__hal_8h.html#a4536f39203aeefdb8f672d237316a762" title="Calculate checksum according to CCITT CRC16.">NVMHAL_Checksum</a>(&amp;checksum, pPhysicalAddress + NVM_HEADER_SIZE + (*pIndex) * wearObjectSize, (*pPageDesc-&gt;<a class="code" href="structNVM__Page__Descriptor__t.html#a4ab6fa77a86dc69e918c0bbad637e1af" title="A pointer to the list of all the objects in the page.">page</a>)[0].size);
<a name="l01353"></a>01353     <span class="comment">/* Flips the last bit of the checksum to zero. This is a mark used to</span>
<a name="l01354"></a>01354 <span class="comment">     * determine whether we have written anything to the page. */</span>
<a name="l01355"></a>01355     <span class="keywordflow">if</span> ((uint16_t)(checksum &amp; NVM_LAST_BIT_ZERO) == readBuffer)
<a name="l01356"></a>01356 <span class="preprocessor">#else</span>
<a name="l01357"></a>01357 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (NVM_NO_WRITE_16BIT != readBuffer)
<a name="l01358"></a>01358 <span class="preprocessor">#endif</span>
<a name="l01359"></a>01359 <span class="preprocessor"></span>    {
<a name="l01360"></a>01360       validObjectFound = <span class="keyword">true</span>;
<a name="l01361"></a>01361     }
<a name="l01362"></a>01362   }
<a name="l01363"></a>01363 
<a name="l01364"></a>01364   <span class="keywordflow">return</span> validObjectFound;
<a name="l01365"></a>01365 }
<a name="l01366"></a>01366 <span class="preprocessor">#endif</span>
<a name="l01367"></a>01367 <span class="preprocessor"></span>
<a name="l01368"></a>01368 <span class="comment">/***************************************************************************/</span>
<a name="l01387"></a>01387 <span class="keyword">static</span> <span class="keywordtype">void</span> NVM_ChecksumAdditive(uint16_t *pChecksum, <span class="keywordtype">void</span> *pBuffer, uint16_t len)
<a name="l01388"></a>01388 {
<a name="l01389"></a>01389   uint8_t *pointer = (uint8_t *) pBuffer;
<a name="l01390"></a>01390   uint16_t crc = *pChecksum;
<a name="l01391"></a>01391 
<a name="l01392"></a>01392   <span class="keywordflow">while</span>(len--)
<a name="l01393"></a>01393   {
<a name="l01394"></a>01394     crc = (crc &gt;&gt; 8) | (crc &lt;&lt; 8);
<a name="l01395"></a>01395     crc ^= *pointer++;
<a name="l01396"></a>01396     crc ^= (crc &amp; 0xf0) &gt;&gt; 4;
<a name="l01397"></a>01397     crc ^= (crc &amp; 0x0f) &lt;&lt; 12;
<a name="l01398"></a>01398     crc ^= (crc &amp; 0xff) &lt;&lt; 5;
<a name="l01399"></a>01399   }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401   *pChecksum = crc;
<a name="l01402"></a>01402 }
<a name="l01403"></a>01403 
<a name="l01404"></a>01404 <span class="preprocessor">#if (NVM_FEATURE_STATIC_WEAR_ENABLED == true)</span>
<a name="l01405"></a>01405 <span class="preprocessor"></span><span class="comment">/***************************************************************************/</span>
<a name="l01414"></a>01414 <span class="keyword">static</span> <span class="keywordtype">void</span> NVM_StaticWearReset(<span class="keywordtype">void</span>)
<a name="l01415"></a>01415 {
<a name="l01416"></a>01416   uint16_t i;
<a name="l01417"></a>01417   nvmStaticWearErasesSinceReset = 0;
<a name="l01418"></a>01418   nvmStaticWearWritesInHistory  = 0;
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   <span class="keywordflow">for</span> (i = 0; (NVM_PAGES_PER_WEAR_HISTORY * i) &lt; nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a59511e0aadcd44292a5fc52c6020c391" title="Number of defined (used) pages.">userPages</a>; i += 1)
<a name="l01421"></a>01421   {
<a name="l01422"></a>01422     nvmStaticWearWriteHistory[i] = 0;
<a name="l01423"></a>01423   }
<a name="l01424"></a>01424 }
<a name="l01425"></a>01425 
<a name="l01426"></a>01426 <span class="comment">/***************************************************************************/</span>
<a name="l01437"></a>01437 <span class="keyword">static</span> <span class="keywordtype">void</span> NVM_StaticWearUpdate(uint16_t address)
<a name="l01438"></a>01438 {
<a name="l01439"></a>01439   <span class="keywordflow">if</span> (address &lt; nvmConfig-&gt;userPages)
<a name="l01440"></a>01440   {
<a name="l01441"></a>01441     <span class="comment">/* Mark page with logical address as written. */</span>
<a name="l01442"></a>01442 
<a name="l01443"></a>01443     <span class="comment">/* Bitmask to check and change the desired bit. */</span>
<a name="l01444"></a>01444     uint8_t mask = 1U &lt;&lt; (address % NVM_PAGES_PER_WEAR_HISTORY);
<a name="l01445"></a>01445 
<a name="l01446"></a>01446     <span class="keywordflow">if</span> ((nvmStaticWearWriteHistory[address / NVM_PAGES_PER_WEAR_HISTORY] &amp; mask) == 0)
<a name="l01447"></a>01447     {
<a name="l01448"></a>01448       <span class="comment">/* Flip bit. */</span>
<a name="l01449"></a>01449       nvmStaticWearWriteHistory[address / NVM_PAGES_PER_WEAR_HISTORY] |= mask;
<a name="l01450"></a>01450       <span class="comment">/* Record flip. */</span>
<a name="l01451"></a>01451       nvmStaticWearWritesInHistory++;
<a name="l01452"></a>01452     }
<a name="l01453"></a>01453 
<a name="l01454"></a>01454     <span class="comment">/* Record erase operation. */</span>
<a name="l01455"></a>01455     nvmStaticWearErasesSinceReset++;
<a name="l01456"></a>01456 
<a name="l01457"></a>01457     <span class="comment">/* Call the static wear leveler. */</span>
<a name="l01458"></a>01458     NVM_StaticWearCheck();
<a name="l01459"></a>01459   }
<a name="l01460"></a>01460 }
<a name="l01461"></a>01461 
<a name="l01462"></a>01462 <span class="comment">/***************************************************************************/</span>
<a name="l01471"></a>01471 <span class="keyword">static</span> <a class="code" href="group__EM__Drivers.html#ga7bf5621660c5ba69ac4dd3044173d35c" title="Typedef for API function errorcode return values.">Ecode_t</a> NVM_StaticWearCheck(<span class="keywordtype">void</span>)
<a name="l01472"></a>01472 {
<a name="l01473"></a>01473   <span class="comment">/* Check if there is a check already running. We do not need more of these. */</span>
<a name="l01474"></a>01474   <span class="keywordflow">if</span> (!nvmStaticWearWorking)
<a name="l01475"></a>01475   {
<a name="l01476"></a>01476     nvmStaticWearWorking = <span class="keyword">true</span>;
<a name="l01477"></a>01477     <span class="keywordflow">while</span> (nvmStaticWearErasesSinceReset / nvmStaticWearWritesInHistory &gt; <a class="code" href="group__NVM.html#gafb9b8c59c73d77fd4784034d8a7497d5" title="The threshold used to decide when to do static wear leveling.">NVM_STATIC_WEAR_THRESHOLD</a>)
<a name="l01478"></a>01478     {
<a name="l01479"></a>01479       <span class="comment">/* If all the pages have been moved in this cycle: reset. */</span>
<a name="l01480"></a>01480       <span class="keywordflow">if</span> (nvmStaticWearWritesInHistory &gt;= nvmConfig-&gt;<a class="code" href="structNVM__Config__t.html#a59511e0aadcd44292a5fc52c6020c391" title="Number of defined (used) pages.">userPages</a>)
<a name="l01481"></a>01481       {
<a name="l01482"></a>01482         NVM_StaticWearReset();
<a name="l01483"></a>01483         <span class="keywordflow">break</span>;
<a name="l01484"></a>01484       }
<a name="l01485"></a>01485 
<a name="l01486"></a>01486       <span class="comment">/* Find an address for a page that has not been rewritten. */</span>
<a name="l01487"></a>01487       uint16_t address = 0;
<a name="l01488"></a>01488       uint8_t  mask    = 1U &lt;&lt; (address % NVM_PAGES_PER_WEAR_HISTORY);
<a name="l01489"></a>01489       <span class="keywordflow">while</span> ((nvmStaticWearWriteHistory[address / NVM_PAGES_PER_WEAR_HISTORY] &amp; mask) != 0)
<a name="l01490"></a>01490       {
<a name="l01491"></a>01491         address++;
<a name="l01492"></a>01492         mask = 1U &lt;&lt; (address % NVM_PAGES_PER_WEAR_HISTORY);
<a name="l01493"></a>01493       }
<a name="l01494"></a>01494 
<a name="l01495"></a>01495       <span class="comment">/* Check for wear page. */</span>
<a name="l01496"></a>01496       <span class="keywordflow">if</span> (<a class="code" href="group__NVM.html#ggae2a292fc163eaa08574b4c061c0b1ecaa81f13288c7f3413c4dc96832d7c11117" title="Wear page.">nvmPageTypeWear</a> == NVM_PageGet(address).pageType)
<a name="l01497"></a>01497       {
<a name="l01498"></a>01498         <span class="comment">/* Flip bit. */</span>
<a name="l01499"></a>01499         nvmStaticWearWriteHistory[address / NVM_PAGES_PER_WEAR_HISTORY] |= mask;
<a name="l01500"></a>01500         <span class="comment">/* Record flip. */</span>
<a name="l01501"></a>01501         nvmStaticWearWritesInHistory++;
<a name="l01502"></a>01502       }
<a name="l01503"></a>01503       <span class="keywordflow">else</span>
<a name="l01504"></a>01504       {
<a name="l01505"></a>01505         <span class="comment">/* Must release write lock, run the write function to move the data,</span>
<a name="l01506"></a>01506 <span class="comment">         * then acquire lock again. */</span>
<a name="l01507"></a>01507 
<a name="l01508"></a>01508         <span class="comment">/* Give up write lock and open for other API operations. */</span>
<a name="l01509"></a>01509         NVM_RELEASE_WRITE_LOCK
<a name="l01510"></a>01510 
<a name="l01511"></a>01511         <a class="code" href="group__NVM.html#gad181be9b434658d3552fb311039ff691" title="Write an object or a page.">NVM_Write</a>(address, <a class="code" href="group__NVM.html#gac2786ac8b0b1ae7ae7dd2ee028cc97c7" title="All objects are copied from the old page.">NVM_WRITE_NONE_CMD</a>);
<a name="l01512"></a>01512 
<a name="l01513"></a>01513         <span class="comment">/* Require write lock to continue. */</span>
<a name="l01514"></a>01514         NVM_ACQUIRE_WRITE_LOCK
<a name="l01515"></a>01515       }
<a name="l01516"></a>01516     }
<a name="l01517"></a>01517     nvmStaticWearWorking = <span class="keyword">false</span>;
<a name="l01518"></a>01518   }
<a name="l01519"></a>01519 
<a name="l01520"></a>01520   <span class="keywordflow">return</span> <a class="code" href="group__NVM.html#gae332cf766a19b67f1ed35c9d9e95bd20" title="Return/error codes.">ECODE_EMDRV_NVM_OK</a>;
<a name="l01521"></a>01521 }
<a name="l01522"></a>01522 
<a name="l01523"></a>01523 <span class="preprocessor">#endif</span>
<a name="l01524"></a>01524 <span class="preprocessor"></span>
<a name="l01528"></a>01528 <span class="comment">/******** THE REST OF THE FILE IS DOCUMENTATION ONLY !**********************/</span>
</pre></div></div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Sep 7 08:55:12 2015</small> for Silicon Labs Energy Aware Drivers by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
