<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs Energy Aware Drivers: NVM Non-volatile Memory driver</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="nvm_doc">NVM Non-volatile Memory driver </a></h1><ul>
<li><a class="el" href="nvm__doc.html#nvm_intro">Introduction</a> </li>
<li><a class="el" href="nvm__doc.html#nvm_conf">Configuration Options</a> </li>
<li><a class="el" href="nvm__doc.html#nvm_api">The API</a> </li>
<li><a class="el" href="nvm__doc.html#nvm_example">Example</a></li>
</ul>
<p><br/>
 </p>
<h2><a class="anchor" id="nvm_intro">
Introduction</a></h2>
<p>This driver allows you to store application data in NVM. The driver supports wear leveling to maximize the lifetime of the underlying NVM system and data validation. The driver performs wear leveling by writing objects to the least used locations in the NVM system. The driver uses CCITT CRC16 for data validation.</p>
<p>It is also possible for the user to specify certain pages as wear pages. These pages can only contain a single object, but they provide better performance and drastically increase the lifetime of the memory if the object is known to a low update frequency.</p>
<p>The size and layout of the data objects to be managed by this driver must be known at compile-time.</p>
<p>This driver consists of the files <a class="el" href="nvm_8c.html" title="NVM API implementation.">nvm.c</a>, <a class="el" href="nvm_8h.html" title="NVM API definition.">nvm.h</a> and <a class="el" href="nvm__hal_8h.html" title="Non-Volatile Memory HAL.">nvm_hal.h</a>. Additionally, a implementation of <a class="el" href="nvm__hal_8c.html" title="Non-Volatile Memory HAL for EFM32/EZR32/EFR32 flash.">nvm_hal.c</a> is required for the specific NVM system to be used. A implementation of <a class="el" href="nvm__hal_8c.html" title="Non-Volatile Memory HAL for EFM32/EZR32/EFR32 flash.">nvm_hal.c</a> for EFM32/EZR32/EFR32 Flash memory is included with this driver. Driver configuration parameters and specification of the data objects are located in <a class="el" href="nvm__config_8c.html" title="NVM config implementation.">nvm_config.c</a> and <a class="el" href="nvm__config_8h.html" title="NVM config definition.">nvm_config.h</a>.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="nvm_conf">
Configuration Options</a></h2>
<p>The files <a class="el" href="nvm__config_8c.html" title="NVM config implementation.">nvm_config.c</a> and <a class="el" href="nvm__config_8h.html" title="NVM config definition.">nvm_config.h</a> contains compile-time configuration parameters and a specification of the user data structure to be managed by the driver.</p>
<p><a class="el" href="nvm__config_8c.html" title="NVM config implementation.">nvm_config.c</a> implements an user data example. The arrays colorTable, coefficientTable, etc are defined and assigned to NVM pages. A pointer to each page is assigned to the page table nvmPages. The page table also contain a page type specifier. A page can either be of type nvmPageTypeNormal or nvmPageTypeWear. Pages of type nvmPageTypeNormal are written to the unused page with the lowest erase count. For pages of type nvmPageTypeWear, the data is first attempted fitted in a already used page. If this fails, then a a new page is selected based on the lowest erase count. Pages of type nvmPageTypeWear can only contain one data object.</p>
<p>In <a class="el" href="nvm__config_8h.html" title="NVM config definition.">nvm_config.h</a>, driver features can be enabled or disabled. The following parameters may require special attention:</p>
<ul>
<li>NVM_MAX_NUMBER_OF_PAGES: Maximum number of NVM pages allocated to the driver.</li>
<li>NVM_PAGES_SCRATCH: Configure extra pages to allocate for data security and wear leveling.</li>
<li>NVM_PAGE_SIZE: Page size for the NVM system. Default is the size of the flash.</li>
</ul>
<p>Users have to be aware of the following limitations:</p>
<ul>
<li>Maximum 254 objects in a page.</li>
<li>Maximum 256 pages allocated to the driver. The default is 32 pages.</li>
</ul>
<p>Note that the different EFM32/EZR32/EFR32 families have different page sizes. Please refer to the reference manual for details.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="nvm_api">
The API</a></h2>
<p>This section contain brief descriptions of the functions defined by the API. You will find detailed information on input and output parameters and return values by clicking on the hyperlinked function names. Most functions return an error code or ECODE_EMDRV_NVM_OK is returned on success. See <a class="el" href="ecode_8h.html" title="Energy Aware drivers error code definitions.">ecode.h</a> and <a class="el" href="nvm_8h.html" title="NVM API definition.">nvm.h</a> for other error codes.</p>
<p>Your application code must include one header file: <a class="el" href="nvm_8h.html" title="NVM API definition.">nvm.h</a>.</p>
<p>The application may define the data objects allocated in RAM (and defined in <a class="el" href="nvm__config_8c.html" title="NVM config implementation.">nvm_config.c</a>) as extern if direct access to these objects is required, eg:</p>
<div class="fragment"><pre class="fragment">
  extern uint32_t colorTable[];
  </pre></div><p>The driver requires that the NVM system is erased by calling <a class="el" href="group__NVM.html#gab056662c41fc69f6b1fe44ee5f94852b">NVM_Erase()</a> before the driver initialization function <a class="el" href="group__NVM.html#gaf74bb05f10ed4959e65e85fa438ead67">NVM_Init()</a> is called. <a class="el" href="group__NVM.html#gaf74bb05f10ed4959e65e85fa438ead67">NVM_Init()</a> requires a parameter to the configuration data. A pointer to the configuration data can be obtained by calling <a class="el" href="group__NVM.html#gaec2b85094eab4e1a9f94cd0cfa8ee71b">NVM_ConfigGet()</a>.</p>
<p><a class="el" href="group__NVM.html#gad181be9b434658d3552fb311039ff691">NVM_Write()</a> takes two parameters, a page ID and a object ID. These two parameters must correspond to the definition of the user data in <a class="el" href="nvm__config_8c.html" title="NVM config implementation.">nvm_config.c</a>. For example, colorTable is assigned to page 1 in the example version of <a class="el" href="nvm__config_8c.html" title="NVM config implementation.">nvm_config.c</a>. To write the data in colorTable to NVM, call NVM_Write(MY_PAGE_1, COLOR_TABLE_ID).</p>
<p><a class="el" href="group__NVM.html#ga34880829bee50bf0fde0f6c9695dca86">NVM_Read()</a> reads the a data object or an entire page in NVM back to the structures defined for the page in RAM.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="nvm_example">
Example</a></h2>
<div class="fragment"><pre class="fragment">

  #include "em_chip.h"
  #include "em_gpio.h"
  #include "nvm.h"

  // Data object extern declarations matching the example data defined in nvm_config.c
  extern uint32_t colorTable[];
  extern uint8_t coefficientTable[];
  extern uint8_t primeNumberTable[];
  extern uint8_t bonusTable[];
  extern uint8_t privateKeyTable[];
  extern uint8_t transformTable[];
  extern int32_t safetyTable[];
  extern uint8_t bigEmptyTable[450];
  extern uint32_t singleVariable;

  // Object and page IDs maching the data defined in nvm_config.c
  typedef enum
  {
    COLOR_TABLE_ID,
    COEFFICIENT_TABLE_ID,
    PRIME_NUMBER_TABLE_ID,
    BONUS_TABLE_ID,
    PRIVATE_KEY_TABLE_ID,
    TRANSFORM_TABLE_ID,
    SINGLE_VARIABLE_ID,
    SAFETY_TABLE_ID,
    BIG_EMPTY_TABLE_ID
  } NVM_Object_Ids;

  typedef enum
  {
    MY_PAGE_1,
    MY_PAGE_2,
    MY_PAGE_3,
    MY_PAGE_4
  } NVM_Page_Ids;

  CHIP_Init();

  // Erase all pages managed by the driver and set the erasure count
  // for each page to 0. To retain the erasure count, pass NVM_ERASE_RETAINCOUNT.
  NVM_Erase(0);

  if (ECODE_EMDRV_NVM_NO_PAGES_AVAILABLE == NVM_Init(NVM_ConfigGet())
  {
    // The driver could not initialize any pages
  }

  // Write all pages to NVM
  NVM_Write(MY_PAGE_1, NVM_WRITE_ALL_CMD));
  NVM_Write(MY_PAGE_2, NVM_WRITE_ALL_CMD));
  NVM_Write(MY_PAGE_3, NVM_WRITE_ALL_CMD));
  NVM_Write(MY_PAGE_4, NVM_WRITE_ALL_CMD));

  // Set some data elements to 0
  for (i = 0; i &lt; 4; i++)
  {
    bonusTable[i] = 0;
    primeNumberTable[i] = 0;
  }

  // Read back from NVM and check
  NVM_Read(MY_PAGE_1, NVM_READ_ALL_CMD));
  NVM_Read(MY_PAGE_4, PRIME_NUMBER_TABLE_ID));

  for (i = 0; i &lt; 4; i++)
  {
    if (bonusTable[i] == 0)
    {
      // Should not happen
    }
    if (primeNumberTable[i] == 0)
    {
      // Should not happen
    }
  }

  </pre></div> </div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Sep 7 08:55:22 2015</small> for Silicon Labs Energy Aware Drivers by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
