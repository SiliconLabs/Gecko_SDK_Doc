<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Silicon Labs Energy Aware Drivers: UARTDRV Universal asynchronous receiver/transmitter driver</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="uartdrv_doc">UARTDRV Universal asynchronous receiver/transmitter driver </a></h1><p>The source files for the UART driver library resides in the emdrv/uartdrv folder, and are named <a class="el" href="uartdrv_8c.html" title="UARTDRV API implementation.">uartdrv.c</a> and <a class="el" href="uartdrv_8h.html" title="UARTDRV API definition.">uartdrv.h</a>.</p>
<ul>
<li><a class="el" href="uartdrv__doc.html#uartdrv_intro">Introduction</a> </li>
<li><a class="el" href="uartdrv__doc.html#uartdrv_conf">Configuration Options</a> </li>
<li><a class="el" href="uartdrv__doc.html#uartdrv_api">The API</a> </li>
<li><a class="el" href="uartdrv__doc.html#uartdrv_fc">Flow Control Support</a> </li>
<li><a class="el" href="uartdrv__doc.html#uartdrv_example">Example</a></li>
</ul>
<p><br/>
 </p>
<h2><a class="anchor" id="uartdrv_intro">
Introduction</a></h2>
<p>The UART driver support the UART capabilities of the USART and UART peripherals, but not the LEUART peripherals. The driver is fully reentrant and multiple driver instances can coexist. The driver does not buffer or queue data, but it queues UART transmit and receive operations. Both blocking and non-blocking transfer functions are available. Non-blocking transfer functions report transfer completion with callback functions. Transfers are done using DMA. Simple direct/forced transmit and receive functions are also available. Note that these functions are blocking and not suitable for low energy applications as they use CPU polling.</p>
<p>UART hardware flow control (CTS/RTS) is fully supported by the driver. UART software flow control (XON/XOFF) is partially supported by the driver. Read more about flow control support in <a class="el" href="uartdrv__doc.html#uartdrv_fc">Flow Control Support</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Transfer completion callback functions are called from within the DMA interrupt handler with interrupts disabled.</dd></dl>
<p><br/>
 </p>
<h2><a class="anchor" id="uartdrv_conf">
Configuration Options</a></h2>
<p>Some properties of the UARTDRV driver are compile-time configurable. These properties are set in a file named <a class="el" href="uartdrv__config_8h.html">uartdrv_config.h</a>. A template for this file, containing default values, resides in the emdrv/config folder. To configure UARTDRV for your application, provide your own configuration file. These are the available configuration parameters with default values defined. </p>
<div class="fragment"><pre class="fragment">

  // Maximum concurrent receive operations
  #define EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS    6

  // Maximum concurrent transmit operations
  #define EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS    6

  // Set to 1 to enable hardware flow control
  #define EMDRV_UARTDRV_HW_FLOW_CONTROL_ENABLE    1

  // Maximum number of driver instances. This maximum applies only when EMDRV_UARTDRV_HW_FLOW_CONTROL_ENABLE = 1
  #define EMDRV_UARTDRV_MAX_DRIVER_INSTANCES      4

  // UART software flow control code: request peer to start TX
  #define UARTDRV_FC_SW_XON                       0x11

  // UART software flow control code: request peer to stop TX
  #define UARTDRV_FC_SW_XOFF                      0x13
  </pre></div><p>The properties of each UART driver instance are set at run-time via the <a class="el" href="structUARTDRV__Init__t.html">UARTDRV_Init_t</a> data structure input parameter to the <a class="el" href="group__UARTDRV.html#ga2aa9f087a06d6bf96933d657ac4e55d6">UARTDRV_Init()</a> function.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="uartdrv_api">
The API</a></h2>
<p>This section contain brief descriptions of the functions in the API. You will find detailed information on input and output parameters and return values by clicking on the hyperlinked function names. Most functions return an error code, <a class="el" href="group__UARTDRV.html#gab58e66dca86247dadeb887240b081bfb">ECODE_EMDRV_UARTDRV_OK</a> is returned on success, see <a class="el" href="ecode_8h.html">ecode.h</a> and <a class="el" href="uartdrv_8h.html">uartdrv.h</a> for other error codes.</p>
<p>Your application code must include one header file: <em><a class="el" href="uartdrv_8h.html" title="UARTDRV API definition.">uartdrv.h</a></em>.</p>
<p><a class="el" href="group__UARTDRV.html#ga2aa9f087a06d6bf96933d657ac4e55d6">UARTDRV_Init()</a>, <a class="el" href="group__UARTDRV.html#ga3b4222031534ab6d54ca068b5fa6e596">UARTDRV_DeInit()</a> <br/>
 These functions initializes or deinitializes the UARTDRV driver. Typically  UARTDRV_Init()  is called once in your startup code.</p>
<p><a class="el" href="group__UARTDRV.html#ga34806bf9fc4d876aa6ae725ce060541b">UARTDRV_GetReceiveStatus()</a>, <a class="el" href="group__UARTDRV.html#gae5387109fb659840fa822aa6ae08b81f">UARTDRV_GetTransmitStatus()</a> <br/>
 Query the status of a current transmit or receive operations. Reports number of items (frames) transmitted and remaining.</p>
<p><a class="el" href="group__UARTDRV.html#gab9b0230941575668b73874ffe1ff01e4">UARTDRV_GetReceiveDepth()</a>, <a class="el" href="group__UARTDRV.html#gab467cb6aa9940119e4f03bd860c76266">UARTDRV_GetTransmitDepth()</a> <br/>
 Get the number of queued receive or transmit operations.</p>
<p><a class="el" href="group__UARTDRV.html#ga484ac0b78a9eccb0ec6a1d30b7cc3232">UARTDRV_Transmit()</a>, <a class="el" href="group__UARTDRV.html#ga1d8a5e61c33176ad32cf3c1330e132c6" title="Start a non-blocking receive.">UARTDRV_Receive()</a> <br/>
 <a class="el" href="group__UARTDRV.html#ga58f8120e861e2d9335e2acceec1ae4f7" title="Start a blocking transmit.">UARTDRV_TransmitB()</a>, <a class="el" href="group__UARTDRV.html#ga5d8380296aa482ac95360d3855a2e150" title="Start a blocking receive.">UARTDRV_ReceiveB()</a> <br/>
 <a class="el" href="group__UARTDRV.html#ga762bade408c1a64812467e1f58026899" title="Direct transmit without interrupts or callback.">UARTDRV_ForceTransmit()</a>, <a class="el" href="group__UARTDRV.html#gac978c9e489a78347598b3005bb49545e" title="Direct receive without interrupts or callback.">UARTDRV_ForceReceive()</a> <br/>
 Transfer functions come in both blocking and non-blocking versions, the blocking versions have an uppercase B (for Blocking) at the end of their function name. Blocking functions will not return before the transfer has completed. The non-blocking functions signal transfer completion with a callback function. <a class="el" href="group__UARTDRV.html#ga762bade408c1a64812467e1f58026899">UARTDRV_ForceTransmit()</a> and <a class="el" href="group__UARTDRV.html#gac978c9e489a78347598b3005bb49545e">UARTDRV_ForceReceive()</a> are also blocking. These two functions access the UART peripheral directly without using DMA or interrupts. <a class="el" href="group__UARTDRV.html#ga762bade408c1a64812467e1f58026899">UARTDRV_ForceTransmit()</a> does not respect flow control. <a class="el" href="group__UARTDRV.html#gac978c9e489a78347598b3005bb49545e">UARTDRV_ForceReceive()</a> forces RTS low.</p>
<p><a class="el" href="group__UARTDRV.html#ga0abd859c2a17dafe03abceeb4c96a12a">UARTDRV_Abort()</a> <br/>
 Abort current transmit or receive operations.</p>
<p><a class="el" href="group__UARTDRV.html#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet()</a>, <a class="el" href="group__UARTDRV.html#ga54bed0223f912f7a5a5e1c4a62356ffe" title="Checks the self&#39;s flow control status.">UARTDRV_FlowControlGetSelfStatus()</a>, <a class="el" href="group__UARTDRV.html#ga3ba0e9be643afcefc0962dcdb2e635a7" title="Checks the peer&#39;s flow control status.">UARTDRV_FlowControlGetPeerStatus()</a> <br/>
 Set and get flow control status of self or peer device. Note that the return value from these two functions depends on the flow control mode set by <a class="el" href="group__UARTDRV.html#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet()</a> or <a class="el" href="group__UARTDRV.html#ga2aa9f087a06d6bf96933d657ac4e55d6">UARTDRV_Init()</a>.</p>
<p><a class="el" href="group__UARTDRV.html#ga8e0d51c55deaa14695b276c3c19cd4a1">UARTDRV_FlowControlIgnoreRestrain()</a> <br/>
 Enables transmission when restrained by flow control.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="uartdrv_fc">
Flow Control Support</a></h2>
<p>If UART flow control is not required, make sure EMDRV_UARTDRV_HW_FLOW_CONTROL_ENABLE is set to 0. This reduces the code size and complexity of the driver.</p>
<p>There are two types of flow control supported, hardware and software. To enable any of these, set EMDRV_UARTDRV_HW_FLOW_CONTROL_ENABLE to 1 in <a class="el" href="uartdrv__config_8h.html">uartdrv_config.h</a>.</p>
<p><br/>
 </p>
<h3><a class="anchor" id="uartdrv_fc_hw">
Hardware Flow Control</a></h3>
<p>UART hardware flow control uses two additional pins for flow control handshaking, the clear-to-send (CTS) and ready-to-send (RTS) pins. RTS is an output and CTS is an input. These are active low signals. When CTS is high, the UART transmitter should stop sending frames. A receiver should set RTS high when it is no longer capable of receiving data.</p>
<p>To support hardware flow control, the driver includes the GPIOINT driver to emulate a hardware implementation of UART CTS/RTS flow control. Some revisions of the USART peripheral does not have CTS/RTS hardware support.</p>
<p>To enable hardware flow control, perform the following steps:</p>
<ol type="1">
<li>Set EMDRV_UARTDRV_HW_FLOW_CONTROL_ENABLE to 1.</li>
<li>In the <a class="el" href="structUARTDRV__Init__t.html">UARTDRV_Init_t</a> passed to <a class="el" href="group__UARTDRV.html#ga2aa9f087a06d6bf96933d657ac4e55d6">UARTDRV_Init()</a>, set <a class="el" href="structUARTDRV__Init__t.html#a731da22126fde90056a6e61f989bebc7">UARTDRV_Init_t::fcType</a> = uartdrvFlowControlHw.</li>
<li>Define the pins for CTS and RTS by setting ctsPort, ctsPin, rtsPort and rtsPin in the <a class="el" href="structUARTDRV__Init__t.html">UARTDRV_Init_t</a> passed to <a class="el" href="group__UARTDRV.html#ga2aa9f087a06d6bf96933d657ac4e55d6">UARTDRV_Init()</a>.</li>
</ol>
<dl class="note"><dt><b>Note:</b></dt><dd>Because of the limitations in GPIO interrupt hardware, you cannot select CTS pins in multiple driver instances with the same pin number. Ie. pin A0 and B0 cannot serve as CTS pins in two concurrent driver instances.</dd></dl>
<p>RTS is set high whenever there are no RX operations queued. The UART transmitter is halted when the CTS pin goes high. The transmitter completes the current frame before halting. DMA transfers are also halted.</p>
<p><br/>
 </p>
<h3><a class="anchor" id="uartdrv_fc_sw">
Software Flow Control</a></h3>
<p>UART software flow control uses in-band signaling, meaning the receiver sends special flow control characters to the transmitter and thereby removes the need for dedicated wires for flow control. The two symbols UARTDRV_FC_SW_XON and UARTDRV_FC_SW_XOFF are defined in <a class="el" href="uartdrv__config_8h.html">uartdrv_config.h</a>.</p>
<p>To enable support for software flow control, perform the following steps:</p>
<ol type="1">
<li>Set EMDRV_UARTDRV_HW_FLOW_CONTROL_ENABLE to 1.</li>
<li>In the <a class="el" href="structUARTDRV__Init__t.html">UARTDRV_Init_t</a> passed to <a class="el" href="group__UARTDRV.html#ga2aa9f087a06d6bf96933d657ac4e55d6">UARTDRV_Init()</a>, set <a class="el" href="structUARTDRV__Init__t.html#a731da22126fde90056a6e61f989bebc7">UARTDRV_Init_t::fcType</a> = uartdrvFlowControlSw.</li>
</ol>
<dl class="note"><dt><b>Note:</b></dt><dd>Software flow control is partial only.</dd></dl>
<p>The application must monitor buffers and make decisions on when to send XON/XOFF. XON/XOFF can be sent to the peer using <a class="el" href="group__UARTDRV.html#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet()</a>. If the application implements a specific packet format where the flow control codes may appear only in fixed positions, then the application should not use <a class="el" href="group__UARTDRV.html#ga793738f4fce0d507867e3a56d36426d2">UARTDRV_FlowControlSet()</a>, but implement read and write of XON/XOFF into packet buffers. If the application code fully implements all the flow control logic, then EMDRV_UARTDRV_HW_FLOW_CONTROL_ENABLE should be set to 0 to reduce code space.</p>
<p><br/>
 </p>
<h2><a class="anchor" id="uartdrv_example">
Example</a></h2>
<div class="fragment"><pre class="fragment">
#include "uartdrv.h"

// Define receive/transmit operation queues
DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS, rxBufferQueueI0);
DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS, txBufferQueueI0);

// Configuration for USART0, location 1
#define MY_UART                                                        \
{                                                                      \
  USART0,                                                              \
  115200,                                                              \
  _USART_ROUTE_LOCATION_LOC1,                                          \
  (USART_Stopbits_TypeDef)USART_FRAME_STOPBITS_ONE,                    \
  (USART_Parity_TypeDef)USART_FRAME_PARITY_NONE,                       \
  (USART_OVS_TypeDef)USART_CTRL_OVS_X16,                               \
  false,                                                               \
  uartdrvFlowControlHw,                                                \
  (GPIO_Port_TypeDef)AF_USART0_CS_PORT(_USART_ROUTE_LOCATION_LOC1),    \
  (GPIO_Port_TypeDef)AF_USART0_CS_PIN(_USART_ROUTE_LOCATION_LOC1),     \
  (GPIO_Port_TypeDef)AF_USART0_CLK_PORT(_USART_ROUTE_LOCATION_LOC1),   \
  (GPIO_Port_TypeDef)AF_USART0_CLK_PIN(_USART_ROUTE_LOCATION_LOC1),    \
  (UARTDRV_Buffer_FifoQueue_t *)&amp;rxBufferQueueI0,                      \
  (UARTDRV_Buffer_FifoQueue_t *)&amp;txBufferQueueI0                       \
}

UARTDRV_HandleData_t handleData;
UARTDRV_Handle_t handle = &amp;handleData;

int main(void)
{
  uint8_t buffer[10];
  UARTDRV_Init_t initDataA0 = MY_UART;

  UARTDRV_Init(handle, &amp;initDataA0);

  // Transmit data using a blocking transmit function
  UARTDRV_Transmit(handle, buffer, 10);
}

  </pre></div> </div>
<div id="footer">
<hr size="1"><address style="text-align: right;"><small>
Generated on Mon Sep 7 08:55:22 2015</small> for Silicon Labs Energy Aware Drivers by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a><small> 1.6.3 </small></address></div>
</body>
</html>
